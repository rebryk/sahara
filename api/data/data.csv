id,name,description,type,query
44600,Uniswap v3 Top Pairs by Volume,,table,"WITH all_trades AS
(SELECT
t.block_time,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b
,t.token_a_amount
,t.token_b_amount
,t.exchange_contract_address -- exchange_contract_address is the v3 LP Position
,t.tx_hash -- transaction addr (for spot checks)
,t.usd_amount --TODO: Find some way to pull in USD of any missing tokens
,c.fee/1e6 AS fee_tier --Converting fee tier to a multiplier (i.e. for 0.3%, 3000 -> 0.003)
,t.usd_amount*(c.fee/1e6) AS fees_collected_usd --USD Amount * %fee = fees collected
FROM dex.""trades"" t

LEFT JOIN uniswap_v3.""Factory_call_createPool"" c --1. Join With Pool creation on LP contract address to pull fee tier
ON t.exchange_contract_address = c.output_pool
WHERE t.project = 'Uniswap'
AND t.version = '3'
AND t.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '6 days'::INTERVAL)
AND t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
ORDER BY t.block_time DESC
),

sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,SUM(usd_amount) AS sum_usd
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS( --building the mapping table for pairs
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd,b.sum_usd,
CASE
WHEN RIGHT(a.backward_pair,4)='WETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,4)='WETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair

FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
v3_trades AS (  --clean table of trades to work with for building visuals
SELECT
atx.block_time,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair, --pick the mapped trading pair (see joins)
atx.usd_amount,
atx.fee_tier,
atx.fees_collected_usd,
atx.tx_hash
FROM all_trades atx

LEFT JOIN final_trading_pairs f1 --check if the pair maps with the forward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2 --check if the pair maps with the backward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
)

SELECT
trading_pair
,COUNT(trading_pair) AS num_trades
,SUM(usd_amount) AS total_usd
FROM v3_trades
WHERE usd_amount IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY trading_pair--, fee_tier
ORDER BY SUM(usd_amount) DESC
"
44617,Uniswap v3 Trading Volume and Fees Data Table,,table,"WITH all_trades AS
(SELECT
t.block_time,
t.token_a_address,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
 ELSE COALESCE(t.token_a_symbol,
    CONCAT(LEFT(t.token_a_address::text,3),'...',RIGHT(t.token_a_address::text,3)))
END AS token_a,
t.token_b_address,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
  ELSE COALESCE(t.token_b_symbol,
    CONCAT(LEFT(t.token_b_address::text,3),'...',RIGHT(t.token_b_address::text,3)))
END AS token_b
,t.token_a_amount
,t.token_b_amount
,t.token_a_amount_raw
,t.token_b_amount_raw
,t.exchange_contract_address -- exchange_contract_address is the v3 LP Position
,t.tx_hash -- transaction addr (for spot checks)
,t.usd_amount --TODO: Find some way to pull in USD of any missing tokens
,c.fee/1e6 AS fee_tier --Converting fee tier to a multiplier (i.e. for 0.3%, 3000 -> 0.003)
,t.usd_amount*(c.fee/1e6) AS fees_collected_usd --USD Amount * %fee = fees collected
FROM dex.""trades"" t

LEFT JOIN uniswap_v3.""Factory_call_createPool"" c --1. Join With Pool creation on LP contract address to pull fee tier
ON t.exchange_contract_address = c.output_pool
WHERE t.project = 'Uniswap'
AND t.version = '3'
AND t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '6 days'::INTERVAL)

ORDER BY t.block_time DESC
),

sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,SUM(usd_amount) AS sum_usd
FROM all_trades
GROUP BY 1,2
),

most_recent_price AS --get the latest price so we can use it to calculate TVL
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute, contract_address, symbol, decimals, price,
    ROW_NUMBER() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank --rank by time, where most recent = 1
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this and not query the history of time
    AND contract_address IN (
                            SELECT * FROM (
                                SELECT token_a_address FROM all_trades GROUP BY 1
                                UNION ALL 
                                SELECT token_b_address FROM all_trades GROUP BY 1
                                ) a
                                GROUP BY 1
                            )
    ) last_price
WHERE last_price.recency_rank = 1 --get the most recent price for liquidity joining
),

final_trading_pairs AS( --building the mapping table for pairs
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd,b.sum_usd,
CASE
WHEN RIGHT(a.backward_pair,4)='WETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,4)='WETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair

FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
v3_trades AS (--clean table of trades to work with for building visuals
SELECT
atx.block_time,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
atx.usd_amount,
atx.fee_tier,
atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1--check if the pair maps with the forward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2 --check if the pair maps with the backward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
),

dex_price AS 
( --this was originally multiple queries - combined for preformance
SELECT 
c.t_one, c.tok,
    CASE WHEN direction = 'forward' THEN (l.usd_amount::decimal)/(l.token_a_amount_raw/(10^18))::decimal --token a price
    ELSE (l.usd_amount::decimal)/(l.token_b_amount_raw/(10^18))::decimal --token b price
    END AS price_18,
    c.exchange_contract_address
FROM
    ( --get most recent price
    SELECT d.*
    FROM (
        SELECT --DISTINCT
        block_time, exchange_contract_address,
        token_a_address, token_b_address,
        token_a_amount_raw, token_b_amount_raw,
        usd_amount,
        ROW_NUMBER() OVER(PARTITION BY exchange_contract_address ORDER BY block_time DESC, usd_amount DESC) AS tr_rank
        FROM all_trades
        WHERE block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '3 days'::INTERVAL)
        AND usd_amount IS NOT NULL
        GROUP BY 1,2,3,4,5,6,7
        ) d
    WHERE d.tr_rank=1
    ) l
INNER JOIN 
    ( --dex_trades AS --get most popular pair, use that for price
    SELECT b.* FROM (
        SELECT
        direction,exchange_contract_address,t_one,t_two, tok,
        ROW_NUMBER() OVER (PARTITION BY t_one ORDER BY total_usd DESC, exchange_contract_address DESC) AS t_rank
        FROM
            (
            SELECT
            'forward' as direction,
            exchange_contract_address,
            ""token_a_address"" as t_one, ""token_b_address"" as t_two, token_a AS tok,

            SUM(usd_amount) AS total_usd
            FROM all_trades
            WHERE block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '6 days'::INTERVAL)
            AND ""token_b_address"" = '\xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'
            GROUP BY 1,2,3,4,5
            
            UNION
            
            SELECT
            'backward' as direction, --flipping token a and b here, so it's easier to calc what's the best pair for each token
            exchange_contract_address,
            ""token_b_address"" as t_one, ""token_a_address"" AS t_two, token_b AS tok,

            SUM(usd_amount) AS total_usd
            FROM all_trades
            WHERE block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '6 days'::INTERVAL)
            AND ""token_a_address"" = '\xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'
            GROUP BY 1,2,3,4,5
            ) a
        ) b
    WHERE t_rank = 1
    ) c
ON c.exchange_contract_address = l.exchange_contract_address

),


lp_withdraws AS( --get withdrawals from the lp pool
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws
FROM (SELECT exchange_contract_address FROM all_trades GROUP BY 1) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from"" --transactions where the LP is sending tokens
GROUP BY 1,2
ORDER BY 1 DESC
),

lp_deposits AS( --get deposits into the lp pool
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits
FROM (SELECT exchange_contract_address FROM all_trades GROUP BY 1) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to"" --transactions where the LP is recieving tokens
GROUP BY 1,2
ORDER BY 1 DESC
),

lp_tvl AS( --calculate tvl
SELECT
net.lp_pos, SUM(net.net_usd) AS tvl_usd --combine usd of tokens in each lp position by address
FROM (
    SELECT
    d.lp_pos,
    d.token,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --# of tokens are in the LP
     CASE WHEN p.decimals IS NOT NULL
     THEN
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) --# of tokens in the LP with appropriate decimals (only Dune logged erc20's)
    ELSE (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^18)
    END AS net_tokens_erc20,
    
    CASE WHEN p.decimals IS NOT NULL
    THEN ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price --USD value of each token in the LP (Of the ERC20s that Dune logs)
    ELSE ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^18)) * dp.price_18 --assume 18 in dex_price
    END AS net_usd
    
    FROM lp_deposits d
    INNER JOIN lp_withdraws w --join the deposts with the withdraws
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    LEFT JOIN most_recent_price p --get the price of each token (erc20)
    ON d.token = p.""contract_address""
    LEFT JOIN dex_price dp --get the price of each token (erc20)
    ON d.token = dp.t_one
    ) net
GROUP BY net.lp_pos
)

SELECT
v.trading_pair
,v.fee_tier
,COUNT(v.trading_pair) AS num_trades
,SUM(v.usd_amount) AS total_usd
,SUM(v.fees_collected_usd) AS total_fees_usd
,lp.tvl_usd AS total_value_locked
,SUM(v.fees_collected_usd) / lp.tvl_usd AS fee_to_tvl_ratio
FROM v3_trades v
LEFT JOIN lp_tvl lp
ON v.exchange_contract_address = lp.lp_pos
WHERE v.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '6 days'::INTERVAL)
AND v.usd_amount IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY v.exchange_contract_address, v.trading_pair, lp.tvl_usd, v.fee_tier
HAVING
SUM(v.usd_amount) >100000 --Filter to remove outlier/small pairs
AND lp.tvl_usd >1000 --remove more outliers / pairs with no prices
ORDER BY SUM(v.fees_collected_usd) DESC"
44614,Uniswap v3 Total Volume and Fees - Counter,,table,"WITH all_trades AS
(SELECT
t.block_time,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b
,t.token_a_amount
,t.token_b_amount
,t.exchange_contract_address -- exchange_contract_address is the v3 NFT LP Position
,t.tx_hash -- transaction addr (for spot checks)
,t.usd_amount --TODO: Find some way to pull in USD of any missing tokens
,c.fee/1e6 AS fee_tier --Converting fee tier to a multiplier (i.e. for 0.3%, 3000 -> 0.003)
,t.usd_amount*(c.fee/1e6) AS fees_collected_usd --USD Amount * %fee = fees collected
FROM dex.""trades"" t
LEFT JOIN uniswap_v3.""Factory_call_createPool"" c --1. Join With Pool creation on LP contract address to pull fee tier
ON t.exchange_contract_address = c.output_pool
WHERE t.project = 'Uniswap'
AND t.version = '3'
AND block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '6 days'::INTERVAL)
AND t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
ORDER BY t.block_time DESC
),
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,SUM(usd_amount) AS sum_usd
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS( --building the mapping table for pairs
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd,b.sum_usd,
CASE
WHEN RIGHT(a.backward_pair,4)='WETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,4)='WETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair

FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
v3_trades AS (
SELECT
atx.block_time,
--f1.trading_pair,
--f2.trading_pair,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
atx.usd_amount,
atx.fee_tier,
atx.fees_collected_usd,
atx.tx_hash
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2 --check if the pair maps with the backward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
),
pairs AS (
SELECT
trading_pair
,COUNT(trading_pair) AS num_trades
,SUM(usd_amount) AS total_usd
,SUM(fees_collected_usd) AS total_fees_usd
,fee_tier
,RANK() OVER(ORDER BY SUM(usd_amount) DESC) AS pair_rank_vol --rank by volume
,RANK() OVER(ORDER BY SUM(fees_collected_usd) DESC) AS pair_rank_fee --rank by fees
FROM v3_trades
WHERE usd_amount IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY trading_pair, fee_tier
ORDER BY SUM(usd_amount) DESC)

SELECT
SUM(total_usd)::decimal /1000000000 AS bil_usd_volume, -- all volume no filter
SUM(total_fees_usd)::decimal /1000000 AS mil_usd_fees, -- all fees no filter
SUM(CASE WHEN pair_rank_vol <=15 THEN total_usd ELSE 0 END)::decimal /1000000000 AS bil_usd_volume_top15, -- volume of top 15 pairs by volume
SUM(CASE WHEN pair_rank_fee <=15 THEN total_fees_usd ELSE 0 END)::decimal /1000000 AS mil_usd_fees_top15 -- fees of top 15 pairs by fees
FROM pairs"
45030,Uniswap v3 Trading Volume and Fees Data Table (1% Tier),,table,"WITH all_trades AS
(SELECT
t.block_time,
t.token_a_address,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,
t.token_b_address,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b
,t.token_a_amount
,t.token_b_amount
,t.exchange_contract_address -- exchange_contract_address is the v3 LP Position
,t.tx_hash -- transaction addr (for spot checks)
,t.usd_amount --TODO: Find some way to pull in USD of any missing tokens
,c.fee/1e6 AS fee_tier --Converting fee tier to a multiplier (i.e. for 0.3%, 3000 -> 0.003)
,t.usd_amount*(c.fee/1e6) AS fees_collected_usd --USD Amount * %fee = fees collected
FROM dex.""trades"" t

LEFT JOIN uniswap_v3.""Factory_call_createPool"" c --1. Join With Pool creation on LP contract address to pull fee tier
ON t.exchange_contract_address = c.output_pool
WHERE t.project = 'Uniswap'
AND t.version = '3'
AND t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '6 days'::INTERVAL)

ORDER BY t.block_time DESC
),

sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,SUM(usd_amount) AS sum_usd
FROM all_trades
GROUP BY 1,2
),

most_recent_price AS --get the latest price so we can use it to calculate TVL
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute, contract_address, symbol, decimals, price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank --rank by time, where most recent = 1
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this and not query the history of time
    ) last_price
WHERE last_price.recency_rank = 1 --get the most recent price for liquidity joining
),

final_trading_pairs AS( --building the mapping table for pairs
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd,b.sum_usd,
CASE
WHEN RIGHT(a.backward_pair,4)='WETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,4)='WETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair

FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
v3_trades AS (--clean table of trades to work with for building visuals
SELECT
atx.block_time,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
atx.usd_amount,
atx.fee_tier,
atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1--check if the pair maps with the forward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2 --check if the pair maps with the backward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
),

lp_withdraws AS( --get withdrawals from the lp pool
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from"" --transactions where the LP is sending tokens
GROUP BY 1,2
ORDER BY 1 DESC
),

lp_deposits AS( --get deposits into the lp pool
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to"" --transactions where the LP is recieving tokens
GROUP BY 1,2
ORDER BY 1 DESC
),

lp_tvl AS( --calculate tvl
SELECT
net.lp_pos, SUM(net.net_usd) AS tvl_usd --combine usd of tokens in each lp position by address
FROM (
    SELECT
    d.lp_pos,
    d.token,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --# of tokens are in the LP
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) AS net_tokens_erc20, --# of tokens in the LP with appropriate decimals (only Dune logged erc20's)
    ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price AS net_usd --USD value of each token in the LP (Of the ERC20s that Dune logs)
    FROM lp_deposits d
    INNER JOIN lp_withdraws w --join the deposts with the withdraws
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    LEFT JOIN most_recent_price p --get the price of each token (erc20)
    ON d.token = p.""contract_address""
    ) net
GROUP BY net.lp_pos
)

SELECT
v.trading_pair
--,v.fee_tier
,COUNT(v.trading_pair) AS num_trades
,SUM(v.usd_amount) AS total_usd
,SUM(v.fees_collected_usd) AS total_fees_usd
,lp.tvl_usd AS total_value_locked
,SUM(v.fees_collected_usd) / lp.tvl_usd AS fee_to_tvl_ratio
FROM v3_trades v
LEFT JOIN lp_tvl lp
ON v.exchange_contract_address = lp.lp_pos
WHERE v.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '6 days'::INTERVAL)
AND v.usd_amount IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
AND v.fee_tier = .01
GROUP BY v.exchange_contract_address, v.trading_pair, lp.tvl_usd--, v.fee_tier
HAVING
SUM(v.usd_amount) >100000 --Filter to remove outlier/small pairs
AND lp.tvl_usd >1000 --remove more outliers / pairs with no prices
ORDER BY SUM(v.fees_collected_usd) DESC"
45033,Uniswap v3 Trading Volume and Fees Data Table (0.3% Tier),,table,"WITH all_trades AS
(SELECT
t.block_time,
t.token_a_address,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,
t.token_b_address,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b
,t.token_a_amount
,t.token_b_amount
,t.exchange_contract_address -- exchange_contract_address is the v3 LP Position
,t.tx_hash -- transaction addr (for spot checks)
,t.usd_amount --TODO: Find some way to pull in USD of any missing tokens
,c.fee/1e6 AS fee_tier --Converting fee tier to a multiplier (i.e. for 0.3%, 3000 -> 0.003)
,t.usd_amount*(c.fee/1e6) AS fees_collected_usd --USD Amount * %fee = fees collected
FROM dex.""trades"" t

LEFT JOIN uniswap_v3.""Factory_call_createPool"" c --1. Join With Pool creation on LP contract address to pull fee tier
ON t.exchange_contract_address = c.output_pool
WHERE t.project = 'Uniswap'
AND t.version = '3'
AND t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '6 days'::INTERVAL)

ORDER BY t.block_time DESC
),

sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,SUM(usd_amount) AS sum_usd
FROM all_trades
GROUP BY 1,2
),

most_recent_price AS --get the latest price so we can use it to calculate TVL
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute, contract_address, symbol, decimals, price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank --rank by time, where most recent = 1
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this and not query the history of time
    ) last_price
WHERE last_price.recency_rank = 1 --get the most recent price for liquidity joining
),

final_trading_pairs AS( --building the mapping table for pairs
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd,b.sum_usd,
CASE
WHEN RIGHT(a.backward_pair,4)='WETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,4)='WETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair

FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
v3_trades AS (--clean table of trades to work with for building visuals
SELECT
atx.block_time,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
atx.usd_amount,
atx.fee_tier,
atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1--check if the pair maps with the forward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2 --check if the pair maps with the backward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
),

lp_withdraws AS( --get withdrawals from the lp pool
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from"" --transactions where the LP is sending tokens
GROUP BY 1,2
ORDER BY 1 DESC
),

lp_deposits AS( --get deposits into the lp pool
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to"" --transactions where the LP is recieving tokens
GROUP BY 1,2
ORDER BY 1 DESC
),

lp_tvl AS( --calculate tvl
SELECT
net.lp_pos, SUM(net.net_usd) AS tvl_usd --combine usd of tokens in each lp position by address
FROM (
    SELECT
    d.lp_pos,
    d.token,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --# of tokens are in the LP
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) AS net_tokens_erc20, --# of tokens in the LP with appropriate decimals (only Dune logged erc20's)
    ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price AS net_usd --USD value of each token in the LP (Of the ERC20s that Dune logs)
    FROM lp_deposits d
    INNER JOIN lp_withdraws w --join the deposts with the withdraws
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    LEFT JOIN most_recent_price p --get the price of each token (erc20)
    ON d.token = p.""contract_address""
    ) net
GROUP BY net.lp_pos
)

SELECT
v.trading_pair
--,v.fee_tier
,COUNT(v.trading_pair) AS num_trades
,SUM(v.usd_amount) AS total_usd
,SUM(v.fees_collected_usd) AS total_fees_usd
,lp.tvl_usd AS total_value_locked
,SUM(v.fees_collected_usd) / lp.tvl_usd AS fee_to_tvl_ratio
FROM v3_trades v
LEFT JOIN lp_tvl lp
ON v.exchange_contract_address = lp.lp_pos
WHERE v.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '6 days'::INTERVAL)
AND v.usd_amount IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
AND v.fee_tier = .003
GROUP BY v.exchange_contract_address, v.trading_pair, lp.tvl_usd--, v.fee_tier
HAVING
SUM(v.usd_amount) >100000 --Filter to remove outlier/small pairs
AND lp.tvl_usd >1000 --remove more outliers / pairs with no prices
ORDER BY SUM(v.fees_collected_usd) DESC"
45035,Uniswap v3 Trading Volume and Fees Data Table (0.05% Tier),,table,"WITH all_trades AS
(SELECT
t.block_time,
t.token_a_address,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,
t.token_b_address,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b
,t.token_a_amount
,t.token_b_amount
,t.exchange_contract_address -- exchange_contract_address is the v3 LP Position
,t.tx_hash -- transaction addr (for spot checks)
,t.usd_amount --TODO: Find some way to pull in USD of any missing tokens
,c.fee/1e6 AS fee_tier --Converting fee tier to a multiplier (i.e. for 0.3%, 3000 -> 0.003)
,t.usd_amount*(c.fee/1e6) AS fees_collected_usd --USD Amount * %fee = fees collected
FROM dex.""trades"" t

LEFT JOIN uniswap_v3.""Factory_call_createPool"" c --1. Join With Pool creation on LP contract address to pull fee tier
ON t.exchange_contract_address = c.output_pool
WHERE t.project = 'Uniswap'
AND t.version = '3'
AND t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '6 days'::INTERVAL)

ORDER BY t.block_time DESC
),

sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,SUM(usd_amount) AS sum_usd
FROM all_trades
GROUP BY 1,2
),

most_recent_price AS --get the latest price so we can use it to calculate TVL
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute, contract_address, symbol, decimals, price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank --rank by time, where most recent = 1
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this and not query the history of time
    ) last_price
WHERE last_price.recency_rank = 1 --get the most recent price for liquidity joining
),

final_trading_pairs AS( --building the mapping table for pairs
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd,b.sum_usd,
CASE
WHEN RIGHT(a.backward_pair,4)='WETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,4)='WETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair

FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
v3_trades AS (--clean table of trades to work with for building visuals
SELECT
atx.block_time,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
atx.usd_amount,
atx.fee_tier,
atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1--check if the pair maps with the forward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2 --check if the pair maps with the backward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
),

lp_withdraws AS( --get withdrawals from the lp pool
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from"" --transactions where the LP is sending tokens
GROUP BY 1,2
ORDER BY 1 DESC
),

lp_deposits AS( --get deposits into the lp pool
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to"" --transactions where the LP is recieving tokens
GROUP BY 1,2
ORDER BY 1 DESC
),

lp_tvl AS( --calculate tvl
SELECT
net.lp_pos, SUM(net.net_usd) AS tvl_usd --combine usd of tokens in each lp position by address
FROM (
    SELECT
    d.lp_pos,
    d.token,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --# of tokens are in the LP
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) AS net_tokens_erc20, --# of tokens in the LP with appropriate decimals (only Dune logged erc20's)
    ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price AS net_usd --USD value of each token in the LP (Of the ERC20s that Dune logs)
    FROM lp_deposits d
    INNER JOIN lp_withdraws w --join the deposts with the withdraws
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    LEFT JOIN most_recent_price p --get the price of each token (erc20)
    ON d.token = p.""contract_address""
    ) net
GROUP BY net.lp_pos
)

SELECT
v.trading_pair
--,v.fee_tier
,COUNT(v.trading_pair) AS num_trades
,SUM(v.usd_amount) AS total_usd
,SUM(v.fees_collected_usd) AS total_fees_usd
,lp.tvl_usd AS total_value_locked
,SUM(v.fees_collected_usd) / lp.tvl_usd AS fee_to_tvl_ratio
FROM v3_trades v
LEFT JOIN lp_tvl lp
ON v.exchange_contract_address = lp.lp_pos
WHERE v.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '6 days'::INTERVAL)
AND v.usd_amount IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
AND v.fee_tier = .0005
GROUP BY v.exchange_contract_address, v.trading_pair, lp.tvl_usd--, v.fee_tier
HAVING
SUM(v.usd_amount) >100000 --Filter to remove outlier/small pairs
AND lp.tvl_usd >1000 --remove more outliers / pairs with no prices
ORDER BY SUM(v.fees_collected_usd) DESC"
44612,Uniswap v3 Top Pairs by Fees,,table,"WITH all_trades AS
(SELECT
t.block_time,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b
,t.token_a_amount
,t.token_b_amount
,t.exchange_contract_address -- exchange_contract_address is the v3 LP Position
,t.tx_hash -- transaction addr (for spot checks)
,t.usd_amount --TODO: Find some way to pull in USD of any missing tokens
,c.fee/1e6 AS fee_tier --Converting fee tier to a multiplier (i.e. for 0.3%, 3000 -> 0.003)
,t.usd_amount*(c.fee/1e6) AS fees_collected_usd --USD Amount * %fee = fees collected
FROM dex.""trades"" t

LEFT JOIN uniswap_v3.""Factory_call_createPool"" c --1. Join With Pool creation on LP contract address to pull fee tier
ON t.exchange_contract_address = c.output_pool
WHERE t.project = 'Uniswap'
AND t.version = '3'
AND block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '6 days'::INTERVAL)
AND t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr

ORDER BY t.block_time DESC
),

sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,SUM(usd_amount) AS sum_usd
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS( --building the mapping table for pairs
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd,b.sum_usd,
CASE
WHEN RIGHT(a.backward_pair,4)='WETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,4)='WETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair

FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),

v3_trades AS (  --clean table of trades to work with for building visuals
SELECT
atx.block_time,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
atx.usd_amount,
atx.fee_tier,
atx.fees_collected_usd,
atx.tx_hash
FROM all_trades atx

LEFT JOIN final_trading_pairs f1 --check if the pair maps with the forward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2 --check if the pair maps with the backward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
)

SELECT
trading_pair
,COUNT(trading_pair) AS num_trades
--,SUM(usd_amount) AS total_usd
,SUM(fees_collected_usd) AS total_fees_usd
--,fee_tier
FROM v3_trades
WHERE usd_amount IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY trading_pair--, fee_tier
ORDER BY SUM(fees_collected_usd) DESC
"
44630,Uniswap v3 Fees Formatted,,table,"WITH all_trades AS
(SELECT
t.block_time,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b
,t.token_a_amount
,t.token_b_amount
,t.exchange_contract_address -- exchange_contract_address is the v3 LP Position
,t.tx_hash -- transaction addr (for spot checks)
,t.usd_amount --TODO: Find some way to pull in USD of any missing tokens
,c.fee/1e6 AS fee_tier --Converting fee tier to a multiplier (i.e. for 0.3%, 3000 -> 0.003)
,t.usd_amount*(c.fee/1e6) AS fees_collected_usd --USD Amount * %fee = fees collected
FROM dex.""trades"" t

LEFT JOIN uniswap_v3.""Factory_call_createPool"" c --1. Join With Pool creation on LP contract address to pull fee tier
ON t.exchange_contract_address = c.output_pool
WHERE t.project = 'Uniswap'
AND t.version = '3'
AND t.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '6 days'::INTERVAL)
AND t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr

ORDER BY t.block_time DESC
),
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,SUM(usd_amount) AS sum_usd
FROM all_trades
GROUP BY 1,2
),
final_trading_pairs AS( --building the mapping table for pairs
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd,b.sum_usd,
CASE
WHEN RIGHT(a.backward_pair,4)='WETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,4)='WETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair

FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
v3_trades AS (  --clean table of trades to work with for building visuals
SELECT
atx.block_time,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
atx.usd_amount,
atx.fee_tier,
atx.fees_collected_usd,
atx.tx_hash
FROM all_trades atx

LEFT JOIN final_trading_pairs f1 --check if the pair maps with the forward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2 --check if the pair maps with the backward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
)

SELECT
trading_pair
,COUNT(trading_pair) AS num_trades
,SUM(usd_amount) AS total_usd
,SUM(fees_collected_usd) AS total_fees_usd
,
CASE WHEN fee_tier = 0.01 THEN '1.00%'
WHEN fee_tier = 0.003 THEN '0.30%'
WHEN fee_tier = 0.0005 THEN '0.05%'
ELSE 'n/a'
END AS fee_tier_format
FROM v3_trades
WHERE usd_amount IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY trading_pair, fee_tier
ORDER BY SUM(fees_collected_usd) DESC
"
44618,Uniswap v3 Time Series,,table,"WITH all_trades AS
(SELECT
t.block_time,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = 'x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b
,t.token_a_amount
,t.token_b_amount
,t.exchange_contract_address -- exchange_contract_address is the v3 LP Position
,t.tx_hash -- transaction addr (for spot checks)
,t.usd_amount --TODO: Find some way to pull in USD of any missing tokens
,c.fee/1e6 AS fee_tier --Converting fee tier to a multiplier (i.e. for 0.3%, 3000 -> 0.003)
,t.usd_amount*(c.fee/1e6) AS fees_collected_usd --USD Amount * %fee = fees collected
FROM dex.""trades"" t

LEFT JOIN uniswap_v3.""Factory_call_createPool"" c --1. Join With Pool creation on LP contract address to pull fee tier
ON t.exchange_contract_address = c.output_pool
WHERE t.project = 'Uniswap'
AND t.version = '3'
AND t.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '6 days'::INTERVAL)
AND t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
ORDER BY t.block_time DESC
),
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,SUM(usd_amount) AS sum_usd
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS( --building the mapping table for pairs
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd,b.sum_usd,
CASE
WHEN RIGHT(a.backward_pair,4)='WETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,4)='WETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair

FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),

v3_trades AS ( --clean table of trades to work with for building visuals
SELECT
atx.block_time,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair, --pick the mapped trading pair (see joins)
atx.usd_amount,
atx.fee_tier,
atx.fees_collected_usd,
atx.tx_hash
FROM all_trades atx

LEFT JOIN final_trading_pairs f1 --check if the pair maps with the forward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2 --check if the pair maps with the backward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
)

SELECT
DATE_TRUNC('hour',block_time) AS day_hr
--trading_pair
,COUNT(trading_pair) AS num_trades
,SUM(usd_amount) AS total_usd
,SUM(fees_collected_usd) AS total_fees_usd
--,fee_tier
FROM v3_trades
WHERE usd_amount IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY DATE_TRUNC('hour',block_time)--,trading_pair--, fee_tier
ORDER BY SUM(usd_amount) DESC
"
55964,Uni v3 - 2D Top Volume (> $1M Volume),,chart,"WITH params AS
(
SELECT
'2 days' as tp,
--'{{LP - Top X Pairs}}'::decimal as min_pair_rank,
--'{{LP: Min Fees USD - k}}'::decimal*1000 AS min_fees, 
--'{{LP: Min LP Value USD - k}}'::decimal*1000 AS min_tvl,
--'{{LP: Min Pair Volume USD - M}}'::decimal*1e6 AS min_vol_mil
1::decimal*1e6 AS min_vol_mil,
1*1000 AS min_tvl
),


top_pools AS
(
SELECT
    ""token_a_address"", ""token_a_symbol"",
    ""token_b_address"", ""token_b_symbol"",
""exchange_contract_address"",total_usd

FROM (
    SELECT
    ""exchange_contract_address"",
    ""token_a_address"", ""token_a_symbol"",
    ""token_b_address"", ""token_b_symbol"",
    SUM(""usd_amount"") AS total_usd,
    RANK() OVER (ORDER BY SUM(""usd_amount"") DESC) AS pair_rank
    FROM dex.""trades""
    WHERE project = 'Uniswap'
    AND version = '3'
    AND category = 'DEX'
    AND block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
    AND block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
    AND (""usd_amount"" IS NOT NULL)
    GROUP BY 1,2,3,4,5
    ) a
--WHERE pair_rank <=  (SELECT min_pair_rank from params)
WHERE total_usd >= (SELECT min_vol_mil FROM params)
AND (total_usd IS NOT NULL)
),

all_trades AS
(SELECT
ROW_NUMBER() OVER () AS rown,
t.block_time,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_a_address::text = '\xcc8fa225d80b9c7d42f96e9570156c65d6caaa25' THEN 'SLP'
WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'

ELSE COALESCE(t.token_a_symbol,
CONCAT(LEFT(t.token_a_address::text,3),'...',RIGHT(t.token_a_address::text,3))
)
END AS token_a,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_b_address::text = '\xcc8fa225d80b9c7d42f96e9570156c65d6caaa25' THEN 'SLP'
WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'

ELSE COALESCE(t.token_b_symbol,
CONCAT(LEFT(t.token_b_address::text,3),'...',RIGHT(t.token_b_address::text,3))
)
END AS token_b
,t.token_a_amount
,t.token_b_amount
,t.token_a_amount_raw
,t.token_b_amount_raw
,t.token_a_address
,t.token_b_address
,t.exchange_contract_address -- exchange_contract_address is the v3 LP Position
,t.tx_hash -- transaction addr (for spot checks)
,t.usd_amount --TODO: Find some way to pull in USD of any missing tokens
,c.fee/1e6 AS fee_tier --Converting fee tier to a multiplier (i.e. for 0.3%, 3000 -> 0.003)
,t.usd_amount*(c.fee/1e6) AS fees_collected_usd, --USD Amount * %fee = fees collected
CASE WHEN t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL) THEN 'current period'
ELSE 'previous period'
END AS period
FROM dex.""trades"" t

LEFT JOIN uniswap_v3.""Factory_call_createPool"" c --1. Join With Pool creation on LP contract address to pull fee tier
ON t.exchange_contract_address = c.output_pool
WHERE t.project = 'Uniswap'
AND t.version = '3'
AND t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL - (SELECT tp FROM params)::INTERVAL) --minus twice so we can do comps
AND t.""exchange_contract_address"" IN (SELECT exchange_contract_address FROM top_pools)
ORDER BY t.block_time DESC
),

most_recent_price AS --get the latest price so we can use it to calculate TVL
(
SELECT
last_price.contract_address,
last_price.symbol, last_price.decimals,
last_price.price, last_price.minute
 FROM (
    SELECT
    minute, contract_address, symbol, decimals, price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank --rank by time, where most recent = 1
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this and not query the history of time
    AND
        (
        contract_address IN (SELECT ""token_a_address"" FROM top_pools)
        OR
        contract_address IN (SELECT ""token_b_address"" FROM top_pools)
        )
    ) last_price
WHERE last_price.recency_rank = 1 --get the most recent price for liquidity joining
),

most_recent_trade_price AS 
(
SELECT l.*,
pa.price as pricea,
pb.price as priceb,
(l.usd_amount::decimal)/(l.token_a_amount_raw/(10^18))::decimal -- ttotal trade amount (one-sided), divide that by missing token raw
--doing an 18 based exponent just for rounding/calculation
AS price_a_18, --when prices does not exist
(l.usd_amount::decimal)/(l.token_b_amount_raw/(10^18))::decimal -- total trade amount (one-sided), divide that by missing token raw
--doing an 18 based exponent just for rounding/calculation
AS price_b_18
FROM
    (
    SELECT d.*
    FROM (
        SELECT
        block_time, exchange_contract_address,
        token_a_address, token_b_address,
        token_a_amount_raw, token_b_amount_raw,
        usd_amount,
        DENSE_RANK() OVER(PARTITION BY exchange_contract_address ORDER BY block_time DESC, usd_amount DESC, rown) AS tr_rank
        FROM all_trades
        WHERE block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
        AND usd_amount IS NOT NULL
        ) d
    WHERE d.tr_rank = 1
    ) l
LEFT JOIN prices.""usd"" pa
ON pa.minute = date_trunc('minute',l.block_time)
AND pa.contract_address = l.token_a_address
LEFT JOIN prices.""usd"" pb
ON pb.minute = date_trunc('minute',l.block_time)
AND pb.contract_address = l.token_b_address

)
,
dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals

SELECT c.t_one,
    CASE WHEN direction = 'forward' THEN m.price_a_18
    ELSE m.price_b_18
    END AS price_18
    FROM
    (
    SELECT b.* FROM (
        SELECT
        direction,exchange_contract_address,t_one,t_two,
        DENSE_RANK() OVER (PARTITION BY t_one ORDER BY total_usd DESC,exchange_contract_address DESC) AS t_rank
        FROM
            (
            SELECT
            'forward' as direction,
            exchange_contract_address,
            ""token_a_address"" as t_one, ""token_b_address"" as t_two,

            SUM(usd_amount) AS total_usd
            FROM all_trades
            GROUP BY 1,2,3,4
            
            UNION
            
            SELECT
            'backward' as direction, --flipping token a and b here, so it's easier to calc what's the best pair for each token
            exchange_contract_address,
            ""token_b_address"" as t_one, ""token_a_address"" AS t_two, 

            SUM(usd_amount) AS total_usd
            FROM all_trades
            GROUP BY 1,2,3,4
            ) a
        ) b
    WHERE t_rank = 1
    ) c
    
inner JOIN most_recent_trade_price m
ON m.exchange_contract_address = c.exchange_contract_address

----
),

sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
exchange_contract_address,
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,SUM(usd_amount) AS sum_usd
FROM all_trades
GROUP BY 1,2,3
),

final_trading_pairs AS( --building the mapping table for pairs
SELECT
a.exchange_contract_address,
a.forward_pair, a.backward_pair,
a.sum_usd,b.sum_usd,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.backward_pair 
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.forward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.backward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.forward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair

FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),

v3_trades AS (  --clean table of trades to work with for building visuals
SELECT
atx.block_time,
atx.exchange_contract_address,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair, --pick the mapped trading pair (see joins)
atx.usd_amount,
atx.fee_tier,
atx.fees_collected_usd,
atx.tx_hash,
atx.period
FROM all_trades atx

LEFT JOIN final_trading_pairs f1 --check if the pair maps with the forward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.trading_pair --token order match
AND atx.exchange_contract_address = f1.exchange_contract_address --fee x order match
LEFT JOIN final_trading_pairs f2 --check if the pair maps with the backward version
ON CONCAT(atx.token_b,'/',atx.token_a) = f2.trading_pair --token order match
AND atx.exchange_contract_address = f2.exchange_contract_address  --fee x order match
),

lp_withdraws AS( --get withdrawals from the lp pool
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws,
SUM(CASE WHEN w.evt_block_time <= DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '5 minutes'::INTERVAL
    THEN w.value ELSE 0 END) AS token_withdraws_5mins,
    
SUM(CASE WHEN w.evt_block_time
    <= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
    THEN w.value ELSE 0 END)
    AS token_withdraws_prev,
SUM(CASE WHEN w.evt_block_time
    <= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL - '5 minutes'::INTERVAL)
    THEN w.value ELSE 0 END)
    AS token_withdraws_prev_5mins
    
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from"" --transactions where the LP is sending tokens
GROUP BY 1,2
),

lp_deposits AS( --get deposits into the lp pool
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits,
SUM(CASE WHEN d.evt_block_time <= DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '5 minutes'::INTERVAL
    THEN d.value ELSE 0 END) AS token_deposits_5mins,
SUM(CASE WHEN d.evt_block_time
    <= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
    THEN d.value ELSE 0 END)
    AS token_deposits_prev,
SUM(CASE WHEN d.evt_block_time
    <= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL - '5 minutes'::INTERVAL)
    THEN d.value ELSE 0 END)
    AS token_deposits_prev_5mins
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to"" --transactions where the LP is recieving tokens
GROUP BY 1,2
),

lp_tvl_pt1 AS( --calculate tvl
SELECT
net.lp_pos,
CASE WHEN SUM(net.net_usd) > SUM(net.net_usd_5mins) --smoothing out any weird active lp snapshot timing
THEN SUM(net.net_usd)
ELSE SUM(net.net_usd_5mins)
END AS tvl_usd, --combine usd of tokens in each lp position by address
CASE WHEN SUM(net.net_usd_prev) > SUM(net.net_usd_prev_5mins) --smoothing out any weird active lp snapshot timing
THEN SUM(net.net_usd_prev)
ELSE SUM(net.net_usd_prev_5mins)
END AS tvl_usd_prev --combine usd of tokens in each lp position by address

FROM (
    SELECT
    d.lp_pos,
    d.token,w.token,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --# of tokens are in the LP
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) AS net_tokens_erc20, --# of tokens in the LP with appropriate decimals (only Dune logged erc20's)
    
    CASE WHEN p.price IS NULL --when null, pull dex price, assuming 18 decimals
    THEN ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^18)) * dp.price_18
    ELSE ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price
    END AS net_usd, --USD value of each token in the LP (Of the ERC20s that Dune logs)
    CASE WHEN p.price IS NULL --when null, pull dex price, assuming 18 decimals
    THEN ((d.token_deposits_5mins - COALESCE(w.token_withdraws_5mins,0)) / (10^18)) * dp.price_18
    ELSE ((d.token_deposits_5mins - COALESCE(w.token_withdraws_5mins,0)) / (10^p.decimals)) * p.price
    END AS net_usd_5mins, --USD value of each token in the LP (Of the ERC20s that Dune logs)
    
    d.token_deposits_prev - COALESCE(w.token_withdraws_prev,0) AS net_tokens_prev, --# of tokens are in the LP
    (d.token_deposits_prev - COALESCE(w.token_withdraws_prev,0)) / (10^p.decimals) AS net_tokens_erc20_prev, --# of tokens in the LP with appropriate decimals (only Dune logged erc20's)

    CASE WHEN p.price IS NULL --when null, pull dex price, assuming 18 decimals
    THEN ((d.token_deposits_prev - COALESCE(w.token_withdraws_prev,0)) / (10^18)) * dp.price_18
    ELSE ((d.token_deposits_prev - COALESCE(w.token_withdraws_prev,0)) / (10^p.decimals)) * p.price
    END AS net_usd_prev, --USD value of each token in the LP (Of the ERC20s that Dune logs)
    CASE WHEN p.price IS NULL --when null, pull dex price, assuming 18 decimals
    THEN ((d.token_deposits_prev_5mins - COALESCE(w.token_withdraws_prev_5mins,0)) / (10^18)) * dp.price_18
    ELSE ((d.token_deposits_prev_5mins - COALESCE(w.token_withdraws_prev_5mins,0)) / (10^p.decimals)) * p.price
    END AS net_usd_prev_5mins --USD value of each token in the LP (Of the ERC20s that Dune logs)
   
    FROM lp_deposits d
    INNER JOIN lp_withdraws w --join the deposts with the withdraws
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    LEFT JOIN most_recent_price p --get the price of each token (erc20)
    ON d.token = p.""contract_address""
    LEFT JOIN dex_price dp
    ON d.token = dp.t_one
    ) net
GROUP BY net.lp_pos
),

lp_tvl AS ( --just so alignment with trades makes sense
SELECT DISTINCT
a.lp_pos, 'current period' AS period, a.tvl_usd AS tvl_usd
FROM lp_tvl_pt1 a

UNION

SELECT DISTINCT
b.lp_pos, 'previous period' AS period, b.tvl_usd_prev AS tvl_usd
FROM lp_tvl_pt1 b
),

final_stats AS(
SELECT
t.exchange_contract_address,
t.trading_pair, t.period,
t.fee_tier,
l.tvl_usd -- already calc'd
,COUNT(t.trading_pair) AS num_trades
,SUM(t.usd_amount) AS total_usd
,SUM(t.fees_collected_usd) AS total_fees_usd

FROM v3_trades t
LEFT JOIN lp_tvl l ON
t.exchange_contract_address = l.lp_pos
AND t.period = l.period
WHERE /*block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
AND*/ usd_amount IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY t.exchange_contract_address, t.trading_pair, t.period, l.tvl_usd, fee_tier
ORDER BY SUM(usd_amount) DESC
)

SELECT
DENSE_RANK() OVER(ORDER BY c.total_fees_usd DESC) AS pair_rank,
c.trading_pair,
ROUND(c.fee_tier*100,2) || '%' AS fee_tier,

c.total_fees_usd,
c.total_usd,
c.tvl_usd,
CASE WHEN (c.tvl_usd = 0) OR (c.tvl_usd IS NULL) THEN 0
ELSE (c.total_fees_usd/c.tvl_usd)
END AS fees_tvl,
CASE WHEN (c.tvl_usd = 0) OR (c.tvl_usd IS NULL) THEN 0
ELSE (c.total_fees_usd/c.tvl_usd)*(365/2)
END AS fees_tvl_apy, --Doing 365/2 to get it to APY
--c.total_usd/ (SUM(c.total_usd) OVER(PARTITION BY c.trading_pair)) AS share_of_pair_volume,

CASE WHEN ((SUM(c.total_usd) OVER(PARTITION BY c.trading_pair)) =0) OR ((SUM(c.total_usd) OVER(PARTITION BY c.trading_pair)) IS NULL) THEN 0
ELSE c.total_usd::decimal /
(SUM(c.total_usd) OVER(PARTITION BY c.trading_pair))::decimal 
END AS pair_vol_share,

c.num_trades,

CASE WHEN (p.total_fees_usd = 0) OR (p.total_fees_usd IS NULL) THEN 0
ELSE (c.total_fees_usd - p.total_fees_usd)::decimal / p.total_fees_usd::decimal
END AS change_fees_usd,
CASE WHEN (p.total_usd = 0) OR (p.total_usd IS NULL) THEN 0
ELSE (c.total_usd - p.total_usd)::decimal --/ p.total_usd::decimal
END AS change_usd_val,

/*CASE WHEN (p.total_usd = 0) OR (p.total_usd IS NULL) THEN 0
ELSE (c.total_usd - p.total_usd)::decimal / p.total_usd::decimal
END AS change_usd,*/ --volume and fees delta is the exact same, so removing

CASE WHEN (p.tvl_usd = 0) OR (p.tvl_usd IS NULL) THEN 0 
ELSE (c.tvl_usd - p.tvl_usd)::decimal / p.tvl_usd::decimal
END AS change_tvl_usd,
CASE WHEN (p.tvl_usd = 0) OR (p.tvl_usd IS NULL) THEN 0 
ELSE (c.tvl_usd - p.tvl_usd)::decimal --/ p.tvl_usd::decimal
END AS change_tvl_usd_val,

/*CASE WHEN (p.tvl_usd = 0) OR (p.tvl_usd IS NULL) OR (c.tvl_usd = 0) OR (c.tvl_usd IS NULL)  THEN 0
ELSE ((c.total_fees_usd::decimal/c.tvl_usd::decimal) - (p.total_fees_usd::decimal/p.tvl_usd::decimal))::decimal*100
--    / (c.total_fees_usd::decimal/c.tvl_usd::decimal) --making this absolute change, not % since it's already a %
END AS change_tvl_fees_usd,*/

CASE WHEN
(SUM(c.total_usd) OVER(PARTITION BY c.trading_pair)) = 0 OR ((SUM(c.total_usd) OVER(PARTITION BY c.trading_pair)) IS NULL)
OR (SUM(p.total_usd) OVER(PARTITION BY p.trading_pair)) = 0 OR ((SUM(p.total_usd) OVER(PARTITION BY p.trading_pair)) IS NULL)
THEN -1
ELSE
((c.total_usd/(SUM(c.total_usd) OVER(PARTITION BY c.trading_pair))) -
    (p.total_usd/(SUM(p.total_usd) OVER(PARTITION BY p.trading_pair))))*100
--/ (p.total_usd/(SUM(p.total_usd) OVER(p.trading_pair))) --making this absolute change, not % since it's already a %
END
AS change_pair_vol_share,

CASE WHEN (p.num_trades = 0) OR (p.num_trades IS NULL) THEN 0
ELSE (c.num_trades - p.num_trades)::decimal / p.num_trades::decimal
END AS change_trades,
CASE WHEN (p.num_trades = 0) OR (p.num_trades IS NULL) THEN 0
ELSE (c.num_trades - p.num_trades)::decimal-- / p.num_trades::decimal
END AS change_trades_val,



CONCAT(c.trading_pair, ' - ',
ROUND(c.fee_tier*100,2), '%') AS pair_fee,

CONCAT('https://info.uniswap.org/accounts#/pools/',
REPLACE(c.exchange_contract_address::text,'\','0')) AS pool_url,
CONCAT('https://etherscan.io/address/',
REPLACE(c.exchange_contract_address::text,'\','0')) AS etherscan_url

FROM (SELECT * FROM final_stats WHERE period='current period') c
LEFT JOIN (SELECT * FROM final_stats WHERE period='previous period') p
ON c.exchange_contract_address = p.exchange_contract_address

WHERE c.tvl_usd > (SELECT min_tvl FROM params)

ORDER BY c.total_fees_usd DESC"
55957,Uni v3 - 2D,,counter,"WITH all_trades AS
(SELECT
t.block_time,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'

ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'

ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b
,t.token_a_amount
,t.token_b_amount
,t.exchange_contract_address -- exchange_contract_address is the v3 NFT LP Position
,t.tx_hash -- transaction addr (for spot checks)
,t.usd_amount --TODO: Find some way to pull in USD of any missing tokens
,c.fee/1e6 AS fee_tier --Converting fee tier to a multiplier (i.e. for 0.3%, 3000 -> 0.003)
,t.usd_amount*(c.fee/1e6) AS fees_collected_usd --USD Amount * %fee = fees collected
FROM dex.""trades"" t
LEFT JOIN uniswap_v3.""Factory_call_createPool"" c --1. Join With Pool creation on LP contract address to pull fee tier
ON t.exchange_contract_address = c.output_pool
WHERE t.project = 'Uniswap'
AND t.version = '3'
AND t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
ORDER BY t.block_time DESC
),
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,SUM(usd_amount) AS sum_usd
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS( --building the mapping table for pairs
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd,b.sum_usd,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.backward_pair -- if the backward version ends in WETH, keep it
WHEN RIGHT(a.forward_pair,3)='WTH' THEN a.forward_pair -- if forwards ends in eth, flip it
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.backward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.forward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair

FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
v3_trades AS (
SELECT
atx.block_time,
--f1.trading_pair,
--f2.trading_pair,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
atx.usd_amount,
atx.fee_tier,
atx.fees_collected_usd,
atx.tx_hash
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2 --check if the pair maps with the backward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
),
pairs AS (
SELECT
trading_pair
,COUNT(trading_pair) AS num_trades
,SUM(usd_amount) AS total_usd
,SUM(fees_collected_usd) AS total_fees_usd
,fee_tier
,RANK() OVER(ORDER BY SUM(usd_amount) DESC) AS pair_rank_vol --rank by volume
,RANK() OVER(ORDER BY SUM(fees_collected_usd) DESC) AS pair_rank_fee --rank by fees
FROM v3_trades
WHERE block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
AND usd_amount IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY trading_pair, fee_tier
ORDER BY SUM(usd_amount) DESC),

get_liquidity_sums AS ( --this is to find the liquidity of each position at trade time
SELECT
--amount, amount0, amount1, 
lq.contract_address,
DATE_TRUNC('minute',lq.call_block_time) AS call_block_time,
t1.decimals AS decimals1,
t0.decimals AS decimals0,
t1.price AS price1,
t0.price AS price0,

SUM(CASE WHEN lq.tr_type = 'Mint' THEN lq.amount0 ELSE 0 END) AS liq_added0,
SUM(lq.amount0) AS liq_net0,
SUM(CASE WHEN lq.tr_type = 'Mint' THEN lq.amount1 ELSE 0 END) AS liq_added1,
SUM(lq.amount1) AS liq_net1,
COUNT(DISTINCT CASE WHEN lq.tr_type = 'Mint' THEN ""tokenId"" ELSE NULL END) AS num_positions_added

FROM (--this is a mess. We union new mints + adds to liquidity + new burns + removals from liquidity. eesh
    -- NEW MINTS
    SELECT DISTINCT * FROM ( --some pairs have duplicate rows and idk why
    SELECT
    m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
    m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
    /*l.liquidity,*/ l.""output_tokenId""::text AS ""tokenId"", 'Mint' AS tr_type
    FROM uniswap_v3.""Pair_call_mint"" m
   
    INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_mint"" l
    ON m.call_tx_hash = l.call_tx_hash
    AND m.call_block_time = l.call_block_time
    
    WHERE l.""output_tokenId""::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
    AND (m.amount != 0) --only events that do something
    --AND m.contract_address IN (SELECT exchange_contract_address FROM top_pools)
    AND m.call_success = 'true' AND l.call_success = 'true'
    -- since we only want liquidity added at this moment, we can filter on date
    AND m.call_block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
    AND l.call_block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
    
    UNION
    --ADDITIONS TO LIQUIDITY INCREASE
    SELECT
    m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
    m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
    /*l.liquidity,*/ (l.params->'tokenId')::text AS ""tokenId"", 'Mint' AS tr_type
    FROM uniswap_v3.""Pair_call_mint"" m
   
    INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_increaseLiquidity"" l
    ON m.call_tx_hash = l.call_tx_hash
    AND m.call_block_time = l.call_block_time
    
    WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
    AND (m.amount != 0) --only events that do something
    --AND m.contract_address IN (SELECT exchange_contract_address FROM top_pools)
    AND m.call_success = 'true' AND l.call_success = 'true'
    -- since we only want liquidity added at this moment, we can filter on date
    AND m.call_block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
    AND l.call_block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)

    UNION
    -- NEW BURNS // uniswap_v3.""NonfungibleTokenPositionManager_call_burn"" doesn't do anything so jsut decrease liq
    SELECT --negate because these are burns
    (-1)*b.amount AS amount, (-1)*b.output_amount0 AS amount0, (-1)*b.output_amount1 AS amount1, b.contract_address,
    b.call_block_time, b.call_tx_hash, b.""tickLower"", b.""tickUpper"",
    /*l.liquidity,*/ (l.params->'tokenId')::text AS tokenId, 'Burn' AS tr_type
    FROM uniswap_v3.""Pair_call_burn"" b
    
    INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_decreaseLiquidity"" l
    ON b.call_tx_hash = l.call_tx_hash
    AND b.call_block_time = l.call_block_time
    
    WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
    AND (b.amount != 0) --only events that do something
   -- AND b.contract_address IN (SELECT exchange_contract_address FROM top_pools)
    AND b.call_success = 'true'
    AND l.call_success = 'true'
    -- since we only want liquidity added at this moment, we can filter on date
    AND b.call_block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
    AND l.call_block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
    ) ld
    ) lq
    INNER JOIN uniswap_v3.""Factory_call_createPool"" p --get pool data
    ON lq.contract_address = p.output_pool
    INNER JOIN prices.""usd"" t0 --inner since we're summing all up
    ON DATE_TRUNC('minute',lq.call_block_time) = t0.minute
    AND p.""tokenA"" = t0.""contract_address""
    INNER JOIN prices.""usd"" t1 --inner since we're summing all up
    ON DATE_TRUNC('minute',lq.call_block_time) = t1.minute
    AND p.""tokenB"" = t1.""contract_address""

WHERE t1.minute >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
AND t0.minute >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
GROUP BY 1,2,3,4,5,6
),

total_liq AS (
SELECT
DATE_TRUNC('hour',call_block_time) AS block_hour,
SUM(tvl_usd_added) AS liq_usd_added,
SUM(tvl_usd_net) AS liq_usd_net,
SUM(num_positions_added) AS num_new_positions

FROM
(
    SELECT DISTINCT
    l.call_block_time,
    l.contract_address,
    l.num_positions_added,
    
    -- Sum all liquidity added (liquidity volume) by hour
    (CASE WHEN (l.liq_added0 IS NULL) OR (l.liq_added0 IS NULL) OR (decimals0 IS NULL) THEN 0
    ELSE price0*(l.liq_added0/10^decimals0)
    END)
    +
    (CASE WHEN (l.liq_added1 IS NULL) OR (l.liq_added1 IS NULL) OR (decimals1 IS NULL) THEN 0
    ELSE price1*(l.liq_added1/10^decimals1)
    END)
    AS tvl_usd_added,
    -- Sum all net liquidity added by hour (change in liquidity)
    (CASE WHEN (l.liq_net0 IS NULL) OR (l.liq_net0 IS NULL) OR (decimals0 IS NULL) THEN 0
    ELSE price0*(l.liq_net0/10^decimals0)
    END)
    +
    (CASE WHEN (l.liq_net1 IS NULL) OR (l.liq_added1 IS NULL) OR (decimals1 IS NULL) THEN 0
    ELSE price1*(l.liq_net1/10^decimals1)
    END)
    AS tvl_usd_net
    
    FROM get_liquidity_sums l
    
) bh
GROUP BY 1

),
trade_counters AS
(SELECT
SUM(total_usd)::decimal /1000000000 AS bil_usd_volume, -- all volume no filter
SUM(total_fees_usd)::decimal /1000000 AS mil_usd_fees, -- all fees no filter
SUM(CASE WHEN pair_rank_vol <=15 THEN total_usd ELSE 0 END)::decimal /1000000000 AS bil_usd_volume_top15, -- volume of top 15 pairs by volume
SUM(CASE WHEN pair_rank_fee <=15 THEN total_fees_usd ELSE 0 END)::decimal /1000000 AS mil_usd_fees_top15--, -- fees of top 15 pairs by fees


FROM pairs
),
liq_counters AS(
SELECT
SUM(liq_usd_added)::decimal /1000000 AS mil_lp_usd_added,
SUM(liq_usd_net)::decimal /1000000 AS mil_lp_usd_net
FROM total_liq
)

SELECT
bil_usd_volume, mil_usd_fees,
bil_usd_volume_top15, mil_usd_fees_top15,
mil_lp_usd_added, mil_lp_usd_net
FROM trade_counters,liq_counters
"
55949,Uni v3 -2D Top LPs by Fees Earned,,table,"WITH params AS
(
SELECT
'2 days' as tp,
--'{{LP - Top X Pairs}}'::decimal as min_pair_rank,
'{{3 Min LP Fees - k}}'::decimal*1000 AS min_fees, 
'{{2 Min LP TVL - k}}'::decimal*1000 AS min_tvl,
'{{1 Min Pair Volume - M}}'::decimal*1e6 AS min_vol_mil
),

top_pools AS
(
SELECT
""exchange_contract_address"",total_usd, total_fees
FROM (
    SELECT
    ""exchange_contract_address"",
    p.fee,
    SUM(""usd_amount"") AS total_usd,
    SUM(""usd_amount""*p.fee/1e6) AS total_fees,
    RANK() OVER (ORDER BY SUM(""usd_amount"") DESC) AS pair_rank
    FROM dex.""trades"" t
    INNER JOIN uniswap_v3.""Factory_call_createPool"" p --get pool data
    ON t.exchange_contract_address = p.output_pool
    WHERE project = 'Uniswap'
    AND version = '3'
    AND category = 'DEX'
    AND block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
    AND block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
    --AND ""exchange_contract_address"" = '\x8ad599c3a0ff1de082011efddc58f1908eb6e6d8'
    AND (""usd_amount"" IS NOT NULL)
    GROUP BY 1,2
    ) a
--WHERE pair_rank <=  (SELECT min_pair_rank from params)
WHERE total_usd >= (SELECT min_vol_mil FROM params)
AND (total_usd IS NOT NULL)
),

v3_trunc AS (
SELECT *--,
--ROW_NUMBER() OVER () AS rown
FROM
    (
    SELECT
    --t.block_time,
    date_trunc('hour',t.block_time) + --5 minute blocks // This is for preformance: takes ~5 mins to run if we trunc by minute, ~3 mins by 5 mins, 1 min by 15 minsm 1 min by hour... trying to find a happy medium
        ( --chose 15 minutes as a tradeoff between accuracy (shorter window) and filter flexibility (bigger windwo)
        (FLOOR(extract(minute FROM t.block_time)::int / 15)*15 || 'minutes')::interval --trying 5 mins for accuracy
        )
    AS block_fifteenmins, --make this hour if query hangs
    
    t.""exchange_contract_address"",
    t.""token_a_address"",t.""token_a_symbol"",
    t.""token_b_address"",t.""token_b_symbol"",
    CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
    WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
    WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
    WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
    WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
    WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
    WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
    WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
    WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
    WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
    WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
    WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
    WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
    WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
    WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
    WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
    WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
    WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
    WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
    WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
    WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
    WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
    WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
    WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
    WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
    WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
    WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
    WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
    WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
    WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
    WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
    WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
    WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
    WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
    WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
    WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
    WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
    WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
    WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
    WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
    WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
    WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
    WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
    
    ELSE COALESCE(t.token_a_symbol,
    CONCAT(LEFT(t.token_a_address::text,3),'...',RIGHT(t.token_a_address::text,3))
    )
    END AS token_a,
    CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
    WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
    WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
    WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
    WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
    WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
    WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
    WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
    WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
    WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
    WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
    WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
    WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
    WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
    WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
    WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
    WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
    WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
    WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
    WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
    WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
    WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
    WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
    WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
    WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
    WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
    WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
    WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
    WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
    WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
    WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
    WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
    WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
    WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
    WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
    WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
    WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
    WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
    WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
    WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
    WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
    WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
    WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
    
    ELSE COALESCE(t.token_b_symbol,
    CONCAT(LEFT(t.token_b_address::text,3),'...',RIGHT(t.token_b_address::text,3))
    )
    END AS token_b,
    AVG(s.liquidity) as weighted_liquidity,
    SUM(t.""usd_amount"") AS usd_vol,
    SUM(t.token_a_amount_raw) AS token_a_amount_raw_sum,
    SUM(t.token_b_amount_raw) AS token_b_amount_raw_sum,

    --AVG(s.tick) AS avg_tick,
    SUM(s.tick*t.""usd_amount"")/SUM(t.""usd_amount"") AS weighted_tick
    
    FROM dex.""trades"" t
    
    INNER JOIN uniswap_v3.""Pair_evt_Swap"" s -- Get liquidity available and tick value of the trade
        ON t.tx_hash = s.evt_tx_hash
        AND t.block_time = s.evt_block_time
        AND t.""exchange_contract_address"" = s.""contract_address""

    
    WHERE t.project = 'Uniswap'
    AND t.version = '3'
    AND t.category = 'DEX'
    AND t.block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
    AND s.evt_block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
    AND t.""exchange_contract_address"" IN (SELECT exchange_contract_address FROM top_pools)
    AND (t.""usd_amount"">0) AND (t.""usd_amount"" IS NOT NULL)
    
    GROUP BY 1,2,3,4,5,6,7,8
    ) v
WHERE
(
    '{{7 Exclude}}' NOT LIKE '%' || token_a || '%'
    AND
    '{{7 Exclude}}' NOT LIKE '%' ||token_a || '%'
)
AND
(1 = 
    CASE
    WHEN '{{6 Include}}' = 'All Tokens' THEN 1
    WHEN '{{6 Include}}' LIKE '%' || token_a || '%' THEN 1
    WHEN '{{6 Include}}' LIKE '%' || token_b || '%' THEN 1
    ELSE 0
    END
)
),

dex_price AS 
( --this was originally multiple queries that I combined for preformance, so it looks very confusing now
SELECT 
c.t_one,
    CASE WHEN direction = 'forward' THEN (l.usd_vol::decimal)/(l.token_a_amount_raw_sum/(10^18))::decimal --token a price
    ELSE (l.usd_vol::decimal)/(l.token_b_amount_raw_sum/(10^18))::decimal --token b price
    END AS price_18
FROM
    ( --get most recent price
    SELECT d.*
    FROM (
        SELECT DISTINCT
        block_fifteenmins, exchange_contract_address,
        token_a_address, token_b_address,
        token_a_amount_raw_sum, token_b_amount_raw_sum,
        usd_vol,
        DENSE_RANK() OVER(PARTITION BY exchange_contract_address ORDER BY block_fifteenmins DESC, usd_vol DESC) AS tr_rank
        FROM v3_trunc
        WHERE block_fifteenmins >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
        AND usd_vol IS NOT NULL
        ) d
    WHERE d.tr_rank = 1
    ) l
INNER JOIN 
    ( --dex_trades AS --get most popular pair, use that for price
    SELECT b.* FROM (
        SELECT
        direction,exchange_contract_address,t_one,t_two,
        DENSE_RANK() OVER (PARTITION BY t_one ORDER BY total_usd DESC,exchange_contract_address DESC) AS t_rank
        FROM
            (
            SELECT
            'forward' as direction,
            exchange_contract_address,
            ""token_a_address"" as t_one, ""token_b_address"" as t_two,

            SUM(usd_vol) AS total_usd
            FROM v3_trunc
            WHERE
            ""token_b_address"" = '\xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'
            GROUP BY 1,2,3,4
            
            UNION
            
            SELECT
            'backward' as direction, --flipping token a and b here, so it's easier to calc what's the best pair for each token
            exchange_contract_address,
            ""token_b_address"" as t_one, ""token_a_address"" AS t_two, 
    
            SUM(usd_vol) AS total_usd
            FROM v3_trunc
            WHERE
            ""token_a_address"" = '\xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'
            GROUP BY 1,2,3,4
            ) a
        ) b
    WHERE t_rank = 1
    ) c
ON c.exchange_contract_address = l.exchange_contract_address

),

final_trading_pairs AS( --building the mapping table for pairs
SELECT
a.exchange_contract_address,
a.forward_pair, a.backward_pair,
a.sum_usd,b.sum_usd,

CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.backward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.forward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b --Caring less about this now, just force ETH to thr right, otherwise take the UNI order
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair

FROM 
    ( --sum_pairs AS
    SELECT 
    exchange_contract_address,
    CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
    ,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
    ,SUM(usd_vol) AS sum_usd

    FROM v3_trunc
    GROUP BY 1,2,3
    ) a
LEFT JOIN 
    (
    SELECT --sum_pairs AS
    exchange_contract_address,
    CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
    ,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
    ,SUM(usd_vol) AS sum_usd
    
    FROM v3_trunc
    GROUP BY 1,2,3
    )
    b
ON a.forward_pair = b.backward_pair
AND a.exchange_contract_address = b.exchange_contract_address
),

get_liquidity AS ( --this is to find the liquidity of each position at trade time
SELECT * FROM
    (
    SELECT *,
    lead(running_amount, 1, running_amount) OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS next_lp_amount
    FROM
    (
        SELECT amount, amount0, amount1, contract_address,call_block_time, call_tx_hash,
        ""tickLower"",""tickUpper"", /*liquidity,*/ ""tokenId"", tr_type,
        lead(call_block_time, 1, now()) OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS next_lp, --to help key in on the right lp when joining - for preformance
        lag(call_block_time, 1, '01-01-2000') OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS previous_lp,
        SUM(amount) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount,
        SUM(amount0) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount0,
        SUM(amount1) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount1,
        MIN(call_block_time) OVER(PARTITION BY ""tokenId"") AS liq_start
        
        FROM ( --this is a mess. We union new mints + adds to liquidity + new burns + removals from liquidity. eesh
            -- NEW MINTS
            SELECT
            m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
            m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
            /*l.liquidity,*/ l.""output_tokenId""::text AS ""tokenId"", 'Mint' AS tr_type
            FROM uniswap_v3.""Pair_call_mint"" m
           
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_mint"" l
            ON m.call_tx_hash = l.call_tx_hash
            AND m.call_block_time = l.call_block_time
            
            WHERE l.""output_tokenId""::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (m.amount != 0) --only events that do something
            AND m.contract_address IN (SELECT exchange_contract_address FROM top_pools)
            AND m.call_success = 'true' AND l.call_success = 'true'
            
            UNION ALL
            --ADDITIONS TO LIQUIDITY INCREASE
            SELECT
            m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
            m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
            /*l.liquidity,*/ (l.params->'tokenId')::text AS ""tokenId"", 'Mint' AS tr_type
            FROM uniswap_v3.""Pair_call_mint"" m
           
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_increaseLiquidity"" l
            ON m.call_tx_hash = l.call_tx_hash
            AND m.call_block_time = l.call_block_time
            
            WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (m.amount != 0) --only events that do something
            AND m.contract_address IN (SELECT exchange_contract_address FROM top_pools)
            AND m.call_success = 'true' AND l.call_success = 'true'
            
            UNION ALL
            -- NEW BURNS // uniswap_v3.""NonfungibleTokenPositionManager_call_burn"" doesn't do anything so jsut decrease liq
            SELECT --negate because these are burns
            (-1)*b.amount AS amount, (-1)*b.output_amount0 AS amount0, (-1)*b.output_amount1 AS amount1, b.contract_address,
            b.call_block_time, b.call_tx_hash, b.""tickLower"", b.""tickUpper"",
            /*l.liquidity,*/ (l.params->'tokenId')::text AS tokenId, 'Burn' AS tr_type
            FROM uniswap_v3.""Pair_call_burn"" b
            
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_decreaseLiquidity"" l
            ON b.call_tx_hash = l.call_tx_hash
            AND b.call_block_time = l.call_block_time
            
            WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (b.amount != 0) --only events that do something
            AND b.contract_address IN (SELECT exchange_contract_address FROM top_pools)
            AND b.call_success = 'true'
            AND l.call_success = 'true'
            
            ) lq
        ) la
    --Since we already calc'd running amounts, we can ditch all LP events besides the last one before the 2 day / stuff within the 2 day.
    -- We'll use 'next LP' to do this
    WHERE next_lp >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
) a
WHERE running_amount >0 --check this later, but we should be able to ditch these too since matching is on block time and next lp

),

avail_lps AS(
SELECT b.*,
SUM(lp_amount_per_tick) OVER(PARTITION BY block_fifteenmins, ""exchange_contract_address"") AS in_range_lp,
lp_amount_per_tick / (SUM(lp_amount_per_tick) OVER(PARTITION BY block_fifteenmins, ""exchange_contract_address"")) AS share_at_tick,
usd_amount*(fee/1e6)*(
lp_amount_per_tick / (SUM(lp_amount_per_tick) OVER(PARTITION BY block_fifteenmins, ""exchange_contract_address""))
) AS fees_collected
FROM
(
    SELECT a.*, p.fee
    FROM (
        SELECT
        t.block_fifteenmins,
        t.""exchange_contract_address"",
        t.token_a_address, --for joining
        t.token_b_address, --for joining
        t.token_a,
        t.token_b,
        t.usd_vol AS usd_amount,
        t.weighted_liquidity,
        
        g.running_amount AS lp_amount,--liquidity value of the distinct lp position
        1.0001^(g.""tickUpper"" - g.""tickLower"") AS tick_range,
        g.running_amount / (1.0001^(g.""tickUpper"" - g.""tickLower"")) AS lp_amount_per_tick,
        g.running_amount0 AS lp_amount0,
        g.running_amount1 AS lp_amount1,
        liq_start,
        g.""tokenId"",
        g.""tickLower"", g.""tickUpper"", g.amount0, g.amount1, g.next_lp, g.next_lp_amount,
        g.call_block_time,
        ROW_NUMBER() OVER (PARTITION BY t.block_fifteenmins, g.""tokenId"" ORDER BY g.call_block_time DESC) AS token_lp_rank --Find the most recent liquidity for the lp position for each trade
        ---^ (if the lp adds/removes a bunch of times, we'll see all their transactions. So we want to pick the last one because that should be what their liquidity was at the time of the trade.)
        FROM v3_trunc t
        
        
        INNER JOIN get_liquidity g-- all liquidity options
        ON g.contract_address = t.exchange_contract_address
            AND g.call_block_time <= t.block_fifteenmins --Get previous liquidity statuses before the trade
            AND g.next_lp > t.block_fifteenmins -- pick the transaction whose next transaction is after this trade (i.e. only the latest one)
            AND g.previous_lp <= t.block_fifteenmins --just adding to do it
            AND g.""tickLower"" <= t.weighted_tick
            AND g.""tickUpper"" >= t.weighted_tick
        
        WHERE
        /*t.project = 'Uniswap'
        AND t.version = '3'
        AND t.block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
        AND t.usd_amount > 0 AND (t.usd_amount IS NOT NULL)
        AND*/ g.running_amount >0 --since we join on next > tx_time, we can do this to remove inactive LPs
        AND
        t.""exchange_contract_address"" IN (SELECT exchange_contract_address FROM top_pools)
        AND t.block_fifteenmins >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
        AND g.next_lp >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
        
        ) a
        INNER JOIN uniswap_v3.""Factory_call_createPool"" p --get pool data
        ON a.exchange_contract_address = p.output_pool
        WHERE token_lp_rank = 1
    ) b
),

fees_by_lp AS (
SELECT *,
RANK() OVER (PARTITION BY ""tokenId"" ORDER BY tvl_usd DESC, block_fifteenmins DESC) AS token_tvl_usd_rank
FROM
(
    --i was getting divide by zero... not sure why so this
    --total liquidity still a tiny bit off.... maybe it's collections? Figure this out
    SELECT DISTINCT l.*, --some pairs have duplicate rows and idk why
    fees_collected AS fees_received_usd,
    CASE WHEN (l.lp_amount0 IS NULL) OR (l.lp_amount0 IS NULL) OR (t0.decimals IS NULL)
    THEN (l.lp_amount0/10^18) --if null, assume 18
    ELSE (l.lp_amount0/10^t0.decimals)
    END AS amount_a,
    
    CASE WHEN (l.lp_amount1 IS NULL) OR (l.lp_amount1 IS NULL) OR (t1.decimals IS NULL)
    THEN (l.lp_amount1/10^18)
    ELSE (l.lp_amount1/10^t1.decimals)
    END AS amount_b,
    
    CASE WHEN (l.lp_amount0 IS NULL) OR (l.lp_amount0 IS NULL) OR (t0.decimals IS NULL)
    THEN dpa.price_18*(l.lp_amount0/10^18)
    ELSE t0.price*(l.lp_amount0/10^t0.decimals)
    END AS amount_a_usd,
    
    CASE WHEN (l.lp_amount1 IS NULL) OR (l.lp_amount1 IS NULL) OR (t1.decimals IS NULL)
    THEN dpb.price_18*(l.lp_amount1/10^18)
    ELSE t1.price*(l.lp_amount1/10^t1.decimals)
    END AS amount_b_usd,
    (CASE WHEN (l.lp_amount0 IS NULL) OR (l.lp_amount0 IS NULL) OR (t0.decimals IS NULL)
    THEN dpa.price_18*(l.lp_amount0/10^18)
    ELSE t0.price*(l.lp_amount0/10^t0.decimals)
    END)
    +
    (CASE WHEN (l.lp_amount1 IS NULL) OR (l.lp_amount1 IS NULL) OR (t1.decimals IS NULL)
    THEN dpb.price_18*(l.lp_amount1/10^18)
    ELSE t1.price*(l.lp_amount1/10^t1.decimals)
    END)
    AS tvl_usd,
    --SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"") AS concentrated_liquidity,
    
    CASE WHEN
    ((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    OR ((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    ELSE l.lp_amount::decimal / ((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address""))::decimal)
    END AS share_of_pool,
     CASE WHEN
    ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    OR ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    ELSE l.lp_amount_per_tick::decimal / ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address""))::decimal)
    END AS share_of_pool_per_tick,
    
   /* CASE WHEN
    ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    OR ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    ELSE l.lp_amount_per_tick::decimal / (l.liquidity::decimal)
    END AS share_of_pool_per_tick_liquidity,*/
    
    --CASE WHEN
    --((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    --OR ((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    --ELSE
    --(l.usd_amount::decimal * (p.fee/1e6)::decimal) *
    --(l.lp_amount::decimal / ((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")))::decimal)
    --END AS fees_received_usd_v2_OLD, 
    --TODO - VALIDATE IF FEES ARE CALC'D AS PROPORTION OF LIQUIDITY PER TICK, OR SOMETHING ELSE (LIKE SQRT): https://uniswap.org/whitepaper-v3.pdf
    CASE WHEN
    ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    OR ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    ELSE
    (l.usd_amount::decimal * (p.fee/1e6)::decimal) *
    (l.lp_amount_per_tick::decimal / ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")))::decimal)
    END AS fees_received_usd_old, --TODO: See if I'm calc'ing this right, or of width of ticks has an impact?
    
    
    /*CASE WHEN
    ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    OR ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    ELSE
    (l.usd_amount::decimal * (p.fee/1e6)::decimal) *
    (l.lp_amount_per_tick::decimal / (l.liquidity::decimal))
    END AS fees_received_usd_liq, --TODO: See if I'm calc'ing this right, or of width of ticks has an impact?
    */
    
    --p.fee,
    p.fee/1e6::decimal AS fee_tier,
    p.""tokenA"", p.""tokenB"",
     CASE  --assuming 18 for decimals if null
        WHEN ""tickLower"" < 0 THEN (1.0001^(""tickLower"")) * (10^(ABS(COALESCE(t0.decimals,18)-COALESCE(t1.decimals,18))))
        ELSE (1.0001^(""tickLower"")) / (10^(ABS(COALESCE(t0.decimals,18)-COALESCE(t1.decimals,18))))
    END AS price_lower,
    CASE 
        WHEN ""tickUpper"" < 0 THEN (1.0001^(""tickUpper"")) * (10^(ABS(COALESCE(t0.decimals,18)-COALESCE(t1.decimals,18))))
        ELSE (1.0001^(""tickUpper"")) / (10^(ABS(COALESCE(t0.decimals,18)-COALESCE(t1.decimals,18))))
    END AS price_upper,
    
    RANK() OVER (PARTITION BY l.""tokenId"" ORDER BY l.block_fifteenmins DESC) AS token_tvl_rank --Find the tvl by lp when the last trade was made.
    
    FROM avail_lps l
    
    INNER JOIN uniswap_v3.""Factory_call_createPool"" p --get pool data
    ON l.exchange_contract_address = p.output_pool
    LEFT JOIN prices.""usd"" t0
    ON DATE_TRUNC('minute',l.call_block_time) = t0.minute
    AND l.token_a_address = t0.""contract_address""
    LEFT JOIN prices.""usd"" t1
    ON DATE_TRUNC('minute',l.call_block_time) = t1.minute
    AND l.token_b_address = t1.""contract_address""
    LEFT JOIN dex_price dpa
    ON l.token_a_address = dpa.t_one
    AND t0.price IS NULL
    LEFT JOIN dex_price dpb
    ON l.token_b_address = dpb.t_one
    AND t1.price IS NULL
    
    WHERE /*token_lp_rank = 1 -- only pick most recent liquidity position per lp
    AND*/ lp_amount>0 
    AND usd_amount > 0 --we're losing some pairs that dune doesn't have... to do for later maybe is try to map these (maybe sqrt price?)
    -- fees per Lp is total_usd * fee_tier * share_of_pool
    AND t0.minute >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
    AND t1.minute >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
)  a

),

final_lps AS
(
SELECT
lp.token_a,
lp.token_b,
f1.trading_pair,
f2.trading_pair,
COALESCE(f1.trading_pair, f2.trading_pair) AS pair,
lp.""tokenId"",
lp.liq_start,
lp.exchange_contract_address,
--""tickLower"" as tick_lower,
--""tickUpper"" as tick_upper,
CASE WHEN (lp.price_upper IS NULL) THEN 0
WHEN (f1.trading_pair IS NULL) THEN lp.price_lower --if backwards, keep, if forwards flip
WHEN (lp.price_upper = 0) THEN 0
ELSE 1/lp.price_upper
END AS atob_lower_bound, --since we're doing 1/price

CASE WHEN(lp.price_lower IS NULL) THEN 0
WHEN (f1.trading_pair IS NULL) THEN lp.price_upper
WHEN (lp.price_lower = 0) THEN 0
ELSE 1/lp.price_lower
END AS atob_upper_bound, --upper and lower flip. This isn't a mistake

fee_tier,
CONCAT('https://app.uniswap.org/#/pool/',""tokenId"") AS url,
--MAX(CASE WHEN next_lp IS NULL THEN now() ELSE next_lp END) AS last_lp,
SUM(CASE WHEN lp.token_tvl_rank = 1 THEN lp.lp_amount ELSE 0 END) AS last_tvl,--to grab the last tvl. Anything that's not the most recent one is ignored.
SUM(CASE WHEN token_tvl_usd_rank =1 THEN lp.tvl_usd ELSE 0 END)
    AS most_tvl_usd, --to grab the max tvl. There is some weird aesthetic error where apys and fees/tvl inflate when current is way less than max
SUM(CASE WHEN lp.token_tvl_rank = 1 THEN lp.tvl_usd ELSE 0 END) AS last_tvl_usd,
SUM(CASE WHEN lp.token_tvl_rank = 1 THEN lp.tvl_usd/tick_range ELSE 0 END) AS last_tvl_usd_per_tick,
MAX(CASE WHEN lp.token_tvl_rank = 1 THEN lp.next_lp ELSE '01-01-2000' END) AS last_next_lp,
MAX(CASE WHEN lp.token_tvl_rank = 1 THEN lp.next_lp_amount ELSE 0 END) AS last_next_lp_amount,

SUM(lp.usd_amount) as usd_volume,
SUM(lp.fees_received_usd) AS fees_collected_usd
--SUM(fees_received_usd) / SUM(CASE WHEN token_tvl_rank = 1 THEN tvl_usd ELSE 0 END) AS fees_to_tvl
FROM fees_by_lp lp

LEFT JOIN final_trading_pairs f1 --check if the pair maps with the forward version
ON CONCAT(lp.token_a,'/',lp.token_b) = f1.trading_pair
AND lp.exchange_contract_address = f1.exchange_contract_address 
LEFT JOIN final_trading_pairs f2 --check if the pair maps with the backward version
ON CONCAT(lp.token_b,'/',lp.token_a) = f2.trading_pair
AND lp.exchange_contract_address = f2.exchange_contract_address 

GROUP BY 1,2,3,4,5,6,7,8
,9,10,11,12

),

pair_metrics AS --top pools calculates at the pool level, this is for pair level
(
SELECT
--t.exchange_contract_address,
f1.trading_pair AS pair,
SUM(total_usd) AS usd_pair_volume,
SUM(total_fees) AS fee_pair_volume

FROM top_pools t
LEFT JOIN 
(SELECT DISTINCT exchange_contract_address, trading_pair FROM final_trading_pairs) f1 --check if the pair maps with the forward version
ON t.exchange_contract_address = f1.exchange_contract_address 

WHERE f1.trading_pair IS NOT NULL --If it's a pair we exclude in the filter, then it shows null, so just get rid of these

GROUP BY 1

)

SELECT
DENSE_RANK() OVER(ORDER BY fees_collected_usd DESC) AS fee_rank,
d.*,
l.creator_address
FROM
    (
    SELECT
    final_lps.pair, CONCAT(ROUND(fee_tier*100,2), '%') AS fee_tag, atob_lower_bound, atob_upper_bound,
    
    CASE WHEN (atob_lower_bound = 0) OR (atob_upper_bound = 0) THEN 0
    ELSE (atob_upper_bound - (atob_lower_bound+atob_upper_bound)/2) --upper distance from mid
    / ((atob_lower_bound+atob_upper_bound)/2) --divided by mid
    END AS lp_radius,
    fees_collected_usd, /*last_tvl_usd,*/ most_tvl_usd,
    
    CASE WHEN (most_tvl_usd = 0) OR (most_tvl_usd IS NULL) THEN 0
    ELSE fees_collected_usd::decimal/most_tvl_usd::decimal
    END AS fees_to_tvl,
    
    CASE WHEN (most_tvl_usd = 0) OR (most_tvl_usd IS NULL) THEN 0
    ELSE
    (fees_collected_usd::decimal/most_tvl_usd::decimal)*
    (365/
    --Calculate the decimal in days that the position was open (in this 2 day period)
    -- i.e. $100 in fees for a 2 day position has a lower APY than $100 in a 5 minute position
        (
        EXTRACT( epoch FROM
            ( --Gives amount of time within the 2 day period that the position was open
            CASE WHEN (liq_start < DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL) --when position older than 2 days
            THEN last_next_lp - (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL) --set start as start of period
            ELSE (last_next_lp-liq_start)::INTERVAL
            END
            )
        )
        / EXTRACT(epoch FROM '1 day'::INTERVAL) --to get # days open
        )
    )
    END AS fees_to_tvl_apy,
    
    CASE WHEN (top_pools.total_usd=0) OR (top_pools.total_usd IS NULL) OR (fee_tier=0) OR (fee_tier IS NULL) THEN 0
    ELSE
    fees_collected_usd::decimal/
    ((top_pools.total_usd::decimal)*(fee_tier::decimal)) 
    END AS share_of_possible_fees, -- of the fees collected by a pool, what % did the LP take?
    
    CASE WHEN (top_pools.total_usd=0) OR (top_pools.total_usd IS NULL) OR (fee_tier=0) OR (fee_tier IS NULL) THEN 0
    ELSE
    fees_collected_usd::decimal/
    ((pair_metrics.fee_pair_volume::decimal)) 
    END AS share_of_pair_fees, -- of the fees collected by a pair, what % did the LP take?
    
    usd_volume AS inrange_vol,
    top_pools.total_usd AS pair_vol,
    CASE WHEN (top_pools.total_usd=0) OR (top_pools.total_usd IS NULL) THEN 0
    ELSE (usd_volume::decimal)/(pair_metrics.usd_pair_volume::decimal)
    END AS range_efficiency, -- how much % of a pair's volume was the LP in range for?
    
    
    liq_start, 
    CASE WHEN last_next_lp_amount >0 THEN NULL
    ELSE last_next_lp
    END AS lp_end,
    
    DATE_TRUNC('minute',last_next_lp-liq_start) AS pos_age,
    
    CASE WHEN last_next_lp_amount >0 THEN 'Active'
    ELSE 'Inactive'
    END AS lp_status,
    ""tokenId"",
    url,
    CONCAT(final_lps.pair, ' - ',
    ROUND(fee_tier*100,2), '%') AS pair_fee,
    CONCAT(""tokenId"", ' - ', CONCAT(final_lps.pair, ' - ',
    ROUND(fee_tier*100,2), '%')) AS lp_tag
    
    
    FROM final_lps
    
    INNER JOIN top_pools --pool level (i.e. usdc/eth 0.3%)
    ON top_pools.exchange_contract_address = final_lps.exchange_contract_address
    
    INNER JOIN pair_metrics --pair level (i.e. usdc/eth)
    ON pair_metrics.pair = final_lps.pair
    
    WHERE fees_collected_usd > (SELECT min_fees FROM params)
    AND most_tvl_usd > (SELECT min_tvl FROM params)
    
    ) d
LEFT JOIN (SELECT DISTINCT ""output_tokenId"" AS ""tokenId"", (params->>'recipient') as creator_address FROM uniswap_v3.""NonfungibleTokenPositionManager_call_mint"") l
ON l.""tokenId""::text = d.""tokenId""::text

WHERE
1 =
(
CASE WHEN '{{4 LP Status}}' = 'All' THEN 1
WHEN '{{4 LP Status}}' = lp_status THEN 1
ELSE 0
END
)
AND
1=
(
CASE WHEN '{{5 Fees}}' = 'All Tiers' THEN 1
WHEN '{{5 Fees}}' = fee_tag THEN 1
ELSE 0
END
)
ORDER BY fees_collected_usd DESC, share_of_possible_fees DESC"
55962,Uni v3 - 2D Time Series,,table,"WITH all_trades AS
(SELECT
t.block_time
,t.token_a_symbol,t.token_a_address::text
,t.token_b_symbol,t.token_b_address::text
,t.token_a_amount
,t.token_b_amount
,t.exchange_contract_address -- exchange_contract_address is the v3 LP Position
,t.tx_hash -- transaction addr (for spot checks)
,t.usd_amount --TODO: Find some way to pull in USD of any missing tokens
,c.fee/1e6 AS fee_tier --Converting fee tier to a multiplier (i.e. for 0.3%, 3000 -> 0.003)
,t.usd_amount*(c.fee/1e6) AS fees_collected_usd --USD Amount * %fee = fees collected
FROM dex.""trades"" t

LEFT JOIN uniswap_v3.""Factory_call_createPool"" c --1. Join With Pool creation on LP contract address to pull fee tier
ON t.exchange_contract_address = c.output_pool
WHERE t.project = 'Uniswap'
AND t.version = '3'
AND t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
ORDER BY t.block_time DESC
),

v3_trades AS ( --clean table of trades to work with for building visuals
SELECT
atx.block_time,
atx.token_a_symbol,
atx.token_b_symbol,
atx.usd_amount,
atx.fee_tier,
atx.fees_collected_usd,
atx.tx_hash
FROM all_trades atx
),

get_liquidity_sums AS ( --this is to find the liquidity of each position at trade time
SELECT
--amount, amount0, amount1, 
lq.contract_address,
DATE_TRUNC('minute',lq.call_block_time) AS call_block_time,
t1.decimals AS decimals1,
t0.decimals AS decimals0,
t1.price AS price1,
t0.price AS price0,

SUM(CASE WHEN lq.tr_type = 'Mint' THEN lq.amount0 ELSE 0 END) AS liq_added0,
SUM(lq.amount0) AS liq_net0,
SUM(CASE WHEN lq.tr_type = 'Mint' THEN lq.amount1 ELSE 0 END) AS liq_added1,
SUM(lq.amount1) AS liq_net1,
COUNT(DISTINCT CASE WHEN lq.tr_type = 'Mint' THEN ""tokenId"" ELSE NULL END) AS num_positions_added

FROM ( --this is a mess. We union new mints + adds to liquidity + new burns + removals from liquidity. eesh
    -- NEW MINTS
    SELECT DISTINCT * FROM ( --some pairs have duplicate rows and idk why
    SELECT
    m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
    m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
    /*l.liquidity,*/ l.""output_tokenId""::text AS ""tokenId"", 'Mint' AS tr_type
    FROM uniswap_v3.""Pair_call_mint"" m
   
    INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_mint"" l
    ON m.call_tx_hash = l.call_tx_hash
    AND m.call_block_time = l.call_block_time
    
    WHERE l.""output_tokenId""::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
    AND (m.amount != 0) --only events that do something
    --AND m.contract_address IN (SELECT exchange_contract_address FROM top_pools)
    AND m.call_success = 'true' AND l.call_success = 'true'
    -- since we only want liquidity added at this moment, we can filter on date
    AND m.call_block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
    AND l.call_block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
    
    UNION
    --ADDITIONS TO LIQUIDITY INCREASE
    SELECT
    m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
    m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
    /*l.liquidity,*/ (l.params->'tokenId')::text AS ""tokenId"", 'Mint' AS tr_type
    FROM uniswap_v3.""Pair_call_mint"" m
   
    INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_increaseLiquidity"" l
    ON m.call_tx_hash = l.call_tx_hash
    AND m.call_block_time = l.call_block_time
    
    WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
    AND (m.amount != 0) --only events that do something
    --AND m.contract_address IN (SELECT exchange_contract_address FROM top_pools)
    AND m.call_success = 'true' AND l.call_success = 'true'
    -- since we only want liquidity added at this moment, we can filter on date
    AND m.call_block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
    AND l.call_block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)

    UNION
    -- NEW BURNS // uniswap_v3.""NonfungibleTokenPositionManager_call_burn"" doesn't do anything so jsut decrease liq
    SELECT --negate because these are burns
    (-1)*b.amount AS amount, (-1)*b.output_amount0 AS amount0, (-1)*b.output_amount1 AS amount1, b.contract_address,
    b.call_block_time, b.call_tx_hash, b.""tickLower"", b.""tickUpper"",
    /*l.liquidity,*/ (l.params->'tokenId')::text AS tokenId, 'Burn' AS tr_type
    FROM uniswap_v3.""Pair_call_burn"" b
    
    INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_decreaseLiquidity"" l
    ON b.call_tx_hash = l.call_tx_hash
    AND l.call_block_time = l.call_block_time
    
    WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
    AND (b.amount != 0) --only events that do something
   -- AND b.contract_address IN (SELECT exchange_contract_address FROM top_pools)
    AND b.call_success = 'true'
    AND l.call_success = 'true'
    -- since we only want liquidity added at this moment, we can filter on date
    AND b.call_block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
    AND l.call_block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
    ) ld
    ) lq
    INNER JOIN uniswap_v3.""Factory_call_createPool"" p --get pool data
    ON lq.contract_address = p.output_pool
    INNER JOIN prices.""usd"" t0 --inner since we're summing all up
    ON DATE_TRUNC('minute',lq.call_block_time) = t0.minute
    AND p.""tokenA"" = t0.""contract_address""
    INNER JOIN prices.""usd"" t1 --inner since we're summing all up
    ON DATE_TRUNC('minute',lq.call_block_time) = t1.minute
    AND p.""tokenB"" = t1.""contract_address""
WHERE t1.minute >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
AND t0.minute >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
GROUP BY 1,2,3,4,5,6
),

total_liq AS (
SELECT
DATE_TRUNC('hour',call_block_time) AS block_hour,
SUM(tvl_usd_added) AS liq_usd_added,
SUM(tvl_usd_net) AS liq_usd_net,
SUM(num_positions_added) AS num_new_positions

FROM
(
    SELECT DISTINCT
    l.call_block_time,
    l.contract_address,
    l.num_positions_added,
    
    -- Sum all liquidity added (liquidity volume) by hour
    (CASE WHEN (l.liq_added0 IS NULL) OR (l.liq_added0 IS NULL) OR (decimals0 IS NULL) THEN 0
    ELSE price0*(l.liq_added0/10^decimals0)
    END)
    +
    (CASE WHEN (l.liq_added1 IS NULL) OR (l.liq_added1 IS NULL) OR (decimals1 IS NULL) THEN 0
    ELSE price1*(l.liq_added1/10^decimals1)
    END)
    AS tvl_usd_added,
    -- Sum all net liquidity added by hour (change in liquidity)
    (CASE WHEN (l.liq_net0 IS NULL) OR (l.liq_net0 IS NULL) OR (decimals0 IS NULL) THEN 0
    ELSE price0*(l.liq_net0/10^decimals0)
    END)
    +
    (CASE WHEN (l.liq_net1 IS NULL) OR (l.liq_added1 IS NULL) OR (decimals1 IS NULL) THEN 0
    ELSE price1*(l.liq_net1/10^decimals1)
    END)
    AS tvl_usd_net
    
    FROM get_liquidity_sums l
    
) bh
GROUP BY 1

)

, trade_stats AS(
SELECT
DATE_TRUNC('hour',block_time) AS day_hr
--trading_pair
,COUNT(block_time) AS num_trades
,SUM(usd_amount) AS total_usd
,SUM(fees_collected_usd) AS total_fees_usd
--,fee_tier
FROM v3_trades
WHERE block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
AND usd_amount IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY DATE_TRUNC('hour',block_time)--,trading_pair--, fee_tier
)

SELECT 
d.day_hr,
d.num_trades, d.total_usd, d.total_fees_usd,
l.num_new_positions, l.liq_usd_added, l.liq_usd_net

FROM trade_stats d

LEFT JOIN total_liq l
ON d.day_hr = l.block_hour
"
58590,Uni v3 -2D Top LPs by Fees Earned - Radius Distribution,,table,"WITH params AS
(
SELECT
'2 days' as tp,
--'{{LP - Top X Pairs}}'::decimal as min_pair_rank,
'{{3 Min LP Fees - k}}'::decimal*1000 AS min_fees, 
'{{2 Min LP TVL - k}}'::decimal*1000 AS min_tvl,
'{{1 Min Pair Volume - M}}'::decimal*1e6 AS min_vol_mil
),

top_pools AS
(
SELECT
""exchange_contract_address"",total_usd, total_fees
FROM (
    SELECT
    ""exchange_contract_address"",
    p.fee,
    SUM(""usd_amount"") AS total_usd,
    SUM(""usd_amount""*p.fee/1e6) AS total_fees,
    RANK() OVER (ORDER BY SUM(""usd_amount"") DESC) AS pair_rank
    FROM dex.""trades"" t
    INNER JOIN uniswap_v3.""Factory_call_createPool"" p --get pool data
    ON t.exchange_contract_address = p.output_pool
    WHERE project = 'Uniswap'
    AND version = '3'
    AND category = 'DEX'
    AND block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
    AND block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
    --AND ""exchange_contract_address"" = '\x8ad599c3a0ff1de082011efddc58f1908eb6e6d8'
    AND (""usd_amount"" IS NOT NULL)
    GROUP BY 1,2
    ) a
--WHERE pair_rank <=  (SELECT min_pair_rank from params)
WHERE total_usd >= (SELECT min_vol_mil FROM params)
AND (total_usd IS NOT NULL)
),

v3_trunc AS (
SELECT *--,
--ROW_NUMBER() OVER () AS rown
FROM
    (
    SELECT
    --t.block_time,
    date_trunc('hour',t.block_time) + --5 minute blocks // This is for preformance: takes ~5 mins to run if we trunc by minute, ~3 mins by 5 mins, 1 min by 15 minsm 1 min by hour... trying to find a happy medium
        ( --chose 15 minutes as a tradeoff between accuracy (shorter window) and filter flexibility (bigger windwo)
        (FLOOR(extract(minute FROM t.block_time)::int / 15)*15 || 'minutes')::interval --trying 5 mins for accuracy
        )
    AS block_fifteenmins, --make this hour if query hangs
    
    t.""exchange_contract_address"",
    t.""token_a_address"",t.""token_a_symbol"",
    t.""token_b_address"",t.""token_b_symbol"",
    CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
    WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
    WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
    WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
    WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
    WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
    WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
    WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
    WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
    WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
    WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
    WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
    WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
    WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
    WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
    WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
    WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
    WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
    WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
    WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
    WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
    WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
    WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
    WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
    WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
    WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
    WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
    WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
    WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
    WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
    WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
    WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
    WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
    WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
    WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
    WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
    WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
    WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
    WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
    WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
    WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
    WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
    WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
    
    ELSE COALESCE(t.token_a_symbol,
    CONCAT(LEFT(t.token_a_address::text,3),'...',RIGHT(t.token_a_address::text,3))
    )
    END AS token_a,
    CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
    WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
    WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
    WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
    WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
    WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
    WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
    WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
    WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
    WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
    WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
    WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
    WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
    WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
    WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
    WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
    WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
    WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
    WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
    WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
    WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
    WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
    WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
    WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
    WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
    WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
    WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
    WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
    WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
    WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
    WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
    WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
    WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
    WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
    WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
    WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
    WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
    WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
    WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
    WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
    WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
    WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
    WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
    
    ELSE COALESCE(t.token_b_symbol,
    CONCAT(LEFT(t.token_b_address::text,3),'...',RIGHT(t.token_b_address::text,3))
    )
    END AS token_b,
    AVG(s.liquidity) as weighted_liquidity,
    SUM(t.""usd_amount"") AS usd_vol,
    SUM(t.token_a_amount_raw) AS token_a_amount_raw_sum,
    SUM(t.token_b_amount_raw) AS token_b_amount_raw_sum,

    --AVG(s.tick) AS avg_tick,
    SUM(s.tick*t.""usd_amount"")/SUM(t.""usd_amount"") AS weighted_tick
    
    FROM dex.""trades"" t
    
    INNER JOIN uniswap_v3.""Pair_evt_Swap"" s -- Get liquidity available and tick value of the trade
        ON t.tx_hash = s.evt_tx_hash
        AND t.block_time = s.evt_block_time
        AND t.""exchange_contract_address"" = s.""contract_address""

    
    WHERE t.project = 'Uniswap'
    AND t.version = '3'
    AND t.category = 'DEX'
    AND t.block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
    AND s.evt_block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
    AND t.""exchange_contract_address"" IN (SELECT exchange_contract_address FROM top_pools)
    AND (t.""usd_amount"">0) AND (t.""usd_amount"" IS NOT NULL)
    
    GROUP BY 1,2,3,4,5,6,7,8
    ) v
WHERE
(
    '{{7 Exclude}}' NOT LIKE '%' || token_a || '%'
    AND
    '{{7 Exclude}}' NOT LIKE '%' ||token_a || '%'
)
AND
(1 = 
    CASE
    WHEN '{{6 Include}}' = 'All Tokens' THEN 1
    WHEN '{{6 Include}}' LIKE '%' || token_a || '%' THEN 1
    WHEN '{{6 Include}}' LIKE '%' || token_b || '%' THEN 1
    ELSE 0
    END
)
),

dex_price AS 
( --this was originally multiple queries that I combined for preformance, so it looks very confusing now
SELECT 
c.t_one,
    CASE WHEN direction = 'forward' THEN (l.usd_vol::decimal)/(l.token_a_amount_raw_sum/(10^18))::decimal --token a price
    ELSE (l.usd_vol::decimal)/(l.token_b_amount_raw_sum/(10^18))::decimal --token b price
    END AS price_18
FROM
    ( --get most recent price
    SELECT d.*
    FROM (
        SELECT DISTINCT
        block_fifteenmins, exchange_contract_address,
        token_a_address, token_b_address,
        token_a_amount_raw_sum, token_b_amount_raw_sum,
        usd_vol,
        DENSE_RANK() OVER(PARTITION BY exchange_contract_address ORDER BY block_fifteenmins DESC, usd_vol DESC) AS tr_rank
        FROM v3_trunc
        WHERE block_fifteenmins >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
        AND usd_vol IS NOT NULL
        ) d
    WHERE d.tr_rank = 1
    ) l
INNER JOIN 
    ( --dex_trades AS --get most popular pair, use that for price
    SELECT b.* FROM (
        SELECT
        direction,exchange_contract_address,t_one,t_two,
        DENSE_RANK() OVER (PARTITION BY t_one ORDER BY total_usd DESC,exchange_contract_address DESC) AS t_rank
        FROM
            (
            SELECT
            'forward' as direction,
            exchange_contract_address,
            ""token_a_address"" as t_one, ""token_b_address"" as t_two,

            SUM(usd_vol) AS total_usd
            FROM v3_trunc
            WHERE
            ""token_b_address"" = '\xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'
            GROUP BY 1,2,3,4
            
            UNION
            
            SELECT
            'backward' as direction, --flipping token a and b here, so it's easier to calc what's the best pair for each token
            exchange_contract_address,
            ""token_b_address"" as t_one, ""token_a_address"" AS t_two, 
    
            SUM(usd_vol) AS total_usd
            FROM v3_trunc
            WHERE
            ""token_a_address"" = '\xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'
            GROUP BY 1,2,3,4
            ) a
        ) b
    WHERE t_rank = 1
    ) c
ON c.exchange_contract_address = l.exchange_contract_address

),

final_trading_pairs AS( --building the mapping table for pairs
SELECT
a.exchange_contract_address,
a.forward_pair, a.backward_pair,
a.sum_usd,b.sum_usd,

CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.backward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.forward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b --Caring less about this now, just force ETH to thr right, otherwise take the UNI order
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair

FROM 
    ( --sum_pairs AS
    SELECT 
    exchange_contract_address,
    CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
    ,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
    ,SUM(usd_vol) AS sum_usd

    FROM v3_trunc
    GROUP BY 1,2,3
    ) a
LEFT JOIN 
    (
    SELECT --sum_pairs AS
    exchange_contract_address,
    CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
    ,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
    ,SUM(usd_vol) AS sum_usd
    
    FROM v3_trunc
    GROUP BY 1,2,3
    )
    b
ON a.forward_pair = b.backward_pair
AND a.exchange_contract_address = b.exchange_contract_address
),

get_liquidity AS ( --this is to find the liquidity of each position at trade time
SELECT * FROM
    (
    SELECT *,
    lead(running_amount, 1, running_amount) OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS next_lp_amount
    FROM
    (
        SELECT amount, amount0, amount1, contract_address,call_block_time, call_tx_hash,
        ""tickLower"",""tickUpper"", /*liquidity,*/ ""tokenId"", tr_type,
        lead(call_block_time, 1, now()) OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS next_lp, --to help key in on the right lp when joining - for preformance
        lag(call_block_time, 1, '01-01-2000') OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS previous_lp,
        SUM(amount) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount,
        SUM(amount0) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount0,
        SUM(amount1) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount1,
        MIN(call_block_time) OVER(PARTITION BY ""tokenId"") AS liq_start
        
        FROM ( --this is a mess. We union new mints + adds to liquidity + new burns + removals from liquidity. eesh
            -- NEW MINTS
            SELECT
            m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
            m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
            /*l.liquidity,*/ l.""output_tokenId""::text AS ""tokenId"", 'Mint' AS tr_type
            FROM uniswap_v3.""Pair_call_mint"" m
           
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_mint"" l
            ON m.call_tx_hash = l.call_tx_hash
            AND m.call_block_time = l.call_block_time
            
            WHERE l.""output_tokenId""::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (m.amount != 0) --only events that do something
            AND m.contract_address IN (SELECT exchange_contract_address FROM top_pools)
            AND m.call_success = 'true' AND l.call_success = 'true'
            
            UNION
            --ADDITIONS TO LIQUIDITY INCREASE
            SELECT
            m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
            m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
            /*l.liquidity,*/ (l.params->'tokenId')::text AS ""tokenId"", 'Mint' AS tr_type
            FROM uniswap_v3.""Pair_call_mint"" m
           
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_increaseLiquidity"" l
            ON m.call_tx_hash = l.call_tx_hash
            AND m.call_block_time = l.call_block_time
            
            WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (m.amount != 0) --only events that do something
            AND m.contract_address IN (SELECT exchange_contract_address FROM top_pools)
            AND m.call_success = 'true' AND l.call_success = 'true'
            
            UNION
            -- NEW BURNS // uniswap_v3.""NonfungibleTokenPositionManager_call_burn"" doesn't do anything so jsut decrease liq
            SELECT --negate because these are burns
            (-1)*b.amount AS amount, (-1)*b.output_amount0 AS amount0, (-1)*b.output_amount1 AS amount1, b.contract_address,
            b.call_block_time, b.call_tx_hash, b.""tickLower"", b.""tickUpper"",
            /*l.liquidity,*/ (l.params->'tokenId')::text AS tokenId, 'Burn' AS tr_type
            FROM uniswap_v3.""Pair_call_burn"" b
            
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_decreaseLiquidity"" l
            ON b.call_tx_hash = l.call_tx_hash
            AND b.call_block_time = l.call_block_time
            
            WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (b.amount != 0) --only events that do something
            AND b.contract_address IN (SELECT exchange_contract_address FROM top_pools)
            AND b.call_success = 'true'
            AND l.call_success = 'true'
            
            ) lq
        ) la
    --Since we already calc'd running amounts, we can ditch all LP events besides the last one before the 2 day / stuff within the 2 day.
    -- We'll use 'next LP' to do this
    WHERE next_lp >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
) a
WHERE running_amount >0 --check this later, but we should be able to ditch these too since matching is on block time and next lp

),

avail_lps AS(
SELECT b.*,
SUM(lp_amount_per_tick) OVER(PARTITION BY block_fifteenmins, ""exchange_contract_address"") AS in_range_lp,
lp_amount_per_tick / (SUM(lp_amount_per_tick) OVER(PARTITION BY block_fifteenmins, ""exchange_contract_address"")) AS share_at_tick,
usd_amount*(fee/1e6)*(
lp_amount_per_tick / (SUM(lp_amount_per_tick) OVER(PARTITION BY block_fifteenmins, ""exchange_contract_address""))
) AS fees_collected
FROM
(
    SELECT a.*, p.fee
    FROM (
        SELECT
        t.block_fifteenmins,
        t.""exchange_contract_address"",
        t.token_a_address, --for joining
        t.token_b_address, --for joining
        t.token_a,
        t.token_b,
        t.usd_vol AS usd_amount,
        t.weighted_liquidity,
        
        g.running_amount AS lp_amount,--liquidity value of the distinct lp position
        1.0001^(g.""tickUpper"" - g.""tickLower"") AS tick_range,
        g.running_amount / (1.0001^(g.""tickUpper"" - g.""tickLower"")) AS lp_amount_per_tick,
        g.running_amount0 AS lp_amount0,
        g.running_amount1 AS lp_amount1,
        liq_start,
        g.""tokenId"",
        g.""tickLower"", g.""tickUpper"", g.amount0, g.amount1, g.next_lp, g.next_lp_amount,
        g.call_block_time,
        ROW_NUMBER() OVER (PARTITION BY t.block_fifteenmins, g.""tokenId"" ORDER BY g.call_block_time DESC) AS token_lp_rank --Find the most recent liquidity for the lp position for each trade
        ---^ (if the lp adds/removes a bunch of times, we'll see all their transactions. So we want to pick the last one because that should be what their liquidity was at the time of the trade.)
        FROM v3_trunc t
        
        
        INNER JOIN get_liquidity g-- all liquidity options
        ON g.contract_address = t.exchange_contract_address
            AND g.call_block_time <= t.block_fifteenmins --Get previous liquidity statuses before the trade
            AND g.next_lp > t.block_fifteenmins -- pick the transaction whose next transaction is after this trade (i.e. only the latest one)
            AND g.previous_lp <= t.block_fifteenmins --just adding to do it
            AND g.""tickLower"" <= t.weighted_tick
            AND g.""tickUpper"" >= t.weighted_tick
        
        WHERE
        /*t.project = 'Uniswap'
        AND t.version = '3'
        AND t.block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
        AND t.usd_amount > 0 AND (t.usd_amount IS NOT NULL)
        AND*/ g.running_amount >0 --since we join on next > tx_time, we can do this to remove inactive LPs
        AND
        t.""exchange_contract_address"" IN (SELECT exchange_contract_address FROM top_pools)
        AND t.block_fifteenmins >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
        AND g.next_lp >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
        
        ) a
        INNER JOIN uniswap_v3.""Factory_call_createPool"" p --get pool data
        ON a.exchange_contract_address = p.output_pool
        WHERE token_lp_rank = 1
    ) b
),

fees_by_lp AS (
SELECT *,
RANK() OVER (PARTITION BY ""tokenId"" ORDER BY tvl_usd DESC, block_fifteenmins DESC) AS token_tvl_usd_rank
FROM
(
    --i was getting divide by zero... not sure why so this
    --total liquidity still a tiny bit off.... maybe it's collections? Figure this out
    SELECT DISTINCT l.*, --some pairs have duplicate rows and idk why
    fees_collected AS fees_received_usd,
    CASE WHEN (l.lp_amount0 IS NULL) OR (l.lp_amount0 IS NULL) OR (t0.decimals IS NULL)
    THEN (l.lp_amount0/10^18) --if null, assume 18
    ELSE (l.lp_amount0/10^t0.decimals)
    END AS amount_a,
    
    CASE WHEN (l.lp_amount1 IS NULL) OR (l.lp_amount1 IS NULL) OR (t1.decimals IS NULL)
    THEN (l.lp_amount1/10^18)
    ELSE (l.lp_amount1/10^t1.decimals)
    END AS amount_b,
    
    CASE WHEN (l.lp_amount0 IS NULL) OR (l.lp_amount0 IS NULL) OR (t0.decimals IS NULL)
    THEN dpa.price_18*(l.lp_amount0/10^18)
    ELSE t0.price*(l.lp_amount0/10^t0.decimals)
    END AS amount_a_usd,
    
    CASE WHEN (l.lp_amount1 IS NULL) OR (l.lp_amount1 IS NULL) OR (t1.decimals IS NULL)
    THEN dpb.price_18*(l.lp_amount1/10^18)
    ELSE t1.price*(l.lp_amount1/10^t1.decimals)
    END AS amount_b_usd,
    (CASE WHEN (l.lp_amount0 IS NULL) OR (l.lp_amount0 IS NULL) OR (t0.decimals IS NULL)
    THEN dpa.price_18*(l.lp_amount0/10^18)
    ELSE t0.price*(l.lp_amount0/10^t0.decimals)
    END)
    +
    (CASE WHEN (l.lp_amount1 IS NULL) OR (l.lp_amount1 IS NULL) OR (t1.decimals IS NULL)
    THEN dpb.price_18*(l.lp_amount1/10^18)
    ELSE t1.price*(l.lp_amount1/10^t1.decimals)
    END)
    AS tvl_usd,
    --SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"") AS concentrated_liquidity,
    
    CASE WHEN
    ((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    OR ((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    ELSE l.lp_amount::decimal / ((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address""))::decimal)
    END AS share_of_pool,
     CASE WHEN
    ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    OR ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    ELSE l.lp_amount_per_tick::decimal / ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address""))::decimal)
    END AS share_of_pool_per_tick,
    
   /* CASE WHEN
    ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    OR ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    ELSE l.lp_amount_per_tick::decimal / (l.liquidity::decimal)
    END AS share_of_pool_per_tick_liquidity,*/
    
    --CASE WHEN
    --((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    --OR ((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    --ELSE
    --(l.usd_amount::decimal * (p.fee/1e6)::decimal) *
    --(l.lp_amount::decimal / ((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")))::decimal)
    --END AS fees_received_usd_v2_OLD, 
    --TODO - VALIDATE IF FEES ARE CALC'D AS PROPORTION OF LIQUIDITY PER TICK, OR SOMETHING ELSE (LIKE SQRT): https://uniswap.org/whitepaper-v3.pdf
    CASE WHEN
    ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    OR ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    ELSE
    (l.usd_amount::decimal * (p.fee/1e6)::decimal) *
    (l.lp_amount_per_tick::decimal / ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")))::decimal)
    END AS fees_received_usd_old, --TODO: See if I'm calc'ing this right, or of width of ticks has an impact?
    
    
    /*CASE WHEN
    ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    OR ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    ELSE
    (l.usd_amount::decimal * (p.fee/1e6)::decimal) *
    (l.lp_amount_per_tick::decimal / (l.liquidity::decimal))
    END AS fees_received_usd_liq, --TODO: See if I'm calc'ing this right, or of width of ticks has an impact?
    */
    
    --p.fee,
    p.fee/1e6::decimal AS fee_tier,
    p.""tokenA"", p.""tokenB"",
     CASE  --assuming 18 for decimals if null
        WHEN ""tickLower"" < 0 THEN (1.0001^(""tickLower"")) * (10^(ABS(COALESCE(t0.decimals,18)-COALESCE(t1.decimals,18))))
        ELSE (1.0001^(""tickLower"")) / (10^(ABS(COALESCE(t0.decimals,18)-COALESCE(t1.decimals,18))))
    END AS price_lower,
    CASE 
        WHEN ""tickUpper"" < 0 THEN (1.0001^(""tickUpper"")) * (10^(ABS(COALESCE(t0.decimals,18)-COALESCE(t1.decimals,18))))
        ELSE (1.0001^(""tickUpper"")) / (10^(ABS(COALESCE(t0.decimals,18)-COALESCE(t1.decimals,18))))
    END AS price_upper,
    
    RANK() OVER (PARTITION BY l.""tokenId"" ORDER BY l.block_fifteenmins DESC) AS token_tvl_rank --Find the tvl by lp when the last trade was made.
    
    FROM avail_lps l
    
    INNER JOIN uniswap_v3.""Factory_call_createPool"" p --get pool data
    ON l.exchange_contract_address = p.output_pool
    LEFT JOIN prices.""usd"" t0
    ON DATE_TRUNC('minute',l.call_block_time) = t0.minute
    AND l.token_a_address = t0.""contract_address""
    LEFT JOIN prices.""usd"" t1
    ON DATE_TRUNC('minute',l.call_block_time) = t1.minute
    AND l.token_b_address = t1.""contract_address""
    LEFT JOIN dex_price dpa
    ON l.token_a_address = dpa.t_one
    LEFT JOIN dex_price dpb
    ON l.token_b_address = dpb.t_one
    
    WHERE /*token_lp_rank = 1 -- only pick most recent liquidity position per lp
    AND*/ lp_amount>0 
    AND usd_amount > 0 --we're losing some pairs that dune doesn't have... to do for later maybe is try to map these (maybe sqrt price?)
    -- fees per Lp is total_usd * fee_tier * share_of_pool
    AND t0.minute >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
    AND t1.minute >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
)  a

),

final_lps AS
(
SELECT
lp.token_a,
lp.token_b,
f1.trading_pair,
f2.trading_pair,
COALESCE(f1.trading_pair, f2.trading_pair) AS pair,
lp.""tokenId"",
lp.liq_start,
lp.exchange_contract_address,
--""tickLower"" as tick_lower,
--""tickUpper"" as tick_upper,
CASE WHEN (lp.price_upper IS NULL) THEN 0
WHEN (f1.trading_pair IS NULL) THEN lp.price_lower --if backwards, keep, if forwards flip
WHEN (lp.price_upper = 0) THEN 0
ELSE 1/lp.price_upper
END AS atob_lower_bound, --since we're doing 1/price

CASE WHEN(lp.price_lower IS NULL) THEN 0
WHEN (f1.trading_pair IS NULL) THEN lp.price_upper
WHEN (lp.price_lower = 0) THEN 0
ELSE 1/lp.price_lower
END AS atob_upper_bound, --upper and lower flip. This isn't a mistake

fee_tier,
CONCAT('https://app.uniswap.org/#/pool/',""tokenId"") AS url,
--MAX(CASE WHEN next_lp IS NULL THEN now() ELSE next_lp END) AS last_lp,
SUM(CASE WHEN lp.token_tvl_rank = 1 THEN lp.lp_amount ELSE 0 END) AS last_tvl,--to grab the last tvl. Anything that's not the most recent one is ignored.
SUM(CASE WHEN token_tvl_usd_rank =1 THEN lp.tvl_usd ELSE 0 END)
    AS most_tvl_usd, --to grab the max tvl. There is some weird aesthetic error where apys and fees/tvl inflate when current is way less than max
SUM(CASE WHEN lp.token_tvl_rank = 1 THEN lp.tvl_usd ELSE 0 END) AS last_tvl_usd,
SUM(CASE WHEN lp.token_tvl_rank = 1 THEN lp.tvl_usd/tick_range ELSE 0 END) AS last_tvl_usd_per_tick,
MAX(CASE WHEN lp.token_tvl_rank = 1 THEN lp.next_lp ELSE '01-01-2000' END) AS last_next_lp,
MAX(CASE WHEN lp.token_tvl_rank = 1 THEN lp.next_lp_amount ELSE 0 END) AS last_next_lp_amount,

SUM(lp.usd_amount) as usd_volume,
SUM(lp.fees_received_usd) AS fees_collected_usd
--SUM(fees_received_usd) / SUM(CASE WHEN token_tvl_rank = 1 THEN tvl_usd ELSE 0 END) AS fees_to_tvl
FROM fees_by_lp lp

LEFT JOIN final_trading_pairs f1 --check if the pair maps with the forward version
ON CONCAT(lp.token_a,'/',lp.token_b) = f1.trading_pair
AND lp.exchange_contract_address = f1.exchange_contract_address 
LEFT JOIN final_trading_pairs f2 --check if the pair maps with the backward version
ON CONCAT(lp.token_b,'/',lp.token_a) = f2.trading_pair
AND lp.exchange_contract_address = f2.exchange_contract_address 

GROUP BY 1,2,3,4,5,6,7,8
,9,10,11,12

),

pair_metrics AS --top pools calculates at the pool level, this is for pair level
(
SELECT
--t.exchange_contract_address,
f1.trading_pair AS pair,
SUM(total_usd) AS usd_pair_volume,
SUM(total_fees) AS fee_pair_volume

FROM top_pools t
LEFT JOIN 
(SELECT DISTINCT exchange_contract_address, trading_pair FROM final_trading_pairs) f1 --check if the pair maps with the forward version
ON t.exchange_contract_address = f1.exchange_contract_address 

WHERE f1.trading_pair IS NOT NULL --If it's a pair we exclude in the filter, then it shows null, so just get rid of these

GROUP BY 1

)

SELECT
DENSE_RANK() OVER(ORDER BY fees_collected_usd DESC) AS fee_rank,
CASE
WHEN lp_radius*100 <= 0.1 THEN '< 0.1%'
WHEN lp_radius*100 <= 0.2 THEN '0.1% - 0.2%'
WHEN lp_radius*100 <= 0.3 THEN '0.2% - 0.3%'
WHEN lp_radius*100 <= 0.4 THEN '0.3% - 0.4%'
WHEN lp_radius*100 <= 0.5 THEN '0.4% - 0.5%'
WHEN lp_radius*100 <= 1 THEN '0.5% - 1%'
WHEN lp_radius*100 <= 5 THEN '1% - 5%'
WHEN lp_radius*100 <= 10 THEN '5% - 10%'
WHEN lp_radius*100 <= 15 THEN '10% - 15%'
WHEN lp_radius*100 <= 20 THEN '15% - 20%'
WHEN lp_radius*100 <= 25 THEN '20% - 25%'
ELSE '25%+'
END AS radius_group,
CASE
WHEN lp_radius*100 <= 0.1 THEN 1
WHEN lp_radius*100 <= 0.2 THEN 2
WHEN lp_radius*100 <= 0.3 THEN 3
WHEN lp_radius*100 <= 0.4 THEN 4
WHEN lp_radius*100 <= 0.5 THEN 5
WHEN lp_radius*100 <= 1 THEN 6
WHEN lp_radius*100 <= 5 THEN 7
WHEN lp_radius*100 <= 10 THEN 8
WHEN lp_radius*100 <= 15 THEN 9
WHEN lp_radius*100 <= 20 THEN 10
WHEN lp_radius*100 <= 25 THEN 11
ELSE 12
END AS radius_group_order,
CONCAT(ROUND(lp_radius::decimal*100,2), '%') AS radius_map,
d.*,
l.creator_address
FROM
    (
    SELECT
    final_lps.pair, CONCAT(ROUND(fee_tier*100,2), '%') AS fee_tag, atob_lower_bound, atob_upper_bound,
    
    CASE WHEN (atob_lower_bound = 0) OR (atob_upper_bound = 0) THEN 0
    ELSE (atob_upper_bound - (atob_lower_bound+atob_upper_bound)/2) --upper distance from mid
    / ((atob_lower_bound+atob_upper_bound)/2) --divided by mid
    END AS lp_radius,
    fees_collected_usd, last_tvl_usd,
    
    CASE WHEN (last_tvl_usd = 0) OR (last_tvl_usd IS NULL) THEN 0
    ELSE fees_collected_usd::decimal/last_tvl_usd::decimal
    END AS fees_to_tvl,
    
        CASE WHEN (last_tvl_usd = 0) OR (last_tvl_usd IS NULL) THEN 0
        ELSE
        (fees_collected_usd::decimal/last_tvl_usd::decimal)*
        (365/
        --Calculate the decimal in days that the position was open (in this 2 day period)
        -- i.e. $100 in fees for a 2 day position has a lower APY than $100 in a 5 minute position
            (
            EXTRACT( epoch FROM
                ( --Gives amount of time within the 2 day period that the position was open
                CASE WHEN (liq_start < DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL) --when position older than 2 days
                THEN last_next_lp - (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL) --set start as start of period
                ELSE (last_next_lp-liq_start)::INTERVAL
                END
                )
            )
            / EXTRACT(epoch FROM '1 day'::INTERVAL) --to get # days open
            )
            
            --/ EXTRACT( epoch FROM ((SELECT tp FROM params)::INTERVAL))--(60*60*24*2) --2 days in seconds
        )
        END AS fees_to_tvl_apy,
        /*EXTRACT( epoch FROM
                ( --Gives amount of time within the 2 day period that the position was open
                CASE WHEN (liq_start < DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL) --when position older than 2 days
                THEN last_next_lp - (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL) --set start as start of period
                ELSE (last_next_lp-liq_start)::INTERVAL
                END
                )
            )
            / EXTRACT(epoch FROM '1 day'::INTERVAL)
            
            --/ EXTRACT( epoch FROM ((SELECT tp FROM params)::INTERVAL))--(60*60*24*2) --2 days in seconds
            AS fractional_2day,*/
    
    CASE WHEN (top_pools.total_usd=0) OR (top_pools.total_usd IS NULL) OR (fee_tier=0) OR (fee_tier IS NULL) THEN 0
    ELSE
    fees_collected_usd::decimal/
    ((top_pools.total_usd::decimal)*(fee_tier::decimal)) 
    END AS share_of_possible_fees, -- of the fees collected by a pool, what % did the LP take?
    
    CASE WHEN (top_pools.total_usd=0) OR (top_pools.total_usd IS NULL) OR (fee_tier=0) OR (fee_tier IS NULL) THEN 0
    ELSE
    fees_collected_usd::decimal/
    ((pair_metrics.fee_pair_volume::decimal)) 
    END AS share_of_pair_fees, -- of the fees collected by a pair, what % did the LP take?
    
    usd_volume AS inrange_vol,
    top_pools.total_usd AS pair_vol,
    CASE WHEN (top_pools.total_usd=0) OR (top_pools.total_usd IS NULL) THEN 0
    ELSE (usd_volume::decimal)/(pair_metrics.usd_pair_volume::decimal)
    END AS range_efficiency, -- how much % of a pair's volume was the LP in range for?
    
    
    liq_start, 
    CASE WHEN last_next_lp_amount >0 THEN NULL
    ELSE last_next_lp
    END AS lp_end,
    
    CASE WHEN DATE_TRUNC('minute',last_next_lp-liq_start)::INTERVAL > '2 days' THEN '2 days'
    ELSE DATE_TRUNC('minute',last_next_lp-liq_start)::INTERVAL
    END AS pos_age,
    CASE WHEN last_next_lp_amount >0 THEN 'Active'
    ELSE 'Inactive'
    END AS lp_status,
    ""tokenId"",
    url,
    CONCAT(final_lps.pair, ' - ',
    ROUND(fee_tier*100,2), '%') AS pair_fee,
    CONCAT(""tokenId"", ' - ', CONCAT(final_lps.pair, ' - ',
    ROUND(fee_tier*100,2), '%')) AS lp_tag
    
    
    FROM final_lps
    
    INNER JOIN top_pools --pool level (i.e. usdc/eth 0.3%)
    ON top_pools.exchange_contract_address = final_lps.exchange_contract_address
    
    INNER JOIN pair_metrics --pair level (i.e. usdc/eth)
    ON pair_metrics.pair = final_lps.pair
    
    WHERE fees_collected_usd > (SELECT min_fees FROM params)
    AND last_tvl_usd > (SELECT min_tvl FROM params)
    
    ) d
LEFT JOIN (SELECT DISTINCT ""output_tokenId"" AS ""tokenId"", (params->>'recipient') as creator_address FROM uniswap_v3.""NonfungibleTokenPositionManager_call_mint"") l
ON l.""tokenId""::text = d.""tokenId""::text

--LP Status
WHERE
1 =
(
CASE WHEN '{{4 LP Status}}' = 'All' THEN 1
WHEN '{{4 LP Status}}' = lp_status THEN 1
ELSE 0
END
)
AND
--Fee Tier
1=
(
CASE WHEN '{{5 Fees}}' = 'All Tiers' THEN 1
WHEN '{{5 Fees}}' = fee_tag THEN 1
ELSE 0
END
)

ORDER BY radius_group_order DESC, fees_collected_usd DESC, share_of_possible_fees DESC"
56126,Uni v3 - 2D Time Series by Pair,,table,"WITH params AS
(
SELECT
'2 days' as tp,
--25 as min_pair_rank--,
--1000::decimal AS min_fees,
'{{1 Min Pair Volume - M}}'::decimal*1e6 AS min_vol_mil
),

top_pools AS
(
SELECT
""exchange_contract_address"",total_usd
FROM (
    SELECT
    ""exchange_contract_address"",
    RANK() OVER (ORDER BY SUM(""usd_amount"") DESC) AS pair_rank,
    SUM(""usd_amount"") AS total_usd
    FROM dex.""trades""
    WHERE project = 'Uniswap'
    AND version = '3'
    AND block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
    AND block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
    AND (""usd_amount"" IS NOT NULL)
    GROUP BY 1
    ) a
--WHERE pair_rank <=  (SELECT min_pair_rank from params)
WHERE total_usd >= (SELECT min_vol_mil FROM params)
AND (total_usd IS NOT NULL)
),

 all_trades AS
(
    SELECT * FROM
    (
    SELECT
    t.block_time, t.token_a_address, t.token_b_address,
    CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
    WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
    WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
    WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
    WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
    WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
    WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
    WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
    WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
    WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
    WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
    WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
    WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
    WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
    WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
    WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
    WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
    WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
    WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
    WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
    WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
    WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
    WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
    WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
    WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
    WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
    WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
    WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
    WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
    WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
    WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
    WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
    WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
    WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
    WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
    WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
    WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
    WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
    WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
    WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
    WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
    WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
    WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
    
    ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
    END AS token_a,
    CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
    WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
    WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
    WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
    WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
    WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
    WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
    WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
    WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
    WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
    WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
    WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
    WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
    WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
    WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
    WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
    WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
    WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
    WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
    WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
    WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
    WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
    WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
    WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
    WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
    WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
    WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
    WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
    WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
    WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
    WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
    WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
    WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
    WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
    WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
    WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
    WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
    WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
    WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
    WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
    WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
    WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
    WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
    
    ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
    END AS token_b
    ,t.token_a_amount
    ,t.token_b_amount
    ,t.exchange_contract_address -- exchange_contract_address is the v3 LP Position
    ,t.tx_hash -- transaction addr (for spot checks)
    ,t.usd_amount --TODO: Find some way to pull in USD of any missing tokens
    ,c.fee/1e6 AS fee_tier --Converting fee tier to a multiplier (i.e. for 0.3%, 3000 -> 0.003)
    ,t.usd_amount*(c.fee/1e6) AS fees_collected_usd --USD Amount * %fee = fees collected
    FROM dex.""trades"" t
    
    INNER JOIN top_pools top
    ON t.exchange_contract_address = top.""exchange_contract_address""
    
    LEFT JOIN uniswap_v3.""Factory_call_createPool"" c --1. Join With Pool creation on LP contract address to pull fee tier
    ON t.exchange_contract_address = c.output_pool
    WHERE t.project = 'Uniswap'
    AND t.version = '3'
    AND t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
    AND t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
    ORDER BY t.block_time DESC
    ) v
--WHERE
--token_a NOT IN ({{5 LP: Excluded List}})
--AND
--token_b NOT IN ({{5 LP: Excluded List}})
),

sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,SUM(usd_amount) AS sum_usd
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS( --building the mapping table for pairs
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd,b.sum_usd,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.backward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.forward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair

FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),

v3_trades AS ( --clean table of trades to work with for building visuals
SELECT
atx.block_time,
COALESCE(f1.trading_pair, f2.trading_pair) AS trading_pair,

--CONCAT(atx.token_a, '/', atx.token_b) AS trading_pair, --pick the mapped trading pair (see joins)
-- if forward pair, the price a is front. If backward, then price b is front
CASE WHEN CONCAT(atx.token_a, '/', atx.token_b) = COALESCE(f1.trading_pair, f2.trading_pair) THEN pa.price
ELSE pb.price
END AS pricea,
CASE WHEN CONCAT(atx.token_a, '/', atx.token_b) = COALESCE(f1.trading_pair, f2.trading_pair) THEN pb.price
ELSE pa.price
END AS priceb,

atx.usd_amount,
atx.fee_tier,
atx.fees_collected_usd,
atx.tx_hash
FROM all_trades atx
LEFT JOIN prices.""usd"" pa
ON DATE_TRUNC('minute',atx.block_time) = pa.minute
AND atx.token_a_address = pa.""contract_address""
LEFT JOIN prices.""usd"" pb
ON DATE_TRUNC('minute',atx.block_time) = pb.minute
AND atx.token_b_address = pb.""contract_address""

LEFT JOIN final_trading_pairs f1 --check if the pair maps with the forward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2 --check if the pair maps with the backward version
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair

WHERE
pa.minute  >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
AND pb.minute  >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)

),

first_set_stats AS(
SELECT
DATE_TRUNC('hour',block_time) AS day_hr,
trading_pair
,fee_tier
,CONCAT(trading_pair, ' - ',
ROUND(fee_tier*100,2), '%') AS pair_fee
,SUM(usd_amount) AS total_usd
,SUM(fees_collected_usd) AS total_fees_usd
,AVG(pricea::decimal/priceb::decimal) AS pair_price
--,fee_tier
FROM v3_trades
WHERE block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
AND usd_amount IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1,2,3,4
)
SELECT *,
(pair_price - (FIRST_VALUE(pair_price) OVER(PARTITION BY trading_pair ORDER BY day_hr ASC)))
/ (FIRST_VALUE(pair_price) OVER(PARTITION BY trading_pair ORDER BY day_hr ASC)) AS rel_price,
((pair_price - (FIRST_VALUE(pair_price) OVER(PARTITION BY trading_pair ORDER BY day_hr ASC)))
/ (FIRST_VALUE(pair_price) OVER(PARTITION BY trading_pair ORDER BY day_hr ASC)))*100 AS rel_price_100,
(total_fees_usd - (FIRST_VALUE(total_fees_usd) OVER(PARTITION BY trading_pair ORDER BY day_hr ASC)))
/ (FIRST_VALUE(total_fees_usd) OVER(PARTITION BY trading_pair ORDER BY day_hr ASC)) AS rel_fees,
((total_fees_usd - (FIRST_VALUE(total_fees_usd) OVER(PARTITION BY trading_pair ORDER BY day_hr ASC)))
/ (FIRST_VALUE(total_fees_usd) OVER(PARTITION BY trading_pair ORDER BY day_hr ASC)))*100 AS rel_fees_100

FROM first_set_stats
ORDER BY total_fees_usd DESC
"
58375,Uni v3 -2D Top LPs by Fees Earned (Creator-Level),,chart,"WITH params AS
(
SELECT
'2 days' as tp,
--'{{LP - Top X Pairs}}'::decimal as min_pair_rank,
'{{3 Min LP Fees - k}}'::decimal*1000 AS min_fees, 
'{{2 Min LP TVL - k}}'::decimal*1000 AS min_tvl,
'{{1 Min Pair Volume - M}}'::decimal*1e6 AS min_vol_mil
),

top_pools AS
(
SELECT
""exchange_contract_address"",total_usd, total_fees
FROM (
    SELECT
    ""exchange_contract_address"",
    p.fee,
    SUM(""usd_amount"") AS total_usd,
    SUM(""usd_amount""*p.fee/1e6) AS total_fees,
    RANK() OVER (ORDER BY SUM(""usd_amount"") DESC) AS pair_rank
    FROM dex.""trades"" t
    INNER JOIN uniswap_v3.""Factory_call_createPool"" p --get pool data
    ON t.exchange_contract_address = p.output_pool
    WHERE project = 'Uniswap'
    AND version = '3'
    AND category = 'DEX'
    AND block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
    AND block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
    --AND ""exchange_contract_address"" = '\x8ad599c3a0ff1de082011efddc58f1908eb6e6d8'
    AND (""usd_amount"" IS NOT NULL)
    GROUP BY 1,2
    ) a
--WHERE pair_rank <=  (SELECT min_pair_rank from params)
WHERE total_usd >= (SELECT min_vol_mil FROM params)
AND (total_usd IS NOT NULL)
),

v3_trunc AS (
SELECT *--,
--ROW_NUMBER() OVER () AS rown
FROM
    (
    SELECT
    --t.block_time,
    date_trunc('hour',t.block_time) + --5 minute blocks // This is for preformance: takes ~5 mins to run if we trunc by minute, ~3 mins by 5 mins, 1 min by 15 minsm 1 min by hour... trying to find a happy medium
        ( --chose 15 minutes as a tradeoff between accuracy (shorter window) and filter flexibility (bigger windwo)
        (FLOOR(extract(minute FROM t.block_time)::int / 15)*15 || 'minutes')::interval --trying 5 mins for accuracy
        )
    AS block_fifteenmins, --make this hour if query hangs
    
    t.""exchange_contract_address"",
    t.""token_a_address"",t.""token_a_symbol"",
    t.""token_b_address"",t.""token_b_symbol"",
    CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
    WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
    WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
    WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
    WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
    WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
    WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
    WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
    WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
    WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
    WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
    WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
    WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
    WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
    WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
    WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
    WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
    WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
    WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
    WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
    WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
    WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
    WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
    WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
    WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
    WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
    WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
    WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
    WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
    WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
    WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
    WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
    WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
    WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
    WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
    WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
    WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
    WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
    WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
    WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
    WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
    WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
    WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
    
    ELSE COALESCE(t.token_a_symbol,
    CONCAT(LEFT(t.token_a_address::text,3),'...',RIGHT(t.token_a_address::text,3))
    )
    END AS token_a,
    CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
    WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
    WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
    WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
    WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
    WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
    WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
    WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
    WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
    WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
    WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
    WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
    WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
    WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
    WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
    WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
    WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
    WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
    WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
    WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
    WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
    WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
    WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
    WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
    WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
    WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
    WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
    WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
    WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
    WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
    WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
    WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
    WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
    WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
    WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
    WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
    WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
    WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
    WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
    WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
    WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
    WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
    WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
    
    ELSE COALESCE(t.token_b_symbol,
    CONCAT(LEFT(t.token_b_address::text,3),'...',RIGHT(t.token_b_address::text,3))
    )
    END AS token_b,
    AVG(s.liquidity) as weighted_liquidity,
    SUM(t.""usd_amount"") AS usd_vol,
    SUM(t.token_a_amount_raw) AS token_a_amount_raw_sum,
    SUM(t.token_b_amount_raw) AS token_b_amount_raw_sum,

    --AVG(s.tick) AS avg_tick,
    SUM(s.tick*t.""usd_amount"")/SUM(t.""usd_amount"") AS weighted_tick
    
    FROM dex.""trades"" t
    
    INNER JOIN uniswap_v3.""Pair_evt_Swap"" s -- Get liquidity available and tick value of the trade
        ON t.tx_hash = s.evt_tx_hash
        AND t.block_time = s.evt_block_time
        AND t.""exchange_contract_address"" = s.""contract_address""

    
    WHERE t.project = 'Uniswap'
    AND t.version = '3'
    AND t.category = 'DEX'
    AND t.block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
    AND s.evt_block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
    AND t.""exchange_contract_address"" IN (SELECT exchange_contract_address FROM top_pools)
    AND (t.""usd_amount"">0) AND (t.""usd_amount"" IS NOT NULL)
    
    GROUP BY 1,2,3,4,5,6,7,8
    ) v
WHERE
(
    '{{7 Exclude}}' NOT LIKE '%' || token_a || '%'
    AND
    '{{7 Exclude}}' NOT LIKE '%' ||token_a || '%'
)
AND
(1 = 
    CASE
    WHEN '{{6 Include}}' = 'All Tokens' THEN 1
    WHEN '{{6 Include}}' LIKE '%' || token_a || '%' THEN 1
    WHEN '{{6 Include}}' LIKE '%' || token_b || '%' THEN 1
    ELSE 0
    END
)
),

dex_price AS 
( --this was originally multiple queries that I combined for preformance, so it looks very confusing now
SELECT 
c.t_one,
    CASE WHEN direction = 'forward' THEN (l.usd_vol::decimal)/(l.token_a_amount_raw_sum/(10^18))::decimal --token a price
    ELSE (l.usd_vol::decimal)/(l.token_b_amount_raw_sum/(10^18))::decimal --token b price
    END AS price_18
FROM
    ( --get most recent price
    SELECT d.*
    FROM (
        SELECT DISTINCT
        block_fifteenmins, exchange_contract_address,
        token_a_address, token_b_address,
        token_a_amount_raw_sum, token_b_amount_raw_sum,
        usd_vol,
        DENSE_RANK() OVER(PARTITION BY exchange_contract_address ORDER BY block_fifteenmins DESC, usd_vol DESC) AS tr_rank
        FROM v3_trunc
        WHERE block_fifteenmins >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
        AND usd_vol IS NOT NULL
        ) d
    WHERE d.tr_rank = 1
    ) l
INNER JOIN 
    ( --dex_trades AS --get most popular pair, use that for price
    SELECT b.* FROM (
        SELECT
        direction,exchange_contract_address,t_one,t_two,
        DENSE_RANK() OVER (PARTITION BY t_one ORDER BY total_usd DESC,exchange_contract_address DESC) AS t_rank
        FROM
            (
            SELECT
            'forward' as direction,
            exchange_contract_address,
            ""token_a_address"" as t_one, ""token_b_address"" as t_two,

            SUM(usd_vol) AS total_usd
            FROM v3_trunc
            WHERE
            ""token_b_address"" = '\xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'
            GROUP BY 1,2,3,4
            
            UNION
            
            SELECT
            'backward' as direction, --flipping token a and b here, so it's easier to calc what's the best pair for each token
            exchange_contract_address,
            ""token_b_address"" as t_one, ""token_a_address"" AS t_two, 
    
            SUM(usd_vol) AS total_usd
            FROM v3_trunc
            WHERE
            ""token_a_address"" = '\xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'
            GROUP BY 1,2,3,4
            ) a
        ) b
    WHERE t_rank = 1
    ) c
ON c.exchange_contract_address = l.exchange_contract_address

),

final_trading_pairs AS( --building the mapping table for pairs
SELECT
a.exchange_contract_address,
a.forward_pair, a.backward_pair,
a.sum_usd,b.sum_usd,

CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.backward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.forward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b --Caring less about this now, just force ETH to thr right, otherwise take the UNI order
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair

FROM 
    ( --sum_pairs AS
    SELECT 
    exchange_contract_address,
    CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
    ,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
    ,SUM(usd_vol) AS sum_usd

    FROM v3_trunc
    GROUP BY 1,2,3
    ) a
LEFT JOIN 
    (
    SELECT --sum_pairs AS
    exchange_contract_address,
    CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
    ,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
    ,SUM(usd_vol) AS sum_usd
    
    FROM v3_trunc
    GROUP BY 1,2,3
    )
    b
ON a.forward_pair = b.backward_pair
AND a.exchange_contract_address = b.exchange_contract_address
),

get_liquidity AS ( --this is to find the liquidity of each position at trade time
SELECT * FROM
    (
    SELECT *,
    lead(running_amount, 1, running_amount) OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS next_lp_amount
    FROM
    (
        SELECT amount, amount0, amount1, contract_address,call_block_time, call_tx_hash,
        ""tickLower"",""tickUpper"", /*liquidity,*/ ""tokenId"", tr_type,
        lead(call_block_time, 1, now()) OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS next_lp, --to help key in on the right lp when joining - for preformance
        lag(call_block_time, 1, '01-01-2000') OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS previous_lp,
        SUM(amount) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount,
        SUM(amount0) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount0,
        SUM(amount1) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount1,
        MIN(call_block_time) OVER(PARTITION BY ""tokenId"") AS liq_start
        
        FROM ( --this is a mess. We union new mints + adds to liquidity + new burns + removals from liquidity. eesh
            -- NEW MINTS
            SELECT
            m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
            m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
            /*l.liquidity,*/ l.""output_tokenId""::text AS ""tokenId"", 'Mint' AS tr_type
            FROM uniswap_v3.""Pair_call_mint"" m
           
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_mint"" l
            ON m.call_tx_hash = l.call_tx_hash
            AND m.call_block_time = l.call_block_time
            
            WHERE l.""output_tokenId""::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (m.amount != 0) --only events that do something
            AND m.contract_address IN (SELECT exchange_contract_address FROM top_pools)
            AND m.call_success = 'true' AND l.call_success = 'true'
            
            UNION
            --ADDITIONS TO LIQUIDITY INCREASE
            SELECT
            m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
            m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
            /*l.liquidity,*/ (l.params->'tokenId')::text AS ""tokenId"", 'Mint' AS tr_type
            FROM uniswap_v3.""Pair_call_mint"" m
           
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_increaseLiquidity"" l
            ON m.call_tx_hash = l.call_tx_hash
            AND m.call_block_time = l.call_block_time
            
            WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (m.amount != 0) --only events that do something
            AND m.contract_address IN (SELECT exchange_contract_address FROM top_pools)
            AND m.call_success = 'true' AND l.call_success = 'true'
            
            UNION
            -- NEW BURNS // uniswap_v3.""NonfungibleTokenPositionManager_call_burn"" doesn't do anything so jsut decrease liq
            SELECT --negate because these are burns
            (-1)*b.amount AS amount, (-1)*b.output_amount0 AS amount0, (-1)*b.output_amount1 AS amount1, b.contract_address,
            b.call_block_time, b.call_tx_hash, b.""tickLower"", b.""tickUpper"",
            /*l.liquidity,*/ (l.params->'tokenId')::text AS tokenId, 'Burn' AS tr_type
            FROM uniswap_v3.""Pair_call_burn"" b
            
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_decreaseLiquidity"" l
            ON b.call_tx_hash = l.call_tx_hash
            AND b.call_block_time = l.call_block_time
            
            WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (b.amount != 0) --only events that do something
            AND b.contract_address IN (SELECT exchange_contract_address FROM top_pools)
            AND b.call_success = 'true'
            AND l.call_success = 'true'
            
            ) lq
        ) la
    --Since we already calc'd running amounts, we can ditch all LP events besides the last one before the 2 day / stuff within the 2 day.
    -- We'll use 'next LP' to do this
    WHERE next_lp >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
) a
WHERE running_amount >0 --check this later, but we should be able to ditch these too since matching is on block time and next lp

),

avail_lps AS(
SELECT b.*,
SUM(lp_amount_per_tick) OVER(PARTITION BY block_fifteenmins, ""exchange_contract_address"") AS in_range_lp,
lp_amount_per_tick / (SUM(lp_amount_per_tick) OVER(PARTITION BY block_fifteenmins, ""exchange_contract_address"")) AS share_at_tick,
usd_amount*(fee/1e6)*(
lp_amount_per_tick / (SUM(lp_amount_per_tick) OVER(PARTITION BY block_fifteenmins, ""exchange_contract_address""))
) AS fees_collected
FROM
(
    SELECT a.*, p.fee
    FROM (
        SELECT
        t.block_fifteenmins,
        t.""exchange_contract_address"",
        t.token_a_address, --for joining
        t.token_b_address, --for joining
        t.token_a,
        t.token_b,
        t.usd_vol AS usd_amount,
        t.weighted_liquidity,
        
        g.running_amount AS lp_amount,--liquidity value of the distinct lp position
        1.0001^(g.""tickUpper"" - g.""tickLower"") AS tick_range,
        g.running_amount / (1.0001^(g.""tickUpper"" - g.""tickLower"")) AS lp_amount_per_tick,
        g.running_amount0 AS lp_amount0,
        g.running_amount1 AS lp_amount1,
        liq_start,
        g.""tokenId"",
        g.""tickLower"", g.""tickUpper"", g.amount0, g.amount1, g.next_lp, g.next_lp_amount,
        g.call_block_time,
        ROW_NUMBER() OVER (PARTITION BY t.block_fifteenmins, g.""tokenId"" ORDER BY g.call_block_time DESC) AS token_lp_rank --Find the most recent liquidity for the lp position for each trade
        ---^ (if the lp adds/removes a bunch of times, we'll see all their transactions. So we want to pick the last one because that should be what their liquidity was at the time of the trade.)
        FROM v3_trunc t
        
        
        INNER JOIN get_liquidity g-- all liquidity options
        ON g.contract_address = t.exchange_contract_address
            AND g.call_block_time <= t.block_fifteenmins --Get previous liquidity statuses before the trade
            AND g.next_lp > t.block_fifteenmins -- pick the transaction whose next transaction is after this trade (i.e. only the latest one)
            AND g.previous_lp <= t.block_fifteenmins --just adding to do it
            AND g.""tickLower"" <= t.weighted_tick
            AND g.""tickUpper"" >= t.weighted_tick
        
        WHERE
        /*t.project = 'Uniswap'
        AND t.version = '3'
        AND t.block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
        AND t.usd_amount > 0 AND (t.usd_amount IS NOT NULL)
        AND*/ g.running_amount >0 --since we join on next > tx_time, we can do this to remove inactive LPs
        AND
        t.""exchange_contract_address"" IN (SELECT exchange_contract_address FROM top_pools)
        AND t.block_fifteenmins >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
        AND g.next_lp >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
        
        ) a
        INNER JOIN uniswap_v3.""Factory_call_createPool"" p --get pool data
        ON a.exchange_contract_address = p.output_pool
        WHERE token_lp_rank = 1
    ) b
),

fees_by_lp AS (
SELECT *,
RANK() OVER (PARTITION BY ""tokenId"" ORDER BY tvl_usd DESC, block_fifteenmins DESC) AS token_tvl_usd_rank
FROM
(
    --i was getting divide by zero... not sure why so this
    --total liquidity still a tiny bit off.... maybe it's collections? Figure this out
    SELECT DISTINCT l.*, --some pairs have duplicate rows and idk why
    fees_collected AS fees_received_usd,
    CASE WHEN (l.lp_amount0 IS NULL) OR (l.lp_amount0 IS NULL) OR (t0.decimals IS NULL)
    THEN (l.lp_amount0/10^18) --if null, assume 18
    ELSE (l.lp_amount0/10^t0.decimals)
    END AS amount_a,
    
    CASE WHEN (l.lp_amount1 IS NULL) OR (l.lp_amount1 IS NULL) OR (t1.decimals IS NULL)
    THEN (l.lp_amount1/10^18)
    ELSE (l.lp_amount1/10^t1.decimals)
    END AS amount_b,
    
    CASE WHEN (l.lp_amount0 IS NULL) OR (l.lp_amount0 IS NULL) OR (t0.decimals IS NULL)
    THEN dpa.price_18*(l.lp_amount0/10^18)
    ELSE t0.price*(l.lp_amount0/10^t0.decimals)
    END AS amount_a_usd,
    
    CASE WHEN (l.lp_amount1 IS NULL) OR (l.lp_amount1 IS NULL) OR (t1.decimals IS NULL)
    THEN dpb.price_18*(l.lp_amount1/10^18)
    ELSE t1.price*(l.lp_amount1/10^t1.decimals)
    END AS amount_b_usd,
    (CASE WHEN (l.lp_amount0 IS NULL) OR (l.lp_amount0 IS NULL) OR (t0.decimals IS NULL)
    THEN dpa.price_18*(l.lp_amount0/10^18)
    ELSE t0.price*(l.lp_amount0/10^t0.decimals)
    END)
    +
    (CASE WHEN (l.lp_amount1 IS NULL) OR (l.lp_amount1 IS NULL) OR (t1.decimals IS NULL)
    THEN dpb.price_18*(l.lp_amount1/10^18)
    ELSE t1.price*(l.lp_amount1/10^t1.decimals)
    END)
    AS tvl_usd,
    --SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"") AS concentrated_liquidity,
    
    CASE WHEN
    ((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    OR ((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    ELSE l.lp_amount::decimal / ((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address""))::decimal)
    END AS share_of_pool,
     CASE WHEN
    ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    OR ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    ELSE l.lp_amount_per_tick::decimal / ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address""))::decimal)
    END AS share_of_pool_per_tick,
    
   /* CASE WHEN
    ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    OR ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    ELSE l.lp_amount_per_tick::decimal / (l.liquidity::decimal)
    END AS share_of_pool_per_tick_liquidity,*/
    
    --CASE WHEN
    --((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    --OR ((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    --ELSE
    --(l.usd_amount::decimal * (p.fee/1e6)::decimal) *
    --(l.lp_amount::decimal / ((SUM(l.lp_amount) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")))::decimal)
    --END AS fees_received_usd_v2_OLD, 
    --TODO - VALIDATE IF FEES ARE CALC'D AS PROPORTION OF LIQUIDITY PER TICK, OR SOMETHING ELSE (LIKE SQRT): https://uniswap.org/whitepaper-v3.pdf
    CASE WHEN
    ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    OR ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    ELSE
    (l.usd_amount::decimal * (p.fee/1e6)::decimal) *
    (l.lp_amount_per_tick::decimal / ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")))::decimal)
    END AS fees_received_usd_old, --TODO: See if I'm calc'ing this right, or of width of ticks has an impact?
    
    
    /*CASE WHEN
    ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) = 0)
    OR ((SUM(l.lp_amount_per_tick) OVER (PARTITION BY l.block_fifteenmins, l.""exchange_contract_address"")) IS NULL) THEN 0
    ELSE
    (l.usd_amount::decimal * (p.fee/1e6)::decimal) *
    (l.lp_amount_per_tick::decimal / (l.liquidity::decimal))
    END AS fees_received_usd_liq, --TODO: See if I'm calc'ing this right, or of width of ticks has an impact?
    */
    
    --p.fee,
    p.fee/1e6::decimal AS fee_tier,
    p.""tokenA"", p.""tokenB"",
     CASE  --assuming 18 for decimals if null
        WHEN ""tickLower"" < 0 THEN (1.0001^(""tickLower"")) * (10^(ABS(COALESCE(t0.decimals,18)-COALESCE(t1.decimals,18))))
        ELSE (1.0001^(""tickLower"")) / (10^(ABS(COALESCE(t0.decimals,18)-COALESCE(t1.decimals,18))))
    END AS price_lower,
    CASE 
        WHEN ""tickUpper"" < 0 THEN (1.0001^(""tickUpper"")) * (10^(ABS(COALESCE(t0.decimals,18)-COALESCE(t1.decimals,18))))
        ELSE (1.0001^(""tickUpper"")) / (10^(ABS(COALESCE(t0.decimals,18)-COALESCE(t1.decimals,18))))
    END AS price_upper,
    
    RANK() OVER (PARTITION BY l.""tokenId"" ORDER BY l.block_fifteenmins DESC) AS token_tvl_rank --Find the tvl by lp when the last trade was made.
    
    FROM avail_lps l
    
    INNER JOIN uniswap_v3.""Factory_call_createPool"" p --get pool data
    ON l.exchange_contract_address = p.output_pool
    LEFT JOIN prices.""usd"" t0
    ON DATE_TRUNC('minute',l.call_block_time) = t0.minute
    AND l.token_a_address = t0.""contract_address""
    LEFT JOIN prices.""usd"" t1
    ON DATE_TRUNC('minute',l.call_block_time) = t1.minute
    AND l.token_b_address = t1.""contract_address""
    LEFT JOIN dex_price dpa
    ON l.token_a_address = dpa.t_one
    LEFT JOIN dex_price dpb
    ON l.token_b_address = dpb.t_one
    
    WHERE /*token_lp_rank = 1 -- only pick most recent liquidity position per lp
    AND*/ lp_amount>0 
    AND usd_amount > 0 --we're losing some pairs that dune doesn't have... to do for later maybe is try to map these (maybe sqrt price?)
    -- fees per Lp is total_usd * fee_tier * share_of_pool
    AND t0.minute >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
    AND t1.minute >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL)
)  a

),

final_lps AS
(
SELECT
lp.token_a,
lp.token_b,
f1.trading_pair,
f2.trading_pair,
COALESCE(f1.trading_pair, f2.trading_pair) AS pair,
lp.""tokenId"",
lp.liq_start,
lp.exchange_contract_address,
--""tickLower"" as tick_lower,
--""tickUpper"" as tick_upper,
CASE WHEN (lp.price_upper IS NULL) THEN 0
WHEN (f1.trading_pair IS NULL) THEN lp.price_lower --if backwards, keep, if forwards flip
WHEN (lp.price_upper = 0) THEN 0
ELSE 1/lp.price_upper
END AS atob_lower_bound, --since we're doing 1/price

CASE WHEN(lp.price_lower IS NULL) THEN 0
WHEN (f1.trading_pair IS NULL) THEN lp.price_upper
WHEN (lp.price_lower = 0) THEN 0
ELSE 1/lp.price_lower
END AS atob_upper_bound, --upper and lower flip. This isn't a mistake

fee_tier,
CONCAT('https://app.uniswap.org/#/pool/',""tokenId"") AS url,
--MAX(CASE WHEN next_lp IS NULL THEN now() ELSE next_lp END) AS last_lp,
SUM(CASE WHEN lp.token_tvl_rank = 1 THEN lp.lp_amount ELSE 0 END) AS last_tvl,--to grab the last tvl. Anything that's not the most recent one is ignored.
SUM(CASE WHEN token_tvl_usd_rank =1 THEN lp.tvl_usd ELSE 0 END)
    AS most_tvl_usd, --to grab the max tvl. There is some weird aesthetic error where apys and fees/tvl inflate when current is way less than max
SUM(CASE WHEN lp.token_tvl_rank = 1 THEN lp.tvl_usd ELSE 0 END) AS last_tvl_usd,
SUM(CASE WHEN lp.token_tvl_rank = 1 THEN lp.tvl_usd/tick_range ELSE 0 END) AS last_tvl_usd_per_tick,
MAX(CASE WHEN lp.token_tvl_rank = 1 THEN lp.next_lp ELSE '01-01-2000' END) AS last_next_lp,
MAX(CASE WHEN lp.token_tvl_rank = 1 THEN lp.next_lp_amount ELSE 0 END) AS last_next_lp_amount,

SUM(lp.usd_amount) as usd_volume,
SUM(lp.fees_received_usd) AS fees_collected_usd
--SUM(fees_received_usd) / SUM(CASE WHEN token_tvl_rank = 1 THEN tvl_usd ELSE 0 END) AS fees_to_tvl
FROM fees_by_lp lp

LEFT JOIN final_trading_pairs f1 --check if the pair maps with the forward version
ON CONCAT(lp.token_a,'/',lp.token_b) = f1.trading_pair
AND lp.exchange_contract_address = f1.exchange_contract_address 
LEFT JOIN final_trading_pairs f2 --check if the pair maps with the backward version
ON CONCAT(lp.token_b,'/',lp.token_a) = f2.trading_pair
AND lp.exchange_contract_address = f2.exchange_contract_address 

GROUP BY 1,2,3,4,5,6,7,8
,9,10,11,12

),

pair_metrics AS --top pools calculates at the pool level, this is for pair level
(
SELECT
--t.exchange_contract_address,
f1.trading_pair AS pair,
SUM(total_usd) AS usd_pair_volume,
SUM(total_fees) AS fee_pair_volume

FROM top_pools t
LEFT JOIN 
(SELECT DISTINCT exchange_contract_address, trading_pair FROM final_trading_pairs) f1 --check if the pair maps with the forward version
ON t.exchange_contract_address = f1.exchange_contract_address 

WHERE f1.trading_pair IS NOT NULL --If it's a pair we exclude in the filter, then it shows null, so just get rid of these

GROUP BY 1

)
SELECT
*,
creator_fees/fee_pair_volume AS share_of_fees,
DENSE_RANK()
    OVER(PARTITION BY pair ORDER BY creator_fees/fee_pair_volume DESC,creator_address DESC) AS creator_pair_rank,
CASE WHEN DENSE_RANK()
    OVER(PARTITION BY pair ORDER BY creator_fees/fee_pair_volume DESC,creator_address DESC) <= 10 THEN creator_address
ELSE 'Other'
END AS addr_map

FROM
(
    
    SELECT
        d.pair, --fee_tier, d.pair_fee, pair_vol,
        l.creator_address, --fees_collected_usd,
        fee_pair_volume,
        usd_pair_volume,
        --SUM(fees_collected_usd) AS total_fees,
        SUM(fees_collected_usd) AS creator_fees
        
        FROM
            (
            SELECT
            final_lps.pair, CONCAT(ROUND(fee_tier*100,2), '%') AS fee_tag, atob_lower_bound, atob_upper_bound,
            pair_metrics.fee_pair_volume,
            pair_metrics.usd_pair_volume,
            
            CASE WHEN (atob_lower_bound = 0) OR (atob_upper_bound = 0) THEN 0
            ELSE (atob_upper_bound - (atob_lower_bound+atob_upper_bound)/2) --upper distance from mid
            / ((atob_lower_bound+atob_upper_bound)/2) --divided by mid
            END AS lp_radius,
            fees_collected_usd, most_tvl_usd,
            
            CASE WHEN (most_tvl_usd = 0) OR (most_tvl_usd IS NULL) THEN 0
            ELSE fees_collected_usd::decimal/most_tvl_usd::decimal
            END AS fees_to_tvl,
            
            CASE WHEN (most_tvl_usd = 0) OR (most_tvl_usd IS NULL) THEN 0
            ELSE
            (fees_collected_usd::decimal/most_tvl_usd::decimal)*
            (365/
            --Calculate the decimal in days that the position was open (in this 2 day period)
            -- i.e. $100 in fees for a 2 day position has a lower APY than $100 in a 5 minute position
                (
                EXTRACT( epoch FROM
                    ( --Gives amount of time within the 2 day period that the position was open
                    CASE WHEN (liq_start < DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL) --when position older than 2 days
                    THEN last_next_lp - (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL) --set start as start of period
                    ELSE (last_next_lp-liq_start)::INTERVAL
                    END
                    )
                )
                / EXTRACT(epoch FROM '1 day'::INTERVAL) --to get # days open
                )
                
                --/ EXTRACT( epoch FROM ((SELECT tp FROM params)::INTERVAL))--(60*60*24*2) --2 days in seconds
            )
            END AS fees_to_tvl_apy,
            /*EXTRACT( epoch FROM
                    ( --Gives amount of time within the 2 day period that the position was open
                    CASE WHEN (liq_start < DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL) --when position older than 2 days
                    THEN last_next_lp - (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - (SELECT tp FROM params)::INTERVAL) --set start as start of period
                    ELSE (last_next_lp-liq_start)::INTERVAL
                    END
                    )
                )
                / EXTRACT(epoch FROM '1 day'::INTERVAL)
                
                --/ EXTRACT( epoch FROM ((SELECT tp FROM params)::INTERVAL))--(60*60*24*2) --2 days in seconds
                AS fractional_2day,*/
            
            CASE WHEN (top_pools.total_usd=0) OR (top_pools.total_usd IS NULL) OR (fee_tier=0) OR (fee_tier IS NULL) THEN 0
            ELSE
            fees_collected_usd::decimal/
            ((top_pools.total_usd::decimal)*(fee_tier::decimal)) 
            END AS share_of_possible_fees, -- of the fees collected by a pool, what % did the LP take?
            
            --TODO
            CASE WHEN (top_pools.total_usd=0) OR (top_pools.total_usd IS NULL) OR (fee_tier=0) OR (fee_tier IS NULL) THEN 0
            ELSE
            fees_collected_usd::decimal/
            ((pair_metrics.fee_pair_volume::decimal)) 
            END AS share_of_pair_fees, -- of the fees collected by a pair, what % did the LP take?
            
            usd_volume AS inrange_vol,
            top_pools.total_usd AS pair_vol,
            CASE WHEN (top_pools.total_usd=0) OR (top_pools.total_usd IS NULL) THEN 0
            ELSE (usd_volume::decimal)/(pair_metrics.usd_pair_volume::decimal)
            END AS range_efficiency, -- how much % of a pair's volume was the LP in range for?
            
            
            liq_start, 
            CASE WHEN last_next_lp_amount >0 THEN NULL
            ELSE last_next_lp
            END AS lp_end,
            
            DATE_TRUNC('minute',last_next_lp-liq_start) AS pos_age,
            CASE WHEN last_next_lp_amount >0 THEN 'Active'
            ELSE 'Inactive'
            END AS lp_status,
            ""tokenId"",
            url,
            CONCAT(final_lps.pair, ' - ',
            ROUND(fee_tier*100,2), '%') AS pair_fee,
            CONCAT(""tokenId"", ' - ', CONCAT(final_lps.pair, ' - ',
            ROUND(fee_tier*100,2), '%')) AS lp_tag
            
            
            FROM final_lps
            
            INNER JOIN top_pools --pool level (i.e. usdc/eth 0.3%)
            ON top_pools.exchange_contract_address = final_lps.exchange_contract_address
            
            INNER JOIN pair_metrics --pair level (i.e. usdc/eth)
            ON pair_metrics.pair = final_lps.pair
            
            WHERE fees_collected_usd > (SELECT min_fees FROM params)
            AND most_tvl_usd > (SELECT min_tvl FROM params)
            
            ) d
        LEFT JOIN (SELECT DISTINCT ""output_tokenId"" AS ""tokenId"", (params->>'recipient') as creator_address FROM uniswap_v3.""NonfungibleTokenPositionManager_call_mint"") l
        ON l.""tokenId""::text = d.""tokenId""::text
        
        WHERE
        1 =
        (
        CASE WHEN '{{4 LP Status}}' = 'All' THEN 1
        WHEN '{{4 LP Status}}' = lp_status THEN 1
        ELSE 0
        END
        )
        AND
        1=
        (
        CASE WHEN '{{5 Fees}}' = 'All Tiers' THEN 1
        WHEN '{{5 Fees}}' = fee_tag THEN 1
        ELSE 0
        END
        )
    GROUP BY 1,2,3,4--,5,6
) a

ORDER BY fee_pair_volume DESC, creator_fees DESC"
65461,USD/UNI LR,,counter,"WITH liq AS(    
    WITH ticks AS(
        WITH mint_burn AS(
            WITH mb AS(
                SELECT
                    ""tickLower"" AS lowerTick,
                    ""tickUpper"" AS UpperTick,
                    amount
                FROM uniswap_v3.""Pair_call_mint""
                WHERE call_success = true
                AND contract_address = '\x1d42064Fc4Beb5F8aAF85F4617AE8b3b5B8Bd801'
                
                UNION ALL
                
                SELECT 
                    ""tickLower"" AS lowerTick,
                    ""tickUpper"" AS UpperTick,
                    -amount AS amount
                FROM uniswap_v3.""Pair_call_burn""
                WHERE call_success = true
                AND contract_address = '\x1d42064Fc4Beb5F8aAF85F4617AE8b3b5B8Bd801'
           )
            SELECT
                lowerTick,
                UpperTick,
                SUM(amount) as amount
            FROM mb
            GROUP BY 1,2
            )
        SELECT 
           generate_series(lowerTick, UpperTick, 5) as tick,
           amount AS amount_tick
        FROM mint_burn
        WHERE amount > 0
    )
    SELECT 
        --1/(1.0001^tick) AS price,
        tick,
        SUM(amount_tick) as liquidity
    FROM ticks
    --WHERE tick BETWEEN -55000 AND -30000
    GROUP BY 1
),
cp AS (
    WITH prices AS (
        WITH eth_cpprc AS (
            SELECT
                --minute,
                price,
                --decimals,
                symbol
            from prices.""usd""
            WHERE symbol = 'WETH'
            ORDER BY minute DESC
            LIMIT 1
        ),
        uni_cpprc AS (
            SELECT
                --minute,
                price,
                --decimals,
                symbol
            from prices.""usd""
            WHERE symbol = 'UNI'
            ORDER BY minute DESC
            LIMIT 1
        )
        SELECT *
        FROM eth_cpprc
        UNION
        SELECT *
        FROM uni_cpprc
    )
    SELECT 
        SUM(CASE WHEN symbol = 'WETH' THEN price ELSE 0 END) AS WETH_price,
        SUM(CASE WHEN symbol = 'UNI' THEN price ELSE 0 END) AS UNI_price,
        1e10 AS total,
        'current' AS series
    FROM prices
    GROUP BY 3
)

SELECT
    cp.UNI_price AS current_price,
    SUM(CASE WHEN tick < log(1/(cp.WETH_price/cp.UNI_price))/log(1.0001) THEN liquidity END)/1e23 AS ""Below Price"",
    SUM(CASE WHEN tick BETWEEN log(1/(cp.WETH_price/(cp.UNI_price/1.3)))/log(1.0001) AND log(1/((cp.WETH_price/cp.UNI_price)))/log(1.0001) THEN liquidity END)/1e23 AS ""Price-30%"",
    SUM(CASE WHEN tick BETWEEN log(1/(cp.WETH_price/(cp.UNI_price/1.1)))/log(1.0001) AND log(1/((cp.WETH_price/cp.UNI_price)))/log(1.0001) THEN liquidity END)/1e23 AS ""Price-10%"",
    SUM(CASE WHEN tick BETWEEN log(1/((cp.WETH_price/cp.UNI_price)))/log(1.0001) AND log(1/(cp.WETH_price/(cp.UNI_price*1.1)))/log(1.0001) THEN liquidity END)/1e23 AS ""Price+10%"",
    SUM(CASE WHEN tick BETWEEN log(1/((cp.WETH_price/cp.UNI_price)))/log(1.0001) AND log(1/(cp.WETH_price/(cp.UNI_price*1.3)))/log(1.0001) THEN liquidity END)/1e23 AS ""Price+30%"",
    SUM(CASE WHEN tick > log(1/(cp.WETH_price/cp.UNI_price))/log(1.0001) THEN liquidity END)/1e23 AS ""Above Price""
FROM liq
JOIN cp ON(UNI_price<>0)
GROUP BY 1"
65460,USD/UNI LD,,table,"WITH ticks AS(
   WITH mint_burn AS(
        WITH mb AS(
            SELECT
                ""tickLower"" AS lowerTick,
                ""tickUpper"" AS UpperTick,
                amount
            FROM uniswap_v3.""Pair_call_mint""
            WHERE call_success = true
            AND contract_address = '\x1d42064Fc4Beb5F8aAF85F4617AE8b3b5B8Bd801'
            
            UNION ALL
            
            SELECT 
                ""tickLower"" AS lowerTick,
                ""tickUpper"" AS UpperTick,
                -amount AS amount
            FROM uniswap_v3.""Pair_call_burn""
            WHERE call_success = true
            AND contract_address = '\x1d42064Fc4Beb5F8aAF85F4617AE8b3b5B8Bd801'
       )
        SELECT
            lowerTick,
            UpperTick,
            SUM(amount) as amount
        FROM mb
        GROUP BY 1,2
        )
    SELECT 
       generate_series(lowerTick, UpperTick, 5) as tick,
       amount AS amount_tick
    FROM mint_burn
    WHERE amount > 0
),

cp AS (
  WITH eth_cpprc AS (
        SELECT
            --minute,
            price,
            --decimals,
            symbol
        from prices.""usd""
        WHERE symbol = 'WETH'
        ORDER BY minute DESC
        LIMIT 1
    ),
    UNI_cpprc AS (
        SELECT
            --minute,
            price,
            --decimals,
            symbol
        from prices.""usd""
        WHERE symbol = 'UNI'
        ORDER BY minute DESC
        LIMIT 1
    )
    SELECT *
    FROM eth_cpprc
    UNION
    SELECT *
    FROM UNI_cpprc
),
dist as (
    SELECT 
        1/(1.0001^tick) AS price,
        --tick,
        SUM(amount_tick) as total,
        'liq' AS series
    FROM ticks
    WHERE tick BETWEEN -60000 AND -35000
    GROUP BY 1
)

SELECT 
    cp.price/d.price AS price,
    total,
    series
FROM dist d
JOIN cp ON cp.symbol = 'WETH'

UNION ALL

SELECT 
    price,
    1e10 AS total,
    'current' AS series
FROM cp
WHERE symbol = 'UNI'"
64593,WETH/USDC LR,,table,"WITH liq AS(    
    WITH ticks AS(
        WITH mint_burn AS(
            WITH mb AS(     --GET ALL MINT AND BURN SUCCESSEFUL CALLS (could also use evt table)
                SELECT                          --get all mint calls
                    ""tickLower"" AS lowerTick,   --range lower limit
                    ""tickUpper"" AS UpperTick,   --range upper limit
                    amount                      --Liquidity added to each tick
                FROM uniswap_v3.""Pair_call_mint""
                WHERE call_success = true       --exclude fail calls
                AND contract_address =  '\x8ad599c3a0ff1de082011efddc58f1908eb6e6d8' --pool address
                
                UNION ALL
                
                SELECT                          -- same to burn liquidity calls
                    ""tickLower"" AS lowerTick,
                    ""tickUpper"" AS UpperTick,
                    -amount AS amount
                FROM uniswap_v3.""Pair_call_burn""
                WHERE call_success = true
                AND contract_address = '\x8ad599c3a0ff1de082011efddc58f1908eb6e6d8'
            )
            SELECT          -- sum liquidity for exact same range, added and removed liquidity will add to zero.
                lowerTick,
                UpperTick,
                SUM(amount) as amount
            FROM mb
            GROUP BY 1,2
            )
        SELECT              --for each range, create a series of ticks from lower to upper range. 
           generate_series(lowerTick, UpperTick, 5) as tick, --step 5 was used to make query faster.
           amount AS amount_tick                             --distribute liquidity for each tick
        FROM mint_burn
        WHERE amount > 0 --remove ranges already that liquidity has been already removed
    )
    SELECT 
        --1e12/(1.0001^tick) AS price,      --transform tick into price, used in previous query
        tick,                           
        SUM(amount_tick) as liquidity       --add all liquidity for the same tick
    FROM ticks
    --WHERE tick BETWEEN 190000 AND 210000 --Do not filter table so above e below price liquidity get all data.
    GROUP BY 1
),
cp AS (                     -- auxiliary table to get current price for the token
    SELECT
        price,
        decimals,
        symbol
    from prices.""usd""
    WHERE symbol = 'WETH' --OR symbol = 'USDC'
    ORDER BY minute DESC
    LIMIT 1
)

/* Add metrics for each column
1- Current price
2- Sum all liquidity below current price
3- Sum liquidity between current_price/1.1 and current_price
4- Sum liquidity between current_price/1.05 and current_price
5- Sum liquidity between current_price and current_price*1.05
6- Sum liquidity between current_price/1.1 and current_price*1.1
7- Sum all liquidity above current price

Divide each metric by arbitrary number (1e18) to make it more suitable.
*/
SELECT  
    cp.price AS current_price,
    SUM(CASE WHEN tick > log(1e12/cp.price)/log(1.0001) THEN liquidity END)/1e18 AS ""Below Price"",
    SUM(CASE WHEN tick BETWEEN log(1e12/cp.price)/log(1.0001) AND log(1e12/(cp.price/1.1))/log(1.0001) THEN liquidity END)/1e18 AS ""Price-10%"",
    SUM(CASE WHEN tick BETWEEN log(1e12/cp.price)/log(1.0001) AND log(1e12/(cp.price/1.05))/log(1.0001) THEN liquidity END)/1e18 AS ""Price-5%"",
    SUM(CASE WHEN tick BETWEEN log(1e12/(cp.price*1.05))/log(1.0001) AND log(1e12/cp.price)/log(1.0001) THEN liquidity END)/1e18 AS ""Price+5%"",
    SUM(CASE WHEN tick BETWEEN log(1e12/(cp.price*1.1))/log(1.0001) AND log(1e12/cp.price)/log(1.0001) THEN liquidity END)/1e18 AS ""Price+10%"",
    SUM(CASE WHEN tick < log(1e12/cp.price)/log(1.0001) THEN liquidity END)/1e18 AS ""Above Price""
FROM liq
JOIN cp ON(price<>0)
GROUP BY 1
"
65459,LINK/WETH LR,,table,"WITH liq AS(    
    WITH ticks AS(
        WITH mint_burn AS(
            WITH mb AS(
                SELECT
                    ""tickLower"" AS lowerTick,
                    ""tickUpper"" AS UpperTick,
                    amount
                FROM uniswap_v3.""Pair_call_mint""
                WHERE call_success = true
                AND contract_address = '\xa6cc3c2531fdaa6ae1a3ca84c2855806728693e8'
                
                UNION ALL
                
                SELECT 
                    ""tickLower"" AS lowerTick,
                    ""tickUpper"" AS UpperTick,
                    -amount AS amount
                FROM uniswap_v3.""Pair_call_burn""
                WHERE call_success = true
                AND contract_address = '\xa6cc3c2531fdaa6ae1a3ca84c2855806728693e8'
           )
            SELECT
                lowerTick,
                UpperTick,
                SUM(amount) as amount
            FROM mb
            GROUP BY 1,2
            )
        SELECT 
           generate_series(lowerTick, UpperTick, 5) as tick,
           amount AS amount_tick
        FROM mint_burn
        WHERE amount > 0
    )
    SELECT 
        --1/(1.0001^tick) AS price,
        tick,
        SUM(amount_tick) as liquidity
    FROM ticks
    --WHERE tick BETWEEN -120000 AND -35000
    GROUP BY 1
),
cp AS (
    WITH prices AS (
        WITH eth_cpprc AS (
            SELECT
                --minute,
                price,
                --decimals,
                symbol
            from prices.""usd""
            WHERE symbol = 'WETH'
            ORDER BY minute DESC
            LIMIT 1
        ),
        link_cpprc AS (
            SELECT
                --minute,
                price,
                --decimals,
                symbol
            from prices.""usd""
            WHERE symbol = 'LINK'
            ORDER BY minute DESC
            LIMIT 1
        )
        SELECT *
        FROM eth_cpprc
        UNION
        SELECT *
        FROM link_cpprc
    )
    SELECT 
        SUM(CASE WHEN symbol = 'WETH' THEN price ELSE 0 END) AS WETH_price,
        SUM(CASE WHEN symbol = 'LINK' THEN price ELSE 0 END) AS LINK_price,
        'current' AS series
    FROM prices
    GROUP BY 3
)

SELECT
    cp.LINK_price AS current_price,
    SUM(CASE WHEN tick < log(1/(cp.WETH_price/cp.LINK_price))/log(1.0001) THEN liquidity END)/1e23 AS ""Below Price"",
    SUM(CASE WHEN tick BETWEEN log(1/(cp.WETH_price/(cp.LINK_price/1.3)))/log(1.0001) AND log(1/((cp.WETH_price/cp.LINK_price)))/log(1.0001) THEN liquidity END)/1e23 AS ""Price-30%"",
    SUM(CASE WHEN tick BETWEEN log(1/(cp.WETH_price/(cp.LINK_price/1.1)))/log(1.0001) AND log(1/((cp.WETH_price/cp.LINK_price)))/log(1.0001) THEN liquidity END)/1e23 AS ""Price-10%"",
    SUM(CASE WHEN tick BETWEEN log(1/((cp.WETH_price/cp.LINK_price)))/log(1.0001) AND log(1/(cp.WETH_price/(cp.LINK_price*1.1)))/log(1.0001) THEN liquidity END)/1e23 AS ""Price+10%"",
    SUM(CASE WHEN tick BETWEEN log(1/((cp.WETH_price/cp.LINK_price)))/log(1.0001) AND log(1/(cp.WETH_price/(cp.LINK_price*1.3)))/log(1.0001) THEN liquidity END)/1e23 AS ""Price+30%"",
    SUM(CASE WHEN tick > log(1/(cp.WETH_price/cp.LINK_price))/log(1.0001) THEN liquidity END)/1e23 AS ""Above Price""
FROM liq
JOIN cp ON(LINK_price<>0)
GROUP BY 1

"
64519,ETH/USDC LD,,table,"WITH ticks AS(
    WITH mint_burn AS(
        WITH mb AS(     --GET ALL MINT AND BURN SUCCESSEFUL CALLS (could also use evt table)
            SELECT                          --get all mint calls
                ""tickLower"" AS lowerTick,   --range lower limit
                ""tickUpper"" AS UpperTick,   --range upper limit
                amount                      --Liquidity added to each tick
            FROM uniswap_v3.""Pair_call_mint""
            WHERE call_success = true       --exclude fail calls
            AND contract_address =  '\x8ad599c3a0ff1de082011efddc58f1908eb6e6d8' --pool address
            
            UNION ALL
            
            SELECT                          -- same to burn liquidity calls
                ""tickLower"" AS lowerTick,
                ""tickUpper"" AS UpperTick,
                -amount AS amount
            FROM uniswap_v3.""Pair_call_burn""
            WHERE call_success = true
            AND contract_address = '\x8ad599c3a0ff1de082011efddc58f1908eb6e6d8'
        )
        SELECT          -- sum liquidity for exact same range, added and removed liquidity will add to zero.
            lowerTick,
            UpperTick,
            SUM(amount) as amount
        FROM mb
        GROUP BY 1,2
        )
    SELECT              --for each range, create a series of ticks from lower to upper range. 
       generate_series(lowerTick, UpperTick, 5) as tick, --step 5 was used to make query faster.
       amount AS amount_tick                             --distribute liquidity for each tick
    FROM mint_burn
    WHERE amount > 0 --remove ranges already that liquidity has been already removed
),

current_price AS ( -- auxiliary table to get current price for the token
    SELECT
        price,
        decimals,
        symbol
    from prices.""usd""
    WHERE symbol = 'WETH' OR symbol = 'USDC'
    ORDER BY minute DESC
    LIMIT 2
)
/*The most difficult part is doing tick to price correlation. 
Formula is 1.0001^(tick)* 1e(number of decimals in token0)/1e(numberof_decimals in token1)
Invert for token1/token0 price
*/
SELECT                              
    1e12/(1.0001^tick) AS price,        --transform tick into price, decimals in this case 6 USDC and 18 WETH 
    --tick,                             --used to see tick-price correlation
    SUM(amount_tick) as total,          --add all liquidity for the same tick
    'liq' AS series                     --auxiliary colunm to filter graph
FROM ticks
WHERE tick BETWEEN 190000 AND 210000    --filter tick interval to better suit graph (helps if query shows both tick and price )
GROUP BY 1

UNION ALL                               --Add extra line to table with current price

SELECT 
    price,                              --current price
    1e10 AS total,                      --arbitrary number (end up showing a white line in graph)
    'current' AS series                 --auxiliary colunm to filter graph
FROM current_price
WHERE symbol = 'WETH'                   --Get only ETH price
"
65056,USD/LINK LD,,table,"WITH ticks AS(
    WITH mint_burn AS(
        WITH mb AS(     --GET ALL MINT AND BURN SUCCESSEFUL CALLS (could also use evt table)
            SELECT                          --get all mint calls
                ""tickLower"" AS lowerTick,   --range lower limit
                ""tickUpper"" AS UpperTick,   --range upper limit
                amount                      --Liquidity added to each tick
            FROM uniswap_v3.""Pair_call_mint""
            WHERE call_success = true       --exclude fail calls
            AND contract_address =  '\xa6cc3c2531fdaa6ae1a3ca84c2855806728693e8' --pool address
            
            UNION ALL
            
            SELECT                          -- same to burn liquidity calls
                ""tickLower"" AS lowerTick,
                ""tickUpper"" AS UpperTick,
                -amount AS amount
            FROM uniswap_v3.""Pair_call_burn""
            WHERE call_success = true
            AND contract_address = '\xa6cc3c2531fdaa6ae1a3ca84c2855806728693e8'
        )
        SELECT          -- sum liquidity for exact same range, added and removed liquidity will add to zero.
            lowerTick,
            UpperTick,
            SUM(amount) as amount
        FROM mb
        GROUP BY 1,2
        )
    SELECT              --for each range, create a series of ticks from lower to upper range. 
       generate_series(lowerTick, UpperTick, 5) as tick, --step 5 was used to make query faster.
       amount AS amount_tick                             --distribute liquidity for each tick
    FROM mint_burn
    WHERE amount > 0 --remove ranges already that liquidity has been already removed
),

cp AS (   -- auxiliary table to get current price for the token
    WITH eth_cpprc AS (
        SELECT
            --minute,
            price,
            --decimals,
            symbol
        from prices.""usd""
        WHERE symbol = 'WETH'
        ORDER BY minute DESC
        LIMIT 1
    ),
    LINK_cpprc AS (
        SELECT
            --minute,
            price,
            --decimals,
            symbol
        from prices.""usd""
        WHERE symbol = 'LINK'
        ORDER BY minute DESC
        LIMIT 1
    )
    SELECT *
    FROM eth_cpprc
    UNION
    SELECT *
    FROM LINK_cpprc
),

/*The most difficult part is doing tick to price correlation. 
Formula is 1.0001^(tick)* 1e(number of decimals in token0)/1e(numberof_decimals in token1)
Invert for token1/token0 price
*/
distribution as (
    SELECT 
        (1.0001^tick) AS price,   --transform tick into price, decimals in this case 18 LINK and 18 WETH
        tick,                     --used to see tick-price correlation
        SUM(amount_tick) as total,  --add all liquidity for the same tick
        'liq' AS series              --auxiliary colunm to filter graph
    FROM ticks
    WHERE tick BETWEEN -60000 AND -35000    --filter tick interval to better suit graph (helps if query shows both tick and price )
    GROUP BY 1,2
)

SELECT 
    cp.price*d.price AS price,
    --tick,
    total,
    series
FROM distribution d
LEFT JOIN cp ON cp.symbol = 'WETH'

UNION ALL               --Add extra line to table with current price

SELECT 
    price,              --current price
    1e10 AS total,      --arbitrary number (end up showing a white line in graph)
    'current' AS series --auxiliary colunm to filter graph
FROM cp
WHERE symbol = 'LINK'    --Get only LINK price"
65051,WBTC/USDC LR,,table,"WITH liq AS(    
    WITH ticks AS(
        WITH mint_burn AS(
            WITH mb AS(
                SELECT 
                    ""tickLower"" AS lowerTick,
                    ""tickUpper"" AS UpperTick,
                    amount
                FROM uniswap_v3.""Pair_evt_Mint""
                WHERE contract_address = '\x99ac8ca7087fa4a2a1fb6357269965a2014abc35'
                
                UNION ALL
                
                SELECT 
                    ""tickLower"" AS lowerTick,
                    ""tickUpper"" AS UpperTick,
                    -amount AS amount
                FROM uniswap_v3.""Pair_evt_Burn""
                WHERE contract_address = '\x99ac8ca7087fa4a2a1fb6357269965a2014abc35'
            )
            SELECT
                lowerTick,
                UpperTick,
                SUM(amount) as amount
            FROM mb
            GROUP BY 1,2
            )
        SELECT 
           generate_series(lowerTick, UpperTick, 5) as tick,
           amount AS amount_tick
        FROM mint_burn
        WHERE amount > 0
    )
    SELECT 
        --1e2*(1.0001^tick) AS price,
        tick,
        SUM(amount_tick) as liquidity
    FROM ticks
    --WHERE tick BETWEEN 54000 AND 67500
    GROUP BY 1
),
cp AS (
    SELECT
        price,
        decimals,
        symbol
    from prices.""usd""
    WHERE symbol = 'WBTC' --OR symbol = 'USDC'
    ORDER BY minute DESC
    LIMIT 1
)

SELECT
    cp.price AS current_price,
    SUM(CASE WHEN tick < log(1e-2*cp.price)/log(1.0001) THEN liquidity END)/1e13 AS ""Below Price"",
    SUM(CASE WHEN tick BETWEEN log(1e-2*cp.price/1.1)/log(1.0001) AND log(1e-2*cp.price)/log(1.0001) THEN liquidity END)/1e13 AS ""Price-10%"",
    SUM(CASE WHEN tick BETWEEN log(1e-2*cp.price/1.05)/log(1.0001) AND log(1e-2*cp.price)/log(1.0001) THEN liquidity END)/1e13 AS ""Price-5%"",
    SUM(CASE WHEN tick BETWEEN log(1e-2*cp.price)/log(1.0001) AND log(1e-2*cp.price*1.05)/log(1.0001) THEN liquidity END)/1e13 AS ""Price+5%"",
    SUM(CASE WHEN tick BETWEEN log(1e-2*cp.price)/log(1.0001) AND log(1e-2*cp.price*1.1)/log(1.0001) THEN liquidity END)/1e13 AS ""Price+10%"",
    SUM(CASE WHEN tick > log(1e-2*cp.price)/log(1.0001) THEN liquidity END)/1e13 AS ""Above Price""
FROM liq
JOIN cp ON(price<>0)
GROUP BY 1
"
65034,WBTC/USDC LD,,table,"WITH ticks AS(
    WITH mint_burn AS(
        WITH mb AS(
            SELECT 
                ""tickLower"" AS lowerTick,
                ""tickUpper"" AS UpperTick,
                amount
            FROM uniswap_v3.""Pair_evt_Mint""
            WHERE contract_address = '\x99ac8ca7087fa4a2a1fb6357269965a2014abc35'
            
            UNION ALL
            
            SELECT 
                ""tickLower"" AS lowerTick,
                ""tickUpper"" AS UpperTick,
                -amount AS amount
            FROM uniswap_v3.""Pair_evt_Burn""
            WHERE contract_address = '\x99ac8ca7087fa4a2a1fb6357269965a2014abc35'
        )
        SELECT
            lowerTick,
            UpperTick,
            SUM(amount) as amount
        FROM mb
        GROUP BY 1,2
        )
    SELECT 
       generate_series(lowerTick, UpperTick) as tick,
       amount AS amount_tick
    FROM mint_burn
    WHERE amount > 0
),

cp AS (
  SELECT
        price,
        decimals,
        symbol
    from prices.""usd""
    WHERE symbol = 'WBTC'
    ORDER BY minute DESC
    LIMIT 1
)

SELECT 
    (1.0001^tick)*1e2 AS price,
    --tick,
    SUM(amount_tick) as total,
    'liq' AS series
FROM ticks t
WHERE tick BETWEEN 50000 AND 67500
GROUP BY 1

UNION ALL

SELECT 
    price,
    1e5 AS total,
    'current' AS series
FROM cp
"
65590,USD/MKR LR,,counter,"WITH liq AS(    
    WITH ticks AS(
        WITH mint_burn AS(
            WITH mb AS(
                SELECT
                    ""tickLower"" AS lowerTick,
                    ""tickUpper"" AS UpperTick,
                    amount
                FROM uniswap_v3.""Pair_call_mint""
                WHERE call_success = true
                AND contract_address = '\xe8c6c9227491c0a8156a0106a0204d881bb7e531'
                
                UNION ALL
                
                SELECT 
                    ""tickLower"" AS lowerTick,
                    ""tickUpper"" AS UpperTick,
                    -amount AS amount
                FROM uniswap_v3.""Pair_call_burn""
                WHERE call_success = true
                AND contract_address = '\xe8c6c9227491c0a8156a0106a0204d881bb7e531'
           )
            SELECT
                lowerTick,
                UpperTick,
                SUM(amount) as amount
            FROM mb
            GROUP BY 1,2
            )
        SELECT 
           generate_series(lowerTick, UpperTick, 5) as tick,
           amount AS amount_tick
        FROM mint_burn
        WHERE amount > 0
    )
    SELECT 
        --1/(1.0001^tick) AS price,
        tick,
        SUM(amount_tick) as liquidity
    FROM ticks
    --WHERE tick BETWEEN -12000 AND 15000
    GROUP BY 1
),
cp AS (
    WITH prices AS (
        WITH eth_cpprc AS (
            SELECT
                --minute,
                price,
                --decimals,
                symbol
            from prices.""usd""
            WHERE symbol = 'WETH'
            ORDER BY minute DESC
            LIMIT 1
        ),
        MKR_cpprc AS (
            SELECT
                --minute,
                price,
                --decimals,
                symbol
            from prices.""usd""
            WHERE symbol = 'MKR'
            ORDER BY minute DESC
            LIMIT 1
        )
        SELECT *
        FROM eth_cpprc
        UNION
        SELECT *
        FROM MKR_cpprc
    )
    SELECT 
        SUM(CASE WHEN symbol = 'WETH' THEN price ELSE 0 END) AS WETH_price,
        SUM(CASE WHEN symbol = 'MKR' THEN price ELSE 0 END) AS MKR_price,
        1e10 AS total,
        'current' AS series
    FROM prices
    GROUP BY 3
)

SELECT
    cp.MKR_price AS current_price,
    SUM(CASE WHEN tick < log(1/(cp.WETH_price/cp.MKR_price))/log(1.0001) THEN liquidity END)/1e21 AS ""Below Price"",
    SUM(CASE WHEN tick BETWEEN log(1/(cp.WETH_price/(cp.MKR_price/1.3)))/log(1.0001) AND log(1/((cp.WETH_price/cp.MKR_price)))/log(1.0001) THEN liquidity END)/1e21 AS ""Price-30%"",
    SUM(CASE WHEN tick BETWEEN log(1/(cp.WETH_price/(cp.MKR_price/1.1)))/log(1.0001) AND log(1/((cp.WETH_price/cp.MKR_price)))/log(1.0001) THEN liquidity END)/1e21 AS ""Price-10%"",
    SUM(CASE WHEN tick BETWEEN log(1/((cp.WETH_price/cp.MKR_price)))/log(1.0001) AND log(1/(cp.WETH_price/(cp.MKR_price*1.1)))/log(1.0001) THEN liquidity END)/1e21 AS ""Price+10%"",
    SUM(CASE WHEN tick BETWEEN log(1/((cp.WETH_price/cp.MKR_price)))/log(1.0001) AND log(1/(cp.WETH_price/(cp.MKR_price*1.3)))/log(1.0001) THEN liquidity END)/1e21 AS ""Price+30%"",
    SUM(CASE WHEN tick > log(1/(cp.WETH_price/cp.MKR_price))/log(1.0001) THEN liquidity END)/1e21 AS ""Above Price""
FROM liq
JOIN cp ON(MKR_price<>0)
GROUP BY 1"
65589,USD/MRK LD,,table,"WITH ticks AS(
   WITH mint_burn AS(
        WITH mb AS(
            SELECT
                ""tickLower"" AS lowerTick,
                ""tickUpper"" AS UpperTick,
                amount
            FROM uniswap_v3.""Pair_call_mint""
            WHERE call_success = true
            AND contract_address = '\xe8c6c9227491c0a8156a0106a0204d881bb7e531'
            
            UNION ALL
            
            SELECT 
                ""tickLower"" AS lowerTick,
                ""tickUpper"" AS UpperTick,
                -amount AS amount
            FROM uniswap_v3.""Pair_call_burn""
            WHERE call_success = true
            AND contract_address = '\xe8c6c9227491c0a8156a0106a0204d881bb7e531'
       )
        SELECT
            lowerTick,
            UpperTick,
            SUM(amount) as amount
        FROM mb
        GROUP BY 1,2
        )
    SELECT 
       generate_series(lowerTick, UpperTick, 10) as tick,
       amount AS amount_tick
    FROM mint_burn
    WHERE amount > 0
),

cp AS (
    WITH eth_cpprc AS (
        SELECT
            --minute,
            price,
            --decimals,
            symbol
        from prices.""usd""
        WHERE symbol = 'WETH'
        ORDER BY minute DESC
        LIMIT 1
    ),
    MRK_cpprc AS (
        SELECT
            --minute,
            price,
            --decimals,
            symbol
        from prices.""usd""
        WHERE symbol = 'MRK'
        ORDER BY minute DESC
        LIMIT 1
    )
    SELECT *
    FROM eth_cpprc
    UNION
    SELECT *
    FROM MRK_cpprc
),

dist as (
    SELECT 
        1/(1.0001^tick) AS price,
        --tick,
        SUM(amount_tick) as total,
        'liq' AS series
    FROM ticks
    WHERE tick BETWEEN -11000 AND 15000
    GROUP BY 1
)

SELECT 
    cp.price/d.price AS price,
    total,
    series
FROM dist d
JOIN cp ON cp.symbol = 'WETH'

UNION ALL

SELECT 
    price,
    1e10 AS total,
    'current' AS series
FROM cp
WHERE symbol = 'MKR'"
65610,USD/COMP LR,,table,"WITH liq AS(    
    WITH ticks AS(
        WITH mint_burn AS(
            WITH mb AS(
                SELECT
                    ""tickLower"" AS lowerTick,
                    ""tickUpper"" AS UpperTick,
                    amount
                FROM uniswap_v3.""Pair_call_mint""
                WHERE call_success = true
                AND contract_address = '\xea4ba4ce14fdd287f380b55419b1c5b6c3f22ab6'
                
                UNION ALL
                
                SELECT 
                    ""tickLower"" AS lowerTick,
                    ""tickUpper"" AS UpperTick,
                    -amount AS amount
                FROM uniswap_v3.""Pair_call_burn""
                WHERE call_success = true
                AND contract_address = '\xea4ba4ce14fdd287f380b55419b1c5b6c3f22ab6'
           )
            SELECT
                lowerTick,
                UpperTick,
                SUM(amount) as amount
            FROM mb
            GROUP BY 1,2
            )
        SELECT 
           generate_series(lowerTick, UpperTick, 5) as tick,
           amount AS amount_tick
        FROM mint_burn
        WHERE amount > 0
    )
    SELECT 
        --1/(1.0001^tick) AS price,
        tick,
        SUM(amount_tick) as liquidity
    FROM ticks
    --WHERE tick BETWEEN -120000 AND -7000
    GROUP BY 1
),
cp AS (
    WITH prices AS (
        WITH eth_cpprc AS (
            SELECT
                --minute,
                price,
                --decimals,
                symbol
            from prices.""usd""
            WHERE symbol = 'WETH'
            ORDER BY minute DESC
            LIMIT 1
        ),
        COMP_cpprc AS (
            SELECT
                --minute,
                price,
                --decimals,
                symbol
            from prices.""usd""
            WHERE symbol = 'COMP'
            ORDER BY minute DESC
            LIMIT 1
        )
        SELECT *
        FROM eth_cpprc
        UNION
        SELECT *
        FROM COMP_cpprc
    )
    SELECT 
        SUM(CASE WHEN symbol = 'WETH' THEN price ELSE 0 END) AS WETH_price,
        SUM(CASE WHEN symbol = 'COMP' THEN price ELSE 0 END) AS COMP_price,
        1e10 AS total,
        'current' AS series
    FROM prices
    GROUP BY 3
)

SELECT
    cp.COMP_price AS current_price,
    SUM(CASE WHEN tick < log(1/(cp.WETH_price/cp.COMP_price))/log(1.0001) THEN liquidity END)/1e21 AS ""Below Price"",
    SUM(CASE WHEN tick BETWEEN log(1/(cp.WETH_price/(cp.COMP_price/1.3)))/log(1.0001) AND log(1/((cp.WETH_price/cp.COMP_price)))/log(1.0001) THEN liquidity END)/1e21 AS ""Price-30%"",
    SUM(CASE WHEN tick BETWEEN log(1/(cp.WETH_price/(cp.COMP_price/1.1)))/log(1.0001) AND log(1/((cp.WETH_price/cp.COMP_price)))/log(1.0001) THEN liquidity END)/1e21 AS ""Price-10%"",
    SUM(CASE WHEN tick BETWEEN log(1/((cp.WETH_price/cp.COMP_price)))/log(1.0001) AND log(1/(cp.WETH_price/(cp.COMP_price*1.1)))/log(1.0001) THEN liquidity END)/1e21 AS ""Price+10%"",
    SUM(CASE WHEN tick BETWEEN log(1/((cp.WETH_price/cp.COMP_price)))/log(1.0001) AND log(1/(cp.WETH_price/(cp.COMP_price*1.3)))/log(1.0001) THEN liquidity END)/1e21 AS ""Price+30%"",
    SUM(CASE WHEN tick > log(1/(cp.WETH_price/cp.COMP_price))/log(1.0001) THEN liquidity END)/1e21 AS ""Above Price""
FROM liq
JOIN cp ON(COMP_price<>0)
GROUP BY 1"
65608,USD/COMP LD,,table,"WITH ticks AS(
   WITH mint_burn AS(
        WITH mb AS(
            SELECT
                ""tickLower"" AS lowerTick,
                ""tickUpper"" AS UpperTick,
                amount
            FROM uniswap_v3.""Pair_call_mint""
            WHERE call_success = true
            AND contract_address = '\xea4ba4ce14fdd287f380b55419b1c5b6c3f22ab6'
            
            UNION ALL
            
            SELECT 
                ""tickLower"" AS lowerTick,
                ""tickUpper"" AS UpperTick,
                -amount AS amount
            FROM uniswap_v3.""Pair_call_burn""
            WHERE call_success = true
            AND contract_address = '\xea4ba4ce14fdd287f380b55419b1c5b6c3f22ab6'
       )
        SELECT
            lowerTick,
            UpperTick,
            SUM(amount) as amount
        FROM mb
        GROUP BY 1,2
        )
    SELECT 
       generate_series(lowerTick, UpperTick, 5) as tick,
       amount AS amount_tick
    FROM mint_burn
    WHERE amount > 0
),

cp AS (
    WITH eth_cpprc AS (
        SELECT
            --minute,
            price,
            --decimals,
            symbol
        from prices.""usd""
        WHERE symbol = 'WETH'
        ORDER BY minute DESC
        LIMIT 1
    ),
    COMP_cpprc AS (
        SELECT
            --minute,
            price,
            --decimals,
            symbol
        from prices.""usd""
        WHERE symbol = 'COMP'
        ORDER BY minute DESC
        LIMIT 1
    )
    SELECT *
    FROM eth_cpprc
    UNION
    SELECT *
    FROM COMP_cpprc
),

dist as (
    SELECT 
        1/(1.0001^tick) AS price,
        --tick,
        SUM(amount_tick) as total,
        'liq' AS series
    FROM ticks
    WHERE tick BETWEEN -33000 AND -7000
    GROUP BY 1
)

SELECT 
    cp.price/d.price AS price,
    total,
    series
FROM dist d
JOIN cp ON cp.symbol = 'WETH'

UNION ALL

SELECT 
    price,
    1e10 AS total,
    'current' AS series
FROM cp
WHERE symbol = 'COMP'"
65613,USD/YFI LR,,counter,"WITH liq AS(    
    WITH ticks AS(
        WITH mint_burn AS(
            WITH mb AS(
                SELECT
                    ""tickLower"" AS lowerTick,
                    ""tickUpper"" AS UpperTick,
                    amount
                FROM uniswap_v3.""Pair_call_mint""
                WHERE call_success = true
                AND contract_address = '\x04916039b1f59d9745bf6e0a21f191d1e0a84287'
                
                UNION ALL
                
                SELECT 
                    ""tickLower"" AS lowerTick,
                    ""tickUpper"" AS UpperTick,
                    -amount AS amount
                FROM uniswap_v3.""Pair_call_burn""
                WHERE call_success = true
                AND contract_address = '\x04916039b1f59d9745bf6e0a21f191d1e0a84287'
           )
            SELECT
                lowerTick,
                UpperTick,
                SUM(amount) as amount
            FROM mb
            GROUP BY 1,2
            )
        SELECT 
           generate_series(lowerTick, UpperTick, 5) as tick,
           amount AS amount_tick
        FROM mint_burn
        WHERE amount > 0
    )
    SELECT 
        --1/(1.0001^tick) AS price,
        tick,
        SUM(amount_tick) as liquidity
    FROM ticks
    --WHERE tick BETWEEN -120000 AND 35000
    GROUP BY 1
),
cp AS (
    WITH prices AS (
        WITH eth_cpprc AS (
            SELECT
                --minute,
                price,
                --decimals,
                symbol
            from prices.""usd""
            WHERE symbol = 'WETH'
            ORDER BY minute DESC
            LIMIT 1
        ),
        yfi_cpprc AS (
            SELECT
                --minute,
                price,
                --decimals,
                symbol
            from prices.""usd""
            WHERE symbol = 'YFI'
            ORDER BY minute DESC
            LIMIT 1
        )
        SELECT *
        FROM eth_cpprc
        UNION
        SELECT *
        FROM yfi_cpprc
        )
    SELECT 
        SUM(CASE WHEN symbol = 'WETH' THEN price ELSE 0 END) AS WETH_price,
        SUM(CASE WHEN symbol = 'YFI' THEN price ELSE 0 END) AS YFI_price,
        1e10 AS total,
        'current' AS series
    FROM prices
    GROUP BY 3
)

SELECT
    cp.YFI_price AS current_price,
    SUM(CASE WHEN tick < log(1/(cp.WETH_price/cp.YFI_price))/log(1.0001) THEN liquidity END)/1e20 AS ""Below Price"",
    SUM(CASE WHEN tick BETWEEN log(1/(cp.WETH_price/(cp.YFI_price/1.3)))/log(1.0001) AND log(1/((cp.WETH_price/cp.YFI_price)))/log(1.0001) THEN liquidity END)/1e20 AS ""Price-30%"",
    SUM(CASE WHEN tick BETWEEN log(1/(cp.WETH_price/(cp.YFI_price/1.1)))/log(1.0001) AND log(1/((cp.WETH_price/cp.YFI_price)))/log(1.0001) THEN liquidity END)/1e20 AS ""Price-10%"",
    SUM(CASE WHEN tick BETWEEN log(1/((cp.WETH_price/cp.YFI_price)))/log(1.0001) AND log(1/(cp.WETH_price/(cp.YFI_price*1.1)))/log(1.0001) THEN liquidity END)/1e20 AS ""Price+10%"",
    SUM(CASE WHEN tick BETWEEN log(1/((cp.WETH_price/cp.YFI_price)))/log(1.0001) AND log(1/(cp.WETH_price/(cp.YFI_price*1.3)))/log(1.0001) THEN liquidity END)/1e20 AS ""Price+30%"",
    SUM(CASE WHEN tick > log(1/(cp.WETH_price/cp.YFI_price))/log(1.0001) THEN liquidity END)/1e20 AS ""Above Price""
FROM liq
JOIN cp ON(YFI_price<>0)
GROUP BY 1"
65612,USD/YFI LD,,table,"WITH ticks AS(
   WITH mint_burn AS(
        WITH mb AS(
            SELECT
                ""tickLower"" AS lowerTick,
                ""tickUpper"" AS UpperTick,
                amount
            FROM uniswap_v3.""Pair_call_mint""
            WHERE call_success = true
            AND contract_address = '\x04916039b1f59d9745bf6e0a21f191d1e0a84287'
            
            UNION ALL
            
            SELECT 
                ""tickLower"" AS lowerTick,
                ""tickUpper"" AS UpperTick,
                -amount AS amount
            FROM uniswap_v3.""Pair_call_burn""
            WHERE call_success = true
            AND contract_address = '\x04916039b1f59d9745bf6e0a21f191d1e0a84287'
       )
        SELECT
            lowerTick,
            UpperTick,
            SUM(amount) as amount
        FROM mb
        GROUP BY 1,2
        )
    SELECT 
       generate_series(lowerTick, UpperTick, 5) as tick,
       amount AS amount_tick
    FROM mint_burn
    WHERE amount > 0
),

cp AS (
    WITH eth_cpprc AS (
        SELECT
            --minute,
            price,
            --decimals,
            symbol
        from prices.""usd""
        WHERE symbol = 'WETH'
        ORDER BY minute DESC
        LIMIT 1
    ),
    yfi_cpprc AS (
        SELECT
            --minute,
            price,
            --decimals,
            symbol
        from prices.""usd""
        WHERE symbol = 'YFI'
        ORDER BY minute DESC
        LIMIT 1
    )
    SELECT *
    FROM eth_cpprc
    UNION
    SELECT *
    FROM yfi_cpprc
),

dist as (
    SELECT 
        1/(1.0001^tick) AS price,
        --tick,
        SUM(amount_tick) as total,
        'liq' AS series
    FROM ticks
    WHERE tick BETWEEN -120000 AND 35000
    GROUP BY 1
)

SELECT 
    cp.price/d.price AS price,
    total,
    series
FROM dist d
JOIN cp ON cp.symbol = 'WETH'

UNION ALL

SELECT 
    price,
    1e10 AS total,
    'current' AS series
FROM cp
WHERE symbol = 'YFI'"
1847,Monthly DEX Volume By Project,,table,"SELECT  project,                        
        date_trunc('month', block_time),
        SUM(usd_amount) as usd_volume                                                                             
FROM dex.""trades"" t                                                                             
WHERE block_time > '2019-01-01'
AND category = 'DEX'
--AND block_time < date_trunc('month', Now()) -- This line can be added in case you only want to see full months
GROUP BY 1, 2
;"
18933,Fork of (#13270) Percentile of Trade Size,,pivot,"WITH prices AS (                                                                                       
    SELECT  date_trunc('hour', minute) as hour,                                                         
            contract_address,                                                                              
            AVG(price) as price                                                                                
    FROM    prices.usd                                                                                    
    WHERE minute > now() - interval '16 weeks'
    GROUP BY 1, 2                                                                                      
), paired AS (
    select 
        CASE
            WHEN ((token_a_symbol = 'WETH' and token_b_symbol = 'USDC') OR (token_a_symbol = 'USDC' and token_b_symbol = 'WETH'))
            THEN 'WETH-USDC'
            WHEN ((token_a_symbol = 'WETH' and token_b_symbol = 'DAI') OR (token_a_symbol = 'DAI' and token_b_symbol = 'WETH'))
            THEN 'WETH-DAI'
            WHEN ((token_a_symbol = 'WETH' and token_b_symbol = 'USDT') OR (token_a_symbol = 'USDT' and token_b_symbol = 'WETH'))
            THEN 'WETH-USDT'
            WHEN ((token_a_symbol = 'WETH' and token_b_symbol = 'WBTC') OR (token_a_symbol = 'WBTC' and token_b_symbol = 'WETH'))
            THEN 'WETH-WBTC'
            WHEN ((token_a_symbol = 'WETH' and token_b_symbol = 'UNI') OR (token_a_symbol = 'UNI' and token_b_symbol = 'WETH'))
            THEN 'WETH-UNI'
        END as pair,
        COALESCE(
            usd_amount,
            token_a_amount * a.price,
            token_b_amount * b.price
        ) as usd_val
    from dex.""trades""
    LEFT JOIN prices a ON date_trunc('hour', block_time) = a.hour AND token_a_address = a.contract_address 
    LEFT JOIN prices b ON date_trunc('hour', block_time) = b.hour AND token_b_address = b.contract_address 
    where (
        ((token_a_symbol = 'WETH' and token_b_symbol = 'USDC') OR (token_a_symbol = 'USDC' and token_b_symbol = 'WETH')) OR
        ((token_a_symbol = 'WETH' and token_b_symbol = 'DAI') OR (token_a_symbol = 'DAI' and token_b_symbol = 'WETH')) OR
        ((token_a_symbol = 'WETH' and token_b_symbol = 'USDT') OR (token_a_symbol = 'USDT' and token_b_symbol = 'WETH')) OR
        ((token_a_symbol = 'WETH' and token_b_symbol = 'WBTC') OR (token_a_symbol = 'WBTC' and token_b_symbol = 'WETH')) OR
        ((token_a_symbol = 'WETH' and token_b_symbol = 'UNI') OR (token_a_symbol = 'UNI' and token_b_symbol = 'WETH'))
    )
    and block_time > now() - interval '1 weeks'
    and project = 'Uniswap'
)

select pair, ntile, max(usd_val)
from (
    select
        pair,
        ntile(100) over (PARTITION BY pair order by usd_val asc),
        usd_val
    from paired
) x
group by 1, 2
having ntile >= 50 and ntile <= 99"
9796,Uniswap LP - MAU Breakdown,,table,"WITH lp AS
  (SELECT date_trunc('month', call_block_time)::date AS MONTH,
          date(call_block_time) AS date,
          ""to"" AS lp,
          'remove' AS TYPE,
          'v2' AS protocol
   FROM uniswap_v2.""Router02_call_removeLiquidityWithPermit""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router02_call_removeLiquidityETHWithPermit""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router02_call_removeLiquidityETHWithPermitSupportingFeeOnTransf""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router02_call_removeLiquidityETHSupportingFeeOnTransferTokens""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router02_call_removeLiquidityETH""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router02_call_removeLiquidity""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router01_call_removeLiquidityETH""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router01_call_removeLiquidity""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router01_call_removeLiquidityWithPermit""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router01_call_removeLiquidityETHWithPermit""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'add' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router02_call_addLiquidityETH""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'add' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router02_call_addLiquidity""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'add' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router01_call_addLiquidityETH""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'add' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router01_call_addLiquidity""
   WHERE call_success IS TRUE 
   
   --- v1 omitted
   
   )
, mau AS (
        SELECT DISTINCT
            month, -- differentiate only by month, but convert it back to a date  '2020-08-01 00:00:00'
            lp as address
        FROM lp
    ) 
    , new_user AS (
        SELECT address,
               MIN(month) AS first_month
        FROM mau
        GROUP BY 1
    )
    , user_status AS
    (
        SELECT
            COALESCE(mau_now.month,DATE_TRUNC('month', mau_prev.month + '45 days'::INTERVAL)) AS month,
            COALESCE(mau_now.address, mau_prev.address) as user_address,
            CASE WHEN
                    nu.address IS NOT NULL
                    THEN 1 ELSE 0 END AS if_new,                                            -- new user                             √ active
            CASE WHEN
                    nu.address IS NULL                  -- not new user (existing or not yet joined)
                    AND mau_prev.address IS NOT NULL    -- active last month
                    AND mau_now.address IS NULL         -- inactive this month
                    THEN 1 ELSE 0 END AS if_churned,                                        -- we lost this user this month         x inactive
            CASE
                WHEN
                    nu.address IS NULL                  -- not new user (existing or not yet joined)
                    AND mau_prev.address IS NOT NULL    -- active last month
                    AND mau_now.address IS NOT NULL     -- active this month
                    THEN 1 ELSE 0 END AS if_retained,                                       -- we retained this user this month     √ active
            CASE
                WHEN
                    nu.address IS NULL                  -- not new user (existing or not yet joined)
                    AND mau_prev.address IS NULL        -- inactive last month
                    AND mau_now.address IS NOT NULL     -- active this month
                    THEN 1 ELSE 0 END AS if_resurrected,                                    -- this user returned this month        √ active
            CASE WHEN
                    mau_now.address IS NOT NULL
                    THEN 1 ELSE 0 END AS if_active                                         -- active flag for completence check: passed check √
                                                                                          -- sum(if_new + if_retained + if_resurrected)=sum(if_active) group by month
                                                                                          -- sum(if_churned + if_active)=count(distinct user_address) group by month
                                                                                          -- sum(if_new + if_churned + if_retained + if_resurrected)=1 group by month, user_address
        FROM mau mau_now
        FULL JOIN mau mau_prev ON
            mau_prev.month = DATE_TRUNC('month', mau_now.month - '5 days'::INTERVAL)
            AND mau_prev.address = mau_now.address
        LEFT JOIN new_user nu ON nu.address = mau_now.address AND nu.first_month = mau_now.month
        WHERE
            COALESCE(mau_now.month,DATE_TRUNC('month', mau_prev.month + '45 days'::INTERVAL)) < CURRENT_DATE
    )
    , user_status_pivot as (
        select month, user_address,
            case
                when sum(if_new)        =   1 then 'new'
                when sum(if_churned)    =   1 then 'churned'
                when sum(if_retained)   =   1 then 'retained'
                when sum(if_resurrected)=   1 then 'returned'
                else null end as status
        from user_status
        group by 1,2
    ) , result as (select month, status, count(distinct user_address) as count from user_status_pivot group by 1,2)
    select month, status, case when status ='churned' then -1*count else count end as count  from result




"
9798,Uniswap Traders - MAU Breakdown,,table,"WITH trades AS
  (SELECT date_trunc('month', call_block_time)::date AS MONTH,
          date(call_block_time) AS date,
          ""to"" AS trader
   FROM uniswap_v2.""Router01_call_swapETHForExactTokens""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS trader
   FROM uniswap_v2.""Router01_call_swapExactETHForTokens""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS trader
   FROM uniswap_v2.""Router01_call_swapExactTokensForETH""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS trader
   FROM uniswap_v2.""Router01_call_swapExactTokensForTokens""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS trader
   FROM uniswap_v2.""Router01_call_swapTokensForExactETH""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS trader
   FROM uniswap_v2.""Router01_call_swapTokensForExactTokens""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS trader
   FROM uniswap_v2.""Router02_call_swapETHForExactTokens""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS trader
   FROM uniswap_v2.""Router02_call_swapExactETHForTokens""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS trader
   FROM uniswap_v2.""Router02_call_swapExactETHForTokensSupportingFeeOnTransferToken""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS trader
   FROM uniswap_v2.""Router02_call_swapExactTokensForETH""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS trader
   FROM uniswap_v2.""Router02_call_swapExactTokensForETHSupportingFeeOnTransferToken""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS trader
   FROM uniswap_v2.""Router02_call_swapExactTokensForTokens""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS trader
   FROM uniswap_v2.""Router02_call_swapExactTokensForTokensSupportingFeeOnTransferTo""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS trader
   FROM uniswap_v2.""Router02_call_swapTokensForExactETH""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS trader
   FROM uniswap_v2.""Router02_call_swapTokensForExactTokens""
   WHERE call_success IS TRUE )
, mau AS (
        SELECT DISTINCT
            month, -- differentiate only by month, but convert it back to a date  '2020-08-01 00:00:00'
            trader as address
        FROM trades
    ) 
    , new_user AS (
        SELECT address,
               MIN(month) AS first_month
        FROM mau
        GROUP BY 1
    )
    , user_status AS
    (
        SELECT
            COALESCE(mau_now.month,DATE_TRUNC('month', mau_prev.month + '45 days'::INTERVAL)) AS month,
            COALESCE(mau_now.address, mau_prev.address) as user_address,
            CASE WHEN
                    nu.address IS NOT NULL
                    THEN 1 ELSE 0 END AS if_new,                                            -- new user                             √ active
            CASE WHEN
                    nu.address IS NULL                  -- not new user (existing or not yet joined)
                    AND mau_prev.address IS NOT NULL    -- active last month
                    AND mau_now.address IS NULL         -- inactive this month
                    THEN 1 ELSE 0 END AS if_churned,                                        -- we lost this user this month         x inactive
            CASE
                WHEN
                    nu.address IS NULL                  -- not new user (existing or not yet joined)
                    AND mau_prev.address IS NOT NULL    -- active last month
                    AND mau_now.address IS NOT NULL     -- active this month
                    THEN 1 ELSE 0 END AS if_retained,                                       -- we retained this user this month     √ active
            CASE
                WHEN
                    nu.address IS NULL                  -- not new user (existing or not yet joined)
                    AND mau_prev.address IS NULL        -- inactive last month
                    AND mau_now.address IS NOT NULL     -- active this month
                    THEN 1 ELSE 0 END AS if_resurrected,                                    -- this user returned this month        √ active
            CASE WHEN
                    mau_now.address IS NOT NULL
                    THEN 1 ELSE 0 END AS if_active                                         -- active flag for completence check: passed check √
                                                                                          -- sum(if_new + if_retained + if_resurrected)=sum(if_active) group by month
                                                                                          -- sum(if_churned + if_active)=count(distinct user_address) group by month
                                                                                          -- sum(if_new + if_churned + if_retained + if_resurrected)=1 group by month, user_address
        FROM mau mau_now
        FULL JOIN mau mau_prev ON
            mau_prev.month = DATE_TRUNC('month', mau_now.month - '5 days'::INTERVAL)
            AND mau_prev.address = mau_now.address
        LEFT JOIN new_user nu ON nu.address = mau_now.address AND nu.first_month = mau_now.month
        WHERE
            COALESCE(mau_now.month,DATE_TRUNC('month', mau_prev.month + '45 days'::INTERVAL)) < CURRENT_DATE
    )
    , user_status_pivot as (
        select month, user_address,
            case
                when sum(if_new)        =   1 then 'new'
                when sum(if_churned)    =   1 then 'churned'
                when sum(if_retained)   =   1 then 'retained'
                when sum(if_resurrected)=   1 then 'returned'
                else null end as status
        from user_status
        group by 1,2
    ) , result as (select month, status, count(distinct user_address) as count from user_status_pivot group by 1,2)
    select month, status, case when status ='churned' then -1*count else count end as count  from result




"
7967,Uniswap trades per month,,table,"SELECT date_trunc('month', block_time) as month, (CASE WHEN version='1' THEN 'v1' ELSE 'v2' END) as uniswap_version, COUNT(*) as trades
FROM dex.""trades""
WHERE project='Uniswap'
GROUP BY month, uniswap_version
ORDER BY month, uniswap_version"
18920,Fork of (#13680) Uni vs Sushi Pools,,table,"-- Pair, Uni, decimals, Sushi
-- ETH/WBTC 0xbb2b8038a1640196fbe3e38816f3e67cba72d940 - 8 - 0xceff51756c56ceffca006cd410b03ffc46dd3a58
-- ETH/USDT 0x0d4a11d5eeaac28ec3f61d100daf4d40471f1852 - 6 - 0x06da0fd433c1a5d7a4faa01111c044910a184553
-- ETH/DAI 0xa478c2975ab1ea89e8196811f51a7b7ade33eb11 - 18 - 0xc3d03e4f041fd4cd388c549ee2a29a9e5075882f
-- ETH/USDC 0xb4e16d0168e52d35cacd2c6185b44281ec28c9dc - 6 - 0x397ff1542f962076d0bfe58ea045ffa2d347aca0
WITH prices AS (                                                                                       
    SELECT  date_trunc('hour', minute) as hour,                                                         
            AVG(price) as price                                                                                
    FROM prices.layer1_usd
    WHERE symbol = 'ETH'
    GROUP BY 1                                                                                      
)

select
    *, eth * 2 * a.price / 1e17 as val
from (
    select
        avg(CASE
            WHEN contract_address in (
                '\x0d4a11d5eeaac28ec3f61d100daf4d40471f1852', '\x06da0fd433c1a5d7a4faa01111c044910a184553'
            ) THEN reserve0
            ELSE reserve1
        END) / 1e1 as eth,
        date_trunc('hour', evt_block_time) as h,
        CASE
            WHEN contract_address = '\xbb2b8038a1640196fbe3e38816f3e67cba72d940' THEN 'eth-wbtc'
            WHEN contract_address = '\x0d4a11d5eeaac28ec3f61d100daf4d40471f1852' THEN 'eth-usdt'
            WHEN contract_address = '\xa478c2975ab1ea89e8196811f51a7b7ade33eb11' THEN 'eth-dai'
            WHEN contract_address = '\xb4e16d0168e52d35cacd2c6185b44281ec28c9dc' THEN 'eth-usdc'
            --Sushi Swap Contracts
            when contract_address = '\xceff51756c56ceffca006cd410b03ffc46dd3a58' THEN 'eth-wbtc'
            when contract_address = '\x06da0fd433c1a5d7a4faa01111c044910a184553' THEN 'eth-usdt'
            when contract_address = '\xc3d03e4f041fd4cd388c549ee2a29a9e5075882f' THEN 'eth-dai'
            when contract_address = '\x397ff1542f962076d0bfe58ea045ffa2d347aca0' THEN 'eth-usdc'
        END as pool,
        protocol
    from (
        select *, 'uni' as protocol from uniswap_v2.""Pair_evt_Sync""
        union
        select *, 'sushi' as protocol from sushi.""Pair_evt_Sync""
    ) y
    where contract_address in ('\xbb2b8038a1640196fbe3e38816f3e67cba72d940','\x0d4a11d5eeaac28ec3f61d100daf4d40471f1852','\xa478c2975ab1ea89e8196811f51a7b7ade33eb11','\xb4e16d0168e52d35cacd2c6185b44281ec28c9dc','\xceff51756c56ceffca006cd410b03ffc46dd3a58','\x06da0fd433c1a5d7a4faa01111c044910a184553','\xc3d03e4f041fd4cd388c549ee2a29a9e5075882f','\x397ff1542f962076d0bfe58ea045ffa2d347aca0')
    group by contract_address, h, protocol
) x
JOIN prices a
    ON x.h = a.hour
where pool = {{ pools }}"
18926,Uniswap Daily Tx Vol,,table,"with txs as (select block_time, usd_amount, price
from dex.""trades"" t
join prices.""layer1_usd"" p
on p.minute = date_trunc('minute', t.block_time)
where block_time > '2019-01-01'
and block_time < '2021-02-01'
and project = 'Uniswap'
and symbol = 'ETH'
)


select date_trunc('day', block_time) as ""Date"", sum(usd_amount / price) as ""eth_amount"", sum(usd_amount) as ""usd_amount"" from txs
group by 1 order by 1"
477783,Pool Info,,table,"WITH pool_contract AS (SELECT CASE WHEN LEFT('{{Pool}}', 1) = '\' THEN '{{Pool}}'::bytea 
    WHEN LEFT('{{Pool}}', 1) = '0' THEN ('\' || RIGHT('{{Pool}}', -1))::bytea
    END AS pc
    )

, start_and_end_date AS (
    SELECT CASE WHEN dune_user_generated.is_date('{{Since}}')='true' AND '{{Since}}' < NOW() THEN '{{Since}}'::timestamp
        ELSE '2000-01-01'::timestamp END AS sd,
    CASE WHEN dune_user_generated.is_date('{{Until}}')='true' AND '{{Until}}' < NOW() THEN '{{Until}}'::timestamp
        ELSE NOW() END AS ed
    )

, uniswap_v1 AS (
    SELECT exchange AS contract_address
    , 'Uniswap v1' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap.""Factory_evt_NewExchange"")
    
, uniswap_v2 AS (
    SELECT pair AS contract_address
    , 'Uniswap v2' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v2.""Factory_evt_PairCreated""
    )
    
, uniswap_v3 AS (
    SELECT pool AS contract_address
    , 'Uniswap v3' AS project
    , fee/1e4 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v3.""Factory_evt_PoolCreated""
    )

, sushiswap AS (
    SELECT pair AS contract_address
    , 'SushiSwap' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM sushi.""Factory_evt_PairCreated""
    )

, curve AS (
    SELECT '\xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7'::bytea AS contract_address
        , 'Curve' AS project
        , 0.04 AS lp_fee_percentage
        , '2020-09-06 20:23'::timestamp AS block_time
        )

, dodo_v1 AS (
    SELECT ""dppAddress"" AS contract_address
    , 'DODO v1' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DPPFactory_call_initDODOPrivatePool"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v1' AS project
    , ""newLpFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DPP_evt_LpFeeRateChange""
    )
    
, dodo_dpp AS (
    SELECT ""output_newBornDODO"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DODOZoo_call_breedDODO"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v2' AS project
    , ""newLiquidityProviderFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DODO_evt_UpdateLiquidityProviderFeeRate""
    )
    
, dodo_dvm AS (
    SELECT ""output_newVendingMachine"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DVMFactory_call_createDODOVendingMachine"" WHERE call_success IS TRUE
    )
    
, dodo_dsp AS (
    SELECT ""output_newStablePool"" AS contract_address,
        'DODO v2' AS project,
        ""lpFeeRate""/1e16 AS lp_fee_percentage,
        call_block_time AS block_time 
    FROM dodo.""DSPFactory_call_createDODOStablePool"" WHERE call_success IS TRUE
    )

, balancer_v1 AS (
    SELECT contract_address
    , 'Balancer v1' AS project
    , ""swapFee""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time
    FROM balancer.""BPool_call_setSwapFee"" WHERE call_success = 'true'
    )
    
, balancer_v2 AS (
    SELECT contract_address
    , 'Balancer v2' AS project
    , ""swapFeePercentage""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM balancer_v2.""WeightedPool_evt_SwapFeePercentageChanged""
    )
 
, all_pools AS (SELECT * FROM (
    SELECT * FROM uniswap_v1
    UNION ALL
    SELECT * FROM uniswap_v2
    UNION ALL
    SELECT * FROM uniswap_v3
    UNION ALL
    SELECT * FROM sushiswap
    UNION ALL
    SELECT * FROM curve
    UNION ALL
    SELECT * FROM dodo_v1
    UNION ALL
    SELECT * FROM dodo_dpp
    UNION ALL
    SELECT * FROM dodo_dvm
    UNION ALL
    SELECT * FROM dodo_dsp
    UNION ALL
    SELECT * FROM balancer_v1
    UNION ALL
    SELECT * FROM balancer_v2) joined
    WHERE contract_address =  (SELECT pc FROM pool_contract)
    ) 
    
, dex_pool_fees AS (SELECT DISTINCT ON (start_lp.contract_address, start_lp.block_time) start_lp.contract_address AS contract_address
    , start_lp.project
    , start_lp.lp_fee_percentage
    , start_lp.block_time AS start_block_time
    , COALESCE(end_lp.block_time, '3000-01-01') AS end_block_time
    FROM (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) start_lp
    LEFT JOIN (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) end_lp
    ON start_lp.contract_address = end_lp.contract_address AND start_lp.block_time < end_lp.block_time
    )
    
, tokens AS (SELECT CASE WHEN token_a_symbol > token_b_symbol THEN token_b_symbol ELSE token_a_symbol END AS ""Token A""
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_symbol ELSE token_b_symbol END AS ""Token B""
    , exchange_contract_address AS contract_address
    FROM (SELECT * FROM dex.trades
    WHERE exchange_contract_address=(SELECT pc FROM pool_contract)
    LIMIT 1) t
    GROUP BY exchange_contract_address, token_a_symbol, token_b_symbol
    )


SELECT MAX(""Token A"") AS ""Token A""
, MAX(""Token B"") AS ""Token B""
, MAX(dpf.project) AS ""Project""
, MAX(dpf.lp_fee_percentage) AS ""Pool Fee""
FROM dex_pool_fees dpf
LEFT JOIN tokens dt ON dt.contract_address=dpf.contract_address
AND end_block_time > NOW()
LIMIT 1"
490667,Pool Impermanent Loss,,table,"WITH pool_contract AS (SELECT CASE WHEN LEFT('{{Pool}}', 1) = '\' THEN '{{Pool}}'::bytea 
    WHEN LEFT('{{Pool}}', 1) = '0' THEN ('\' || RIGHT('{{Pool}}', -1))::bytea
    END AS pc
    )
    
, aggregation AS (SELECT CASE WHEN '{{Granularity}}'='Daily' THEN 'day'
    WHEN '{{Granularity}}'='Weekly' THEN 'week'
    WHEN '{{Granularity}}'='Monthly' THEN 'month'
    WHEN '{{Granularity}}'='Yearly' THEN 'year'
    END AS a
    )

, start_and_end_date AS (
    SELECT CASE WHEN dune_user_generated.is_date('{{Since}}')='true' AND '{{Since}}' < NOW() THEN '{{Since}}'::timestamp
        ELSE '2000-01-01'::timestamp END AS sd,
    CASE WHEN dune_user_generated.is_date('{{Until}}')='true' AND '{{Until}}' < NOW() THEN '{{Until}}'::timestamp
        ELSE NOW() END AS ed
    )

, uniswap_v1 AS (
    SELECT exchange AS contract_address
    , 'Uniswap v1' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap.""Factory_evt_NewExchange"")
    
, uniswap_v2 AS (
    SELECT pair AS contract_address
    , 'Uniswap v2' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v2.""Factory_evt_PairCreated""
    )
    
, uniswap_v3 AS (
    SELECT pool AS contract_address
    , 'Uniswap v3' AS project
    , fee/1e4 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v3.""Factory_evt_PoolCreated""
    )

, sushiswap AS (
    SELECT pair AS contract_address
    , 'SushiSwap' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM sushi.""Factory_evt_PairCreated""
    )

, curve AS (
    SELECT '\xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7'::bytea AS contract_address
        , 'Curve' AS project
        , 0.04 AS lp_fee_percentage
        , '2020-09-06 20:23'::timestamp AS block_time
        )

, dodo_v1 AS (
    SELECT ""dppAddress"" AS contract_address
    , 'DODO v1' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DPPFactory_call_initDODOPrivatePool"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v1' AS project
    , ""newLpFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DPP_evt_LpFeeRateChange""
    )
    
, dodo_dpp AS (
    SELECT ""output_newBornDODO"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DODOZoo_call_breedDODO"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v2' AS project
    , ""newLiquidityProviderFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DODO_evt_UpdateLiquidityProviderFeeRate""
    )
    
, dodo_dvm AS (
    SELECT ""output_newVendingMachine"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DVMFactory_call_createDODOVendingMachine"" WHERE call_success IS TRUE
    )
    
, dodo_dsp AS (
    SELECT ""output_newStablePool"" AS contract_address,
        'DODO v2' AS project,
        ""lpFeeRate""/1e16 AS lp_fee_percentage,
        call_block_time AS block_time 
    FROM dodo.""DSPFactory_call_createDODOStablePool"" WHERE call_success IS TRUE
    )

, balancer_v1 AS (
    SELECT contract_address
    , 'Balancer v1' AS project
    , ""swapFee""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time
    FROM balancer.""BPool_call_setSwapFee"" WHERE call_success = 'true'
    )
    
, balancer_v2 AS (
    SELECT contract_address
    , 'Balancer v2' AS project
    , ""swapFeePercentage""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM balancer_v2.""WeightedPool_evt_SwapFeePercentageChanged""
    )
 
, all_pools AS (SELECT * FROM (
    SELECT * FROM uniswap_v1
    UNION ALL
    SELECT * FROM uniswap_v2
    UNION ALL
    SELECT * FROM uniswap_v3
    UNION ALL
    SELECT * FROM sushiswap
    UNION ALL
    SELECT * FROM curve
    UNION ALL
    SELECT * FROM dodo_v1
    UNION ALL
    SELECT * FROM dodo_dpp
    UNION ALL
    SELECT * FROM dodo_dvm
    UNION ALL
    SELECT * FROM dodo_dsp
    UNION ALL
    SELECT * FROM balancer_v1
    UNION ALL
    SELECT * FROM balancer_v2) joined
    WHERE contract_address =  (SELECT pc FROM pool_contract)
    ) 
    
, dex_pool_fees AS (SELECT DISTINCT ON (start_lp.contract_address, start_lp.block_time) start_lp.contract_address AS contract_address
    , start_lp.project
    , start_lp.lp_fee_percentage
    , start_lp.block_time AS start_block_time
    , COALESCE(end_lp.block_time, '3000-01-01') AS end_block_time
    FROM (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) start_lp
    LEFT JOIN (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) end_lp
    ON start_lp.contract_address = end_lp.contract_address AND start_lp.block_time < end_lp.block_time
    )

, time_series AS (
    SELECT distinct date_trunc((SELECT a FROM aggregation) ,generate_series(date_trunc('day', minimum_date),  maximum_date, '1 day')) AS time
    FROM (
        SELECT CASE WHEN sd < (SELECT MIN(start_block_time) FROM dex_pool_fees) THEN (SELECT MIN(start_block_time) FROM dex_pool_fees)
        ELSE sd END AS minimum_date
        , ed AS maximum_date
        FROM start_and_end_date
    ) md
    )

, pooled_tokens AS (
    SELECT CASE WHEN token_a_symbol > token_b_symbol THEN token_b_address ELSE token_a_address END AS token_a
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_address ELSE token_b_address END AS token_b
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_b_symbol ELSE token_a_symbol END AS token_a_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_symbol ELSE token_b_symbol END AS token_b_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, erctb.decimals) ELSE POWER(10, ercta.decimals) END AS token_a_decimals
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, ercta.decimals) ELSE POWER(10, erctb.decimals) END AS token_b_decimals
    FROM dex.trades dt
    LEFT JOIN erc20.""tokens"" ercta ON dt.token_a_address=ercta.contract_address
    LEFT JOIN erc20.""tokens"" erctb ON dt.token_b_address=erctb.contract_address
    WHERE exchange_contract_address=(SELECT pc FROM pool_contract)
    LIMIT 1
    )

, token_prices AS (
    SELECT time
    , MAX(price_token_a) AS price_token_a
    , MAX(price_token_b) AS price_token_b
    FROM
        (SELECT ts.time
        , price AS price_token_a
        , NULL AS price_token_b
        FROM time_series ts
        LEFT JOIN prices.usd pu ON ts.time=pu.minute
        WHERE contract_address=(SELECT token_a FROM pooled_tokens)
        UNION
        SELECT ts.time
        , NULL AS price_token_a
        , price AS price_token_b
        FROM time_series ts
        LEFT JOIN prices.usd pu ON ts.time=pu.minute
        WHERE contract_address=(SELECT token_b FROM pooled_tokens)
        ) ungrouped
    GROUP BY time
    )

, impermanent_loss_total AS (
    SELECT time
    , 2*sqrt(k)/(1+k)-1 AS impermanent_loss_total
    FROM (
        SELECT time,
        (SELECT price_token_a FROM token_prices ORDER BY time LIMIT 1)/price_token_a*
            (SELECT price_token_b FROM token_prices ORDER BY time LIMIT 1)/price_token_b AS k
        FROM token_prices
        ) k 
    )
        
, impermanent_loss AS (
    SELECT time
    , -ABS((2*sqrt(k)/(1+k)-1)-(2*sqrt(last_k)/(1+last_k)-1)) AS impermanent_loss
    FROM (
        SELECT time
        , (SELECT price_token_a FROM token_prices ORDER BY time LIMIT 1)/price_token_a*
            (SELECT price_token_b FROM token_prices ORDER BY time LIMIT 1)/price_token_b AS k
        , LAG((SELECT price_token_a FROM token_prices ORDER BY time LIMIT 1)/price_token_a*
            (SELECT price_token_b FROM token_prices ORDER BY time LIMIT 1)/price_token_b) OVER (ORDER BY time) AS last_k
        FROM token_prices
        ) k 
    )
        

SELECT il.time AS ""Date""
, impermanent_loss_total AS ""Cumulative Impermanent Loss""
, impermanent_loss AS ""Impermanent Loss""
FROM impermanent_loss il
LEFT JOIN impermanent_loss_total ilt ON il.time = ilt.time
AND il.time < date_trunc('day', NOW())"
490626,Pool Trading Stats,in $,chart,"WITH pool_contract AS (SELECT CASE WHEN LEFT('{{Pool}}', 1) = '\' THEN '{{Pool}}'::bytea 
    WHEN LEFT('{{Pool}}', 1) = '0' THEN ('\' || RIGHT('{{Pool}}', -1))::bytea
    END AS pc
    )
    
, aggregation AS (SELECT CASE WHEN '{{Granularity}}'='Daily' THEN 'day'
    WHEN '{{Granularity}}'='Weekly' THEN 'week'
    WHEN '{{Granularity}}'='Monthly' THEN 'month'
    WHEN '{{Granularity}}'='Yearly' THEN 'year'
    END AS a
    )

, start_and_end_date AS (
    SELECT CASE WHEN dune_user_generated.is_date('{{Since}}')='true' AND '{{Since}}' < NOW() THEN '{{Since}}'::timestamp
        ELSE '2000-01-01'::timestamp END AS sd,
    CASE WHEN dune_user_generated.is_date('{{Until}}')='true' AND '{{Until}}' < NOW() THEN '{{Until}}'::timestamp
        ELSE NOW() END AS ed
    )

, uniswap_v1 AS (
    SELECT exchange AS contract_address
    , 'Uniswap v1' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap.""Factory_evt_NewExchange"")
    
, uniswap_v2 AS (
    SELECT pair AS contract_address
    , 'Uniswap v2' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v2.""Factory_evt_PairCreated""
    )
    
, uniswap_v3 AS (
    SELECT pool AS contract_address
    , 'Uniswap v3' AS project
    , fee/1e4 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v3.""Factory_evt_PoolCreated""
    )

, sushiswap AS (
    SELECT pair AS contract_address
    , 'SushiSwap' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM sushi.""Factory_evt_PairCreated""
    )

, curve AS (
    SELECT '\xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7'::bytea AS contract_address
        , 'Curve' AS project
        , 0.04 AS lp_fee_percentage
        , '2020-09-06 20:23'::timestamp AS block_time
        )

, dodo_v1 AS (
    SELECT ""dppAddress"" AS contract_address
    , 'DODO v1' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DPPFactory_call_initDODOPrivatePool"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v1' AS project
    , ""newLpFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DPP_evt_LpFeeRateChange""
    )
    
, dodo_dpp AS (
    SELECT ""output_newBornDODO"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DODOZoo_call_breedDODO"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v2' AS project
    , ""newLiquidityProviderFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DODO_evt_UpdateLiquidityProviderFeeRate""
    )
    
, dodo_dvm AS (
    SELECT ""output_newVendingMachine"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DVMFactory_call_createDODOVendingMachine"" WHERE call_success IS TRUE
    )
    
, dodo_dsp AS (
    SELECT ""output_newStablePool"" AS contract_address,
        'DODO v2' AS project,
        ""lpFeeRate""/1e16 AS lp_fee_percentage,
        call_block_time AS block_time 
    FROM dodo.""DSPFactory_call_createDODOStablePool"" WHERE call_success IS TRUE
    )

, balancer_v1 AS (
    SELECT contract_address
    , 'Balancer v1' AS project
    , ""swapFee""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time
    FROM balancer.""BPool_call_setSwapFee"" WHERE call_success = 'true'
    )
    
, balancer_v2 AS (
    SELECT contract_address
    , 'Balancer v2' AS project
    , ""swapFeePercentage""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM balancer_v2.""WeightedPool_evt_SwapFeePercentageChanged""
    )
 
, all_pools AS (SELECT * FROM (
    SELECT * FROM uniswap_v1
    UNION ALL
    SELECT * FROM uniswap_v2
    UNION ALL
    SELECT * FROM uniswap_v3
    UNION ALL
    SELECT * FROM sushiswap
    UNION ALL
    SELECT * FROM curve
    UNION ALL
    SELECT * FROM dodo_v1
    UNION ALL
    SELECT * FROM dodo_dpp
    UNION ALL
    SELECT * FROM dodo_dvm
    UNION ALL
    SELECT * FROM dodo_dsp
    UNION ALL
    SELECT * FROM balancer_v1
    UNION ALL
    SELECT * FROM balancer_v2) joined
    WHERE contract_address =  (SELECT pc FROM pool_contract)
    ) 
    
, dex_pool_fees AS (SELECT DISTINCT ON (start_lp.contract_address, start_lp.block_time) start_lp.contract_address AS contract_address
    , start_lp.project
    , start_lp.lp_fee_percentage
    , start_lp.block_time AS start_block_time
    , COALESCE(end_lp.block_time, '3000-01-01') AS end_block_time
    FROM (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) start_lp
    LEFT JOIN (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) end_lp
    ON start_lp.contract_address = end_lp.contract_address AND start_lp.block_time < end_lp.block_time
    )

        
SELECT date_trunc((SELECT a FROM aggregation), block_time) AS ""Date""
, SUM(dt.usd_amount) AS ""Trading Volume (USD)""
, SUM(dt.usd_amount*dpf.lp_fee_percentage/100) AS ""Accumulated Fees (USD)""
FROM dex.trades dt
LEFT JOIN dex_pool_fees dpf ON dt.block_time BETWEEN dpf.start_block_time AND dpf.end_block_time
WHERE exchange_contract_address = (SELECT pc FROM pool_contract)
AND date_trunc((SELECT a FROM aggregation), block_time) >= (SELECT sd FROM start_and_end_date)
AND date_trunc((SELECT a FROM aggregation), block_time) <= (SELECT ed FROM start_and_end_date)
AND dt.category='DEX'
AND block_time >= '{{Since}}'
GROUP BY ""Date"""
506149,Pool Yield,Fees/TVL,chart,"WITH pool_contract AS (SELECT CASE WHEN LEFT('{{Pool}}', 1) = '\' THEN '{{Pool}}'::bytea 
    WHEN LEFT('{{Pool}}', 1) = '0' THEN ('\' || RIGHT('{{Pool}}', -1))::bytea
    END AS pc
    )
    
, aggregation AS (SELECT CASE WHEN '{{Granularity}}'='Daily' THEN 'day'
    WHEN '{{Granularity}}'='Weekly' THEN 'week'
    WHEN '{{Granularity}}'='Monthly' THEN 'month'
    WHEN '{{Granularity}}'='Yearly' THEN 'year'
    END AS a
    )

, start_and_end_date AS (
    SELECT CASE WHEN dune_user_generated.is_date('{{Since}}')='true' AND '{{Since}}' < NOW() THEN '{{Since}}'::timestamp
        ELSE '2000-01-01'::timestamp END AS sd,
    CASE WHEN dune_user_generated.is_date('{{Until}}')='true' AND '{{Until}}' < NOW() THEN '{{Until}}'::timestamp
        ELSE NOW() END AS ed
    )

, uniswap_v1 AS (
    SELECT exchange AS contract_address
    , 'Uniswap v1' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap.""Factory_evt_NewExchange"")
    
, uniswap_v2 AS (
    SELECT pair AS contract_address
    , 'Uniswap v2' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v2.""Factory_evt_PairCreated""
    )
    
, uniswap_v3 AS (
    SELECT pool AS contract_address
    , 'Uniswap v3' AS project
    , fee/1e4 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v3.""Factory_evt_PoolCreated""
    )

, sushiswap AS (
    SELECT pair AS contract_address
    , 'SushiSwap' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM sushi.""Factory_evt_PairCreated""
    )

, curve AS (
    SELECT '\xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7'::bytea AS contract_address
        , 'Curve' AS project
        , 0.04 AS lp_fee_percentage
        , '2020-09-06 20:23'::timestamp AS block_time
        )

, dodo_v1 AS (
    SELECT ""dppAddress"" AS contract_address
    , 'DODO v1' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DPPFactory_call_initDODOPrivatePool"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v1' AS project
    , ""newLpFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DPP_evt_LpFeeRateChange""
    )
    
, dodo_dpp AS (
    SELECT ""output_newBornDODO"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DODOZoo_call_breedDODO"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v2' AS project
    , ""newLiquidityProviderFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DODO_evt_UpdateLiquidityProviderFeeRate""
    )
    
, dodo_dvm AS (
    SELECT ""output_newVendingMachine"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DVMFactory_call_createDODOVendingMachine"" WHERE call_success IS TRUE
    )
    
, dodo_dsp AS (
    SELECT ""output_newStablePool"" AS contract_address,
        'DODO v2' AS project,
        ""lpFeeRate""/1e16 AS lp_fee_percentage,
        call_block_time AS block_time 
    FROM dodo.""DSPFactory_call_createDODOStablePool"" WHERE call_success IS TRUE
    )

, balancer_v1 AS (
    SELECT contract_address
    , 'Balancer v1' AS project
    , ""swapFee""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time
    FROM balancer.""BPool_call_setSwapFee"" WHERE call_success = 'true'
    )
    
, balancer_v2 AS (
    SELECT contract_address
    , 'Balancer v2' AS project
    , ""swapFeePercentage""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM balancer_v2.""WeightedPool_evt_SwapFeePercentageChanged""
    )
 
, all_pools AS (SELECT * FROM (
    SELECT * FROM uniswap_v1
    UNION ALL
    SELECT * FROM uniswap_v2
    UNION ALL
    SELECT * FROM uniswap_v3
    UNION ALL
    SELECT * FROM sushiswap
    UNION ALL
    SELECT * FROM curve
    UNION ALL
    SELECT * FROM dodo_v1
    UNION ALL
    SELECT * FROM dodo_dpp
    UNION ALL
    SELECT * FROM dodo_dvm
    UNION ALL
    SELECT * FROM dodo_dsp
    UNION ALL
    SELECT * FROM balancer_v1
    UNION ALL
    SELECT * FROM balancer_v2) joined
    WHERE contract_address =  (SELECT pc FROM pool_contract)
    ) 
    
, dex_pool_fees AS (SELECT DISTINCT ON (start_lp.contract_address, start_lp.block_time) start_lp.contract_address AS contract_address
    , start_lp.project
    , start_lp.lp_fee_percentage
    , start_lp.block_time AS start_block_time
    , COALESCE(end_lp.block_time, '3000-01-01') AS end_block_time
    FROM (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) start_lp
    LEFT JOIN (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) end_lp
    ON start_lp.contract_address = end_lp.contract_address AND start_lp.block_time < end_lp.block_time
    )

, time_series AS (
    SELECT distinct date_trunc((SELECT a FROM aggregation) ,generate_series(date_trunc('day', minimum_date),  maximum_date, '1 day')) AS time
    FROM (
        SELECT CASE WHEN sd < (SELECT MIN(start_block_time) FROM dex_pool_fees) THEN (SELECT MIN(start_block_time) FROM dex_pool_fees)
        ELSE sd END AS minimum_date
        , ed AS maximum_date
        FROM start_and_end_date
    ) md
    )

, pooled_tokens AS (
    SELECT CASE WHEN token_a_symbol > token_b_symbol THEN token_b_address ELSE token_a_address END AS token_a
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_address ELSE token_b_address END AS token_b
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_b_symbol ELSE token_a_symbol END AS token_a_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_symbol ELSE token_b_symbol END AS token_b_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, erctb.decimals) ELSE POWER(10, ercta.decimals) END AS token_a_decimals
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, ercta.decimals) ELSE POWER(10, erctb.decimals) END AS token_b_decimals
    FROM dex.trades dt
    LEFT JOIN erc20.""tokens"" ercta ON dt.token_a_address=ercta.contract_address
    LEFT JOIN erc20.""tokens"" erctb ON dt.token_b_address=erctb.contract_address
    WHERE exchange_contract_address=(SELECT pc FROM pool_contract)
    LIMIT 1
    )

, token_prices AS (
    SELECT time
    , MAX(price_token_a) AS price_token_a
    , MAX(price_token_b) AS price_token_b
    FROM
        (SELECT ts.time
        , price AS price_token_a
        , NULL AS price_token_b
        FROM time_series ts
        LEFT JOIN prices.usd pu ON ts.time=pu.minute
        WHERE contract_address=(SELECT token_a FROM pooled_tokens)
        UNION
        SELECT ts.time
        , NULL AS price_token_a
        , price AS price_token_b
        FROM time_series ts
        LEFT JOIN prices.usd pu ON ts.time=pu.minute
        WHERE contract_address=(SELECT token_b FROM pooled_tokens)
        ) ungrouped
    GROUP BY time
    )

, impermanent_loss_total AS (
    SELECT time
    , 2*sqrt(k)/(1+k)-1 AS impermanent_loss_total
    FROM (
        SELECT time,
        (SELECT price_token_a FROM token_prices ORDER BY time LIMIT 1)/price_token_a*
            (SELECT price_token_b FROM token_prices ORDER BY time LIMIT 1)/price_token_b AS k
        FROM token_prices
        ) k 
    )
        
, impermanent_loss AS (
    SELECT time
    , -ABS((2*sqrt(k)/(1+k)-1)-(2*sqrt(last_k)/(1+last_k)-1)) AS impermanent_loss
    FROM (
        SELECT time
        , (SELECT price_token_a FROM token_prices ORDER BY time LIMIT 1)/price_token_a*
            (SELECT price_token_b FROM token_prices ORDER BY time LIMIT 1)/price_token_b AS k
        , LAG((SELECT price_token_a FROM token_prices ORDER BY time LIMIT 1)/price_token_a*
            (SELECT price_token_b FROM token_prices ORDER BY time LIMIT 1)/price_token_b) OVER (ORDER BY time) AS last_k
        FROM token_prices
        ) k 
    )

, pool_volume AS (SELECT time
    , usd_volume
    , SUM(usd_volume) OVER (ORDER BY time RANGE UNBOUNDED PRECEDING) AS cumulative_usd_volume
    , usd_fees
    , SUM(usd_fees) OVER (ORDER BY time RANGE UNBOUNDED PRECEDING) AS cumulative_usd_fees
    FROM (SELECT date_trunc((SELECT a FROM aggregation), block_time) AS time
        , SUM(dt.usd_amount) AS usd_volume
        , SUM(dt.usd_amount*dpf.lp_fee_percentage/100) AS usd_fees
        FROM dex.trades dt
        LEFT JOIN dex_pool_fees dpf ON dt.block_time BETWEEN dpf.start_block_time AND dpf.end_block_time
        WHERE exchange_contract_address = (SELECT pc FROM pool_contract)
        AND dt.category='DEX'
        AND block_time >= '{{Since}}'
        GROUP BY time
        ) uncumulated
    )
    
    
, pooled_tokens_volume AS (
    SELECT t.time
    , SUM(SUM(amount_a/(SELECT token_a_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_a_amount
    , SUM(SUM(amount_b/(SELECT token_b_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_b_amount
    , MAX(price_token_a)*SUM(SUM(amount_a/(SELECT token_a_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_a_amount_usd
    , MAX(price_token_b)*SUM(SUM(amount_b/(SELECT token_b_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_b_amount_usd
    FROM (
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , SUM(value) AS amount_a
        , 0 AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""to"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_a FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , -SUM(value) AS amount_a
        , 0 AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""from"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_a FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , 0 AS amount_a
        , SUM(value) AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""to"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_b FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , 0 AS amount_a
        , -SUM(value) AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""from"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_b FROM pooled_tokens)
        GROUP BY 1
        ) t
    LEFT JOIN token_prices tp ON t.time=tp.time
    GROUP BY t.time
    )
    
, pool_yield AS (
    SELECT pv.time
    , pv.usd_fees/(ptv.token_a_amount_usd+ptv.token_b_amount_usd) AS pool_yield
    , SUM(SUM(pv.usd_fees/(ptv.token_a_amount_usd+ptv.token_b_amount_usd))) OVER (ORDER BY pv.time RANGE UNBOUNDED PRECEDING) AS cum_pool_yield
    FROM pool_volume pv
    LEFT JOIN pooled_tokens_volume ptv ON pv.time = ptv.time
    GROUP BY pv.time, pv.usd_fees,ptv.token_a_amount_usd,ptv.token_b_amount_usd
    )


SELECT tp.time AS ""Date""
, py.cum_pool_yield AS ""Cumulated Pool Yield""
, py.pool_yield AS ""Pool Yield""
, py.pool_yield+impermanent_loss AS ""Net Pool Yield""
, py.cum_pool_yield+impermanent_loss_total AS ""Net Cumulated Pool Yield""
FROM token_prices tp
LEFT JOIN pool_yield py ON tp.time = py.time
LEFT JOIN impermanent_loss il ON tp.time=il.time
LEFT JOIN impermanent_loss_total ilt ON tp.time=ilt.time
WHERE tp.time < date_trunc('day', NOW())"
494268,Pool TVL,in $,table,"WITH pool_contract AS (SELECT CASE WHEN LEFT('{{Pool}}', 1) = '\' THEN '{{Pool}}'::bytea 
    WHEN LEFT('{{Pool}}', 1) = '0' THEN ('\' || RIGHT('{{Pool}}', -1))::bytea
    END AS pc
    )
    
, aggregation AS (SELECT CASE WHEN '{{Granularity}}'='Daily' THEN 'day'
    WHEN '{{Granularity}}'='Weekly' THEN 'week'
    WHEN '{{Granularity}}'='Monthly' THEN 'month'
    WHEN '{{Granularity}}'='Yearly' THEN 'year'
    END AS a
    )

, start_and_end_date AS (
    SELECT CASE WHEN dune_user_generated.is_date('{{Since}}')='true' AND '{{Since}}' < NOW() THEN '{{Since}}'::timestamp
        ELSE '2000-01-01'::timestamp END AS sd,
    CASE WHEN dune_user_generated.is_date('{{Until}}')='true' AND '{{Until}}' < NOW() THEN '{{Until}}'::timestamp
        ELSE NOW() END AS ed
    )

, uniswap_v1 AS (
    SELECT exchange AS contract_address
    , 'Uniswap v1' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap.""Factory_evt_NewExchange"")
    
, uniswap_v2 AS (
    SELECT pair AS contract_address
    , 'Uniswap v2' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v2.""Factory_evt_PairCreated""
    )
    
, uniswap_v3 AS (
    SELECT pool AS contract_address
    , 'Uniswap v3' AS project
    , fee/1e4 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v3.""Factory_evt_PoolCreated""
    )

, sushiswap AS (
    SELECT pair AS contract_address
    , 'SushiSwap' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM sushi.""Factory_evt_PairCreated""
    )

, curve AS (
    SELECT '\xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7'::bytea AS contract_address
        , 'Curve' AS project
        , 0.04 AS lp_fee_percentage
        , '2020-09-06 20:23'::timestamp AS block_time
        )

, dodo_v1 AS (
    SELECT ""dppAddress"" AS contract_address
    , 'DODO v1' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DPPFactory_call_initDODOPrivatePool"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v1' AS project
    , ""newLpFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DPP_evt_LpFeeRateChange""
    )
    
, dodo_dpp AS (
    SELECT ""output_newBornDODO"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DODOZoo_call_breedDODO"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v2' AS project
    , ""newLiquidityProviderFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DODO_evt_UpdateLiquidityProviderFeeRate""
    )
    
, dodo_dvm AS (
    SELECT ""output_newVendingMachine"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DVMFactory_call_createDODOVendingMachine"" WHERE call_success IS TRUE
    )
    
, dodo_dsp AS (
    SELECT ""output_newStablePool"" AS contract_address,
        'DODO v2' AS project,
        ""lpFeeRate""/1e16 AS lp_fee_percentage,
        call_block_time AS block_time 
    FROM dodo.""DSPFactory_call_createDODOStablePool"" WHERE call_success IS TRUE
    )

, balancer_v1 AS (
    SELECT contract_address
    , 'Balancer v1' AS project
    , ""swapFee""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time
    FROM balancer.""BPool_call_setSwapFee"" WHERE call_success = 'true'
    )
    
, balancer_v2 AS (
    SELECT contract_address
    , 'Balancer v2' AS project
    , ""swapFeePercentage""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM balancer_v2.""WeightedPool_evt_SwapFeePercentageChanged""
    )
 
, all_pools AS (SELECT * FROM (
    SELECT * FROM uniswap_v1
    UNION ALL
    SELECT * FROM uniswap_v2
    UNION ALL
    SELECT * FROM uniswap_v3
    UNION ALL
    SELECT * FROM sushiswap
    UNION ALL
    SELECT * FROM curve
    UNION ALL
    SELECT * FROM dodo_v1
    UNION ALL
    SELECT * FROM dodo_dpp
    UNION ALL
    SELECT * FROM dodo_dvm
    UNION ALL
    SELECT * FROM dodo_dsp
    UNION ALL
    SELECT * FROM balancer_v1
    UNION ALL
    SELECT * FROM balancer_v2) joined
    WHERE contract_address =  (SELECT pc FROM pool_contract)
    ) 
    
, dex_pool_fees AS (SELECT DISTINCT ON (start_lp.contract_address, start_lp.block_time) start_lp.contract_address AS contract_address
    , start_lp.project
    , start_lp.lp_fee_percentage
    , start_lp.block_time AS start_block_time
    , COALESCE(end_lp.block_time, '3000-01-01') AS end_block_time
    FROM (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) start_lp
    LEFT JOIN (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) end_lp
    ON start_lp.contract_address = end_lp.contract_address AND start_lp.block_time < end_lp.block_time
    )

, time_series AS (
    SELECT distinct date_trunc((SELECT a FROM aggregation) ,generate_series(date_trunc('day', minimum_date),  maximum_date, '1 day')) AS time
    FROM (
        SELECT CASE WHEN sd < (SELECT MIN(start_block_time) FROM dex_pool_fees) THEN (SELECT MIN(start_block_time) FROM dex_pool_fees)
        ELSE sd END AS minimum_date
        , ed AS maximum_date
        FROM start_and_end_date
    ) md
    )

, pooled_tokens AS (
    SELECT CASE WHEN token_a_symbol > token_b_symbol THEN token_b_address ELSE token_a_address END AS token_a
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_address ELSE token_b_address END AS token_b
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_b_symbol ELSE token_a_symbol END AS token_a_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_symbol ELSE token_b_symbol END AS token_b_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, erctb.decimals) ELSE POWER(10, ercta.decimals) END AS token_a_decimals
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, ercta.decimals) ELSE POWER(10, erctb.decimals) END AS token_b_decimals
    FROM dex.trades dt
    LEFT JOIN erc20.""tokens"" ercta ON dt.token_a_address=ercta.contract_address
    LEFT JOIN erc20.""tokens"" erctb ON dt.token_b_address=erctb.contract_address
    WHERE exchange_contract_address=(SELECT pc FROM pool_contract)
    LIMIT 1
    )

, token_prices AS (
    SELECT time
    , MAX(price_token_a) AS price_token_a
    , MAX(price_token_b) AS price_token_b
    FROM
        (SELECT ts.time
        , price AS price_token_a
        , NULL AS price_token_b
        FROM time_series ts
        LEFT JOIN prices.usd pu ON ts.time=pu.minute
        WHERE contract_address=(SELECT token_a FROM pooled_tokens)
        UNION
        SELECT ts.time
        , NULL AS price_token_a
        , price AS price_token_b
        FROM time_series ts
        LEFT JOIN prices.usd pu ON ts.time=pu.minute
        WHERE contract_address=(SELECT token_b FROM pooled_tokens)
        ) ungrouped
    GROUP BY time
    )
    
    
SELECT *
FROM (SELECT t.time AS ""Date""
    , MAX(price_token_a)*SUM(SUM(amount_a/(SELECT token_a_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS ""Token A TVL (USD)""
    , MAX(price_token_b)*SUM(SUM(amount_b/(SELECT token_b_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS ""Token B TVL (USD)""
    , MAX(price_token_a)*SUM(SUM(amount_a/(SELECT token_a_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) +
    MAX(price_token_b)*SUM(SUM(amount_b/(SELECT token_b_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS ""Total TVL (USD)""
    FROM (
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , SUM(value) AS amount_a
        , 0 AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""to"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_a FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , -SUM(value) AS amount_a
        , 0 AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""from"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_a FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , 0 AS amount_a
        , SUM(value) AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""to"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_b FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , 0 AS amount_a
        , -SUM(value) AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""from"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_b FROM pooled_tokens)
        GROUP BY 1
        ) t
    LEFT JOIN token_prices tp ON t.time=tp.time
    GROUP BY t.time
) t2
WHERE ""Date"" >= (SELECT sd FROM start_and_end_date)
AND ""Date"" <= (SELECT ed FROM start_and_end_date)
AND ""Date"" < date_trunc('day', NOW())"
506184,Net Pool Yield,Fees/TVL + Impermanent Loss,table,"WITH pool_contract AS (SELECT CASE WHEN LEFT('{{Pool}}', 1) = '\' THEN '{{Pool}}'::bytea 
    WHEN LEFT('{{Pool}}', 1) = '0' THEN ('\' || RIGHT('{{Pool}}', -1))::bytea
    END AS pc
    )
    
, aggregation AS (SELECT CASE WHEN '{{Granularity}}'='Daily' THEN 'day'
    WHEN '{{Granularity}}'='Weekly' THEN 'week'
    WHEN '{{Granularity}}'='Monthly' THEN 'month'
    WHEN '{{Granularity}}'='Yearly' THEN 'year'
    END AS a
    )

, start_and_end_date AS (
    SELECT CASE WHEN dune_user_generated.is_date('{{Since}}')='true' AND '{{Since}}' < NOW() THEN '{{Since}}'::timestamp
        ELSE '2000-01-01'::timestamp END AS sd,
    CASE WHEN dune_user_generated.is_date('{{Until}}')='true' AND '{{Until}}' < NOW() THEN '{{Until}}'::timestamp
        ELSE NOW() END AS ed
    )

, uniswap_v1 AS (
    SELECT exchange AS contract_address
    , 'Uniswap v1' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap.""Factory_evt_NewExchange"")
    
, uniswap_v2 AS (
    SELECT pair AS contract_address
    , 'Uniswap v2' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v2.""Factory_evt_PairCreated""
    )
    
, uniswap_v3 AS (
    SELECT pool AS contract_address
    , 'Uniswap v3' AS project
    , fee/1e4 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v3.""Factory_evt_PoolCreated""
    )

, sushiswap AS (
    SELECT pair AS contract_address
    , 'SushiSwap' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM sushi.""Factory_evt_PairCreated""
    )

, curve AS (
    SELECT '\xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7'::bytea AS contract_address
        , 'Curve' AS project
        , 0.04 AS lp_fee_percentage
        , '2020-09-06 20:23'::timestamp AS block_time
        )

, dodo_v1 AS (
    SELECT ""dppAddress"" AS contract_address
    , 'DODO v1' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DPPFactory_call_initDODOPrivatePool"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v1' AS project
    , ""newLpFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DPP_evt_LpFeeRateChange""
    )
    
, dodo_dpp AS (
    SELECT ""output_newBornDODO"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DODOZoo_call_breedDODO"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v2' AS project
    , ""newLiquidityProviderFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DODO_evt_UpdateLiquidityProviderFeeRate""
    )
    
, dodo_dvm AS (
    SELECT ""output_newVendingMachine"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DVMFactory_call_createDODOVendingMachine"" WHERE call_success IS TRUE
    )
    
, dodo_dsp AS (
    SELECT ""output_newStablePool"" AS contract_address,
        'DODO v2' AS project,
        ""lpFeeRate""/1e16 AS lp_fee_percentage,
        call_block_time AS block_time 
    FROM dodo.""DSPFactory_call_createDODOStablePool"" WHERE call_success IS TRUE
    )

, balancer_v1 AS (
    SELECT contract_address
    , 'Balancer v1' AS project
    , ""swapFee""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time
    FROM balancer.""BPool_call_setSwapFee"" WHERE call_success = 'true'
    )
    
, balancer_v2 AS (
    SELECT contract_address
    , 'Balancer v2' AS project
    , ""swapFeePercentage""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM balancer_v2.""WeightedPool_evt_SwapFeePercentageChanged""
    )
 
, all_pools AS (SELECT * FROM (
    SELECT * FROM uniswap_v1
    UNION ALL
    SELECT * FROM uniswap_v2
    UNION ALL
    SELECT * FROM uniswap_v3
    UNION ALL
    SELECT * FROM sushiswap
    UNION ALL
    SELECT * FROM curve
    UNION ALL
    SELECT * FROM dodo_v1
    UNION ALL
    SELECT * FROM dodo_dpp
    UNION ALL
    SELECT * FROM dodo_dvm
    UNION ALL
    SELECT * FROM dodo_dsp
    UNION ALL
    SELECT * FROM balancer_v1
    UNION ALL
    SELECT * FROM balancer_v2) joined
    WHERE contract_address =  (SELECT pc FROM pool_contract)
    ) 
    
, dex_pool_fees AS (SELECT DISTINCT ON (start_lp.contract_address, start_lp.block_time) start_lp.contract_address AS contract_address
    , start_lp.project
    , start_lp.lp_fee_percentage
    , start_lp.block_time AS start_block_time
    , COALESCE(end_lp.block_time, '3000-01-01') AS end_block_time
    FROM (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) start_lp
    LEFT JOIN (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) end_lp
    ON start_lp.contract_address = end_lp.contract_address AND start_lp.block_time < end_lp.block_time
    )

, time_series AS (
    SELECT distinct date_trunc((SELECT a FROM aggregation) ,generate_series(date_trunc('day', minimum_date),  maximum_date, '1 day')) AS time
    FROM (
        SELECT CASE WHEN sd < (SELECT MIN(start_block_time) FROM dex_pool_fees) THEN (SELECT MIN(start_block_time) FROM dex_pool_fees)
        ELSE sd END AS minimum_date
        , ed AS maximum_date
        FROM start_and_end_date
    ) md
    )

, pooled_tokens AS (
    SELECT CASE WHEN token_a_symbol > token_b_symbol THEN token_b_address ELSE token_a_address END AS token_a
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_address ELSE token_b_address END AS token_b
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_b_symbol ELSE token_a_symbol END AS token_a_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_symbol ELSE token_b_symbol END AS token_b_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, erctb.decimals) ELSE POWER(10, ercta.decimals) END AS token_a_decimals
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, ercta.decimals) ELSE POWER(10, erctb.decimals) END AS token_b_decimals
    FROM dex.trades dt
    LEFT JOIN erc20.""tokens"" ercta ON dt.token_a_address=ercta.contract_address
    LEFT JOIN erc20.""tokens"" erctb ON dt.token_b_address=erctb.contract_address
    WHERE exchange_contract_address=(SELECT pc FROM pool_contract)
    LIMIT 1
    )

, token_prices AS (
    SELECT time
    , MAX(price_token_a) AS price_token_a
    , MAX(price_token_b) AS price_token_b
    FROM
        (SELECT ts.time
        , price AS price_token_a
        , NULL AS price_token_b
        FROM time_series ts
        LEFT JOIN prices.usd pu ON ts.time=pu.minute
        WHERE contract_address=(SELECT token_a FROM pooled_tokens)
        UNION
        SELECT ts.time
        , NULL AS price_token_a
        , price AS price_token_b
        FROM time_series ts
        LEFT JOIN prices.usd pu ON ts.time=pu.minute
        WHERE contract_address=(SELECT token_b FROM pooled_tokens)
        ) ungrouped
    GROUP BY time
    )

, impermanent_loss_total AS (
    SELECT time
    , 2*sqrt(k)/(1+k)-1 AS impermanent_loss_total
    FROM (
        SELECT time,
        (SELECT price_token_a FROM token_prices ORDER BY time LIMIT 1)/price_token_a*
            (SELECT price_token_b FROM token_prices ORDER BY time LIMIT 1)/price_token_b AS k
        FROM token_prices
        ) k 
    )
        
, impermanent_loss AS (
    SELECT time
    , -ABS((2*sqrt(k)/(1+k)-1)-(2*sqrt(last_k)/(1+last_k)-1)) AS impermanent_loss
    FROM (
        SELECT time
        , (SELECT price_token_a FROM token_prices ORDER BY time LIMIT 1)/price_token_a*
            (SELECT price_token_b FROM token_prices ORDER BY time LIMIT 1)/price_token_b AS k
        , LAG((SELECT price_token_a FROM token_prices ORDER BY time LIMIT 1)/price_token_a*
            (SELECT price_token_b FROM token_prices ORDER BY time LIMIT 1)/price_token_b) OVER (ORDER BY time) AS last_k
        FROM token_prices
        ) k 
    )

, pool_volume AS (SELECT time
    , usd_volume
    , SUM(usd_volume) OVER (ORDER BY time RANGE UNBOUNDED PRECEDING) AS cumulative_usd_volume
    , usd_fees
    , SUM(usd_fees) OVER (ORDER BY time RANGE UNBOUNDED PRECEDING) AS cumulative_usd_fees
    FROM (SELECT date_trunc((SELECT a FROM aggregation), block_time) AS time
        , SUM(dt.usd_amount) AS usd_volume
        , SUM(dt.usd_amount*dpf.lp_fee_percentage/100) AS usd_fees
        FROM dex.trades dt
        LEFT JOIN dex_pool_fees dpf ON dt.block_time BETWEEN dpf.start_block_time AND dpf.end_block_time
        WHERE exchange_contract_address = (SELECT pc FROM pool_contract)
        AND dt.category='DEX'
        AND block_time >= '{{Since}}'
        GROUP BY time
        ) uncumulated
    )
    
    
, pooled_tokens_volume AS (
    SELECT t.time
    , SUM(SUM(amount_a/(SELECT token_a_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_a_amount
    , SUM(SUM(amount_b/(SELECT token_b_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_b_amount
    , MAX(price_token_a)*SUM(SUM(amount_a/(SELECT token_a_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_a_amount_usd
    , MAX(price_token_b)*SUM(SUM(amount_b/(SELECT token_b_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_b_amount_usd
    FROM (
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , SUM(value) AS amount_a
        , 0 AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""to"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_a FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , -SUM(value) AS amount_a
        , 0 AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""from"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_a FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , 0 AS amount_a
        , SUM(value) AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""to"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_b FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , 0 AS amount_a
        , -SUM(value) AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""from"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_b FROM pooled_tokens)
        GROUP BY 1
        ) t
    LEFT JOIN token_prices tp ON t.time=tp.time
    GROUP BY t.time
    )
    
, pool_yield AS (
    SELECT pv.time
    , pv.usd_fees/(ptv.token_a_amount_usd+ptv.token_b_amount_usd) AS pool_yield
    , SUM(SUM(pv.usd_fees/(ptv.token_a_amount_usd+ptv.token_b_amount_usd))) OVER (ORDER BY pv.time RANGE UNBOUNDED PRECEDING) AS cum_pool_yield
    FROM pool_volume pv
    LEFT JOIN pooled_tokens_volume ptv ON pv.time = ptv.time
    GROUP BY pv.time, pv.usd_fees,ptv.token_a_amount_usd,ptv.token_b_amount_usd
    )


SELECT tp.time AS ""Date""
, py.cum_pool_yield AS ""Cumulated Pool Yield""
, py.pool_yield AS ""Pool Yield""
, py.pool_yield+impermanent_loss AS ""Net Pool Yield""
, py.cum_pool_yield+impermanent_loss_total AS ""Net Cumulated Pool Yield""
, AVG(POWER((1+py.pool_yield+impermanent_loss), 365)-1) OVER (ORDER BY tp.time ROWS BETWEEN 7 PRECEDING AND CURRENT ROW ) AS ""1W MA""
, AVG(POWER((1+py.pool_yield+impermanent_loss), 365)-1) OVER (ORDER BY tp.time ROWS BETWEEN 30 PRECEDING AND CURRENT ROW ) AS ""1M MA""
, AVG(POWER((1+py.pool_yield+impermanent_loss), 365)-1) OVER (ORDER BY tp.time ROWS BETWEEN 90 PRECEDING AND CURRENT ROW ) AS ""3M MA""
FROM token_prices tp
LEFT JOIN pool_yield py ON tp.time = py.time
LEFT JOIN impermanent_loss il ON tp.time=il.time
LEFT JOIN impermanent_loss_total ilt ON tp.time=ilt.time
WHERE tp.time < date_trunc('day', NOW())"
434021,Top DEX Pairs by Volume,During the Past Month,table,"WITH ungrouped AS (
    SELECT CASE WHEN token_a_symbol < token_b_symbol THEN token_a_symbol || '-' || token_b_symbol
        ELSE token_b_symbol || '-' || token_a_symbol END AS pair
    , exchange_contract_address
    , CASE WHEN (version IS NOT NULL AND project NOT IN ('airswap', 'dYdX')) THEN project || ' v' || version
        WHEN project IN ('airswap', 'dYdX') THEN project || ' ' || version
        ELSE project END AS project
    , SUM(COALESCE(usd_amount,0)) AS volume
    FROM dex.""trades""
    WHERE block_time >= NOW() - interval '1 month'
    AND category = 'DEX'
    AND project NOT IN ('0x API', '0x Native', '1inch', '1inch Limit Order Protocol')
    GROUP BY project, exchange_contract_address, token_a_symbol, token_b_symbol, version
    )


SELECT ROW_NUMBER() OVER (ORDER BY SUM(COALESCE(volume,0)) DESC) AS ""Rank""
, pair AS ""Pair""
, project AS ""Project""
, SUM(volume) AS ""USD Volume""
, '<a href=""https://etherscan.io/address/0' || substring(exchange_contract_address::text from 2) || '"" target=""_blank"" >0' || substring(exchange_contract_address::text from 2 for 5) || '...' || substring(exchange_contract_address::text from 39 for 4) || '</a>' AS ""Contract Address""
, '<a href=""https://dune.xyz/hildobby/DEX-Pool-Deep-Dive?Pool=0' || substring(exchange_contract_address::text from 2) || '"" target=""_blank"" >Dashboard Link</a>' AS ""Dune Analytics""
FROM ungrouped
GROUP BY project, exchange_contract_address, pair"
474028,Pool Total,in $,counter,"WITH pool_contract AS (SELECT CASE WHEN LEFT('{{Pool}}', 1) = '\' THEN '{{Pool}}'::bytea 
    WHEN LEFT('{{Pool}}', 1) = '0' THEN ('\' || RIGHT('{{Pool}}', -1))::bytea
    END AS pc
    )

, start_and_end_date AS (
    SELECT CASE WHEN dune_user_generated.is_date('{{Since}}')='true' AND '{{Since}}' < NOW() THEN '{{Since}}'::timestamp
        ELSE '2000-01-01'::timestamp END AS sd,
    CASE WHEN dune_user_generated.is_date('{{Until}}')='true' AND '{{Until}}' < NOW() THEN '{{Until}}'::timestamp
        ELSE NOW() END AS ed
    )

, uniswap_v1 AS (
    SELECT exchange AS contract_address
    , 'Uniswap v1' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap.""Factory_evt_NewExchange"")
    
, uniswap_v2 AS (
    SELECT pair AS contract_address
    , 'Uniswap v2' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v2.""Factory_evt_PairCreated""
    )
    
, uniswap_v3 AS (
    SELECT pool AS contract_address
    , 'Uniswap v3' AS project
    , fee/1e4 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v3.""Factory_evt_PoolCreated""
    )

, sushiswap AS (
    SELECT pair AS contract_address
    , 'SushiSwap' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM sushi.""Factory_evt_PairCreated""
    )

, curve AS (
    SELECT '\xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7'::bytea AS contract_address
        , 'Curve' AS project
        , 0.04 AS lp_fee_percentage
        , '2020-09-06 20:23'::timestamp AS block_time
        )

, dodo_v1 AS (
    SELECT ""dppAddress"" AS contract_address
    , 'DODO v1' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DPPFactory_call_initDODOPrivatePool"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v1' AS project
    , ""newLpFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DPP_evt_LpFeeRateChange""
    )
    
, dodo_dpp AS (
    SELECT ""output_newBornDODO"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DODOZoo_call_breedDODO"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v2' AS project
    , ""newLiquidityProviderFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DODO_evt_UpdateLiquidityProviderFeeRate""
    )
    
, dodo_dvm AS (
    SELECT ""output_newVendingMachine"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DVMFactory_call_createDODOVendingMachine"" WHERE call_success IS TRUE
    )
    
, dodo_dsp AS (
    SELECT ""output_newStablePool"" AS contract_address,
        'DODO v2' AS project,
        ""lpFeeRate""/1e16 AS lp_fee_percentage,
        call_block_time AS block_time 
    FROM dodo.""DSPFactory_call_createDODOStablePool"" WHERE call_success IS TRUE
    )

, balancer_v1 AS (
    SELECT contract_address
    , 'Balancer v1' AS project
    , ""swapFee""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time
    FROM balancer.""BPool_call_setSwapFee"" WHERE call_success = 'true'
    )
    
, balancer_v2 AS (
    SELECT contract_address
    , 'Balancer v2' AS project
    , ""swapFeePercentage""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM balancer_v2.""WeightedPool_evt_SwapFeePercentageChanged""
    )
 
, all_pools AS (SELECT * FROM (
    SELECT * FROM uniswap_v1
    UNION ALL
    SELECT * FROM uniswap_v2
    UNION ALL
    SELECT * FROM uniswap_v3
    UNION ALL
    SELECT * FROM sushiswap
    UNION ALL
    SELECT * FROM curve
    UNION ALL
    SELECT * FROM dodo_v1
    UNION ALL
    SELECT * FROM dodo_dpp
    UNION ALL
    SELECT * FROM dodo_dvm
    UNION ALL
    SELECT * FROM dodo_dsp
    UNION ALL
    SELECT * FROM balancer_v1
    UNION ALL
    SELECT * FROM balancer_v2) joined
    WHERE contract_address =  (SELECT pc FROM pool_contract)
    ) 
    
, dex_pool_fees AS (SELECT DISTINCT ON (start_lp.contract_address, start_lp.block_time) start_lp.contract_address AS contract_address
    , start_lp.project
    , start_lp.lp_fee_percentage
    , start_lp.block_time AS start_block_time
    , COALESCE(end_lp.block_time, '3000-01-01') AS end_block_time
    FROM (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) start_lp
    LEFT JOIN (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) end_lp
    ON start_lp.contract_address = end_lp.contract_address AND start_lp.block_time < end_lp.block_time
    )


SELECT SUM(usd_amount) AS ""USD Volume""
, SUM(usd_amount*lp_fee_percentage) AS ""Accumulated Fees""
FROM dex.trades dt
LEFT JOIN dex_pool_fees dpf ON dpf.contract_address = dt.exchange_contract_address
    AND (dt.block_time BETWEEN dpf.start_block_time AND dpf.end_block_time)
WHERE exchange_contract_address = (SELECT pc FROM pool_contract)
AND dt.category='DEX'
AND block_time >= (SELECT sd FROM start_and_end_date)
AND block_time <= (SELECT ed FROM start_and_end_date)"
451793,Pool Granular Stats,,table,"WITH pool_contract AS (SELECT CASE WHEN LEFT('{{Pool}}', 1) = '\' THEN '{{Pool}}'::bytea 
    WHEN LEFT('{{Pool}}', 1) = '0' THEN ('\' || RIGHT('{{Pool}}', -1))::bytea
    END AS pc
    )
    
, aggregation AS (SELECT CASE WHEN '{{Granularity}}'='Daily' THEN 'day'
    WHEN '{{Granularity}}'='Weekly' THEN 'week'
    WHEN '{{Granularity}}'='Monthly' THEN 'month'
    WHEN '{{Granularity}}'='Yearly' THEN 'year'
    END AS a
    )

, start_and_end_date AS (
    SELECT CASE WHEN dune_user_generated.is_date('{{Since}}')='true' AND '{{Since}}' < NOW() THEN '{{Since}}'::timestamp
        ELSE '2000-01-01'::timestamp END AS sd,
    CASE WHEN dune_user_generated.is_date('{{Until}}')='true' AND '{{Until}}' < NOW() THEN '{{Until}}'::timestamp
        ELSE NOW() END AS ed
    )

, uniswap_v1 AS (
    SELECT exchange AS contract_address
    , 'Uniswap v1' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap.""Factory_evt_NewExchange"")
    
, uniswap_v2 AS (
    SELECT pair AS contract_address
    , 'Uniswap v2' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v2.""Factory_evt_PairCreated""
    )
    
, uniswap_v3 AS (
    SELECT pool AS contract_address
    , 'Uniswap v3' AS project
    , fee/1e4 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v3.""Factory_evt_PoolCreated""
    )

, sushiswap AS (
    SELECT pair AS contract_address
    , 'SushiSwap' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM sushi.""Factory_evt_PairCreated""
    )

, curve AS (
    SELECT '\xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7'::bytea AS contract_address
        , 'Curve' AS project
        , 0.04 AS lp_fee_percentage
        , '2020-09-06 20:23'::timestamp AS block_time
        )

, dodo_v1 AS (
    SELECT ""dppAddress"" AS contract_address
    , 'DODO v1' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DPPFactory_call_initDODOPrivatePool"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v1' AS project
    , ""newLpFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DPP_evt_LpFeeRateChange""
    )
    
, dodo_dpp AS (
    SELECT ""output_newBornDODO"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DODOZoo_call_breedDODO"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v2' AS project
    , ""newLiquidityProviderFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DODO_evt_UpdateLiquidityProviderFeeRate""
    )
    
, dodo_dvm AS (
    SELECT ""output_newVendingMachine"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DVMFactory_call_createDODOVendingMachine"" WHERE call_success IS TRUE
    )
    
, dodo_dsp AS (
    SELECT ""output_newStablePool"" AS contract_address,
        'DODO v2' AS project,
        ""lpFeeRate""/1e16 AS lp_fee_percentage,
        call_block_time AS block_time 
    FROM dodo.""DSPFactory_call_createDODOStablePool"" WHERE call_success IS TRUE
    )

, balancer_v1 AS (
    SELECT contract_address
    , 'Balancer v1' AS project
    , ""swapFee""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time
    FROM balancer.""BPool_call_setSwapFee"" WHERE call_success = 'true'
    )
    
, balancer_v2 AS (
    SELECT contract_address
    , 'Balancer v2' AS project
    , ""swapFeePercentage""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM balancer_v2.""WeightedPool_evt_SwapFeePercentageChanged""
    )
 
, all_pools AS (SELECT * FROM (
    SELECT * FROM uniswap_v1
    UNION ALL
    SELECT * FROM uniswap_v2
    UNION ALL
    SELECT * FROM uniswap_v3
    UNION ALL
    SELECT * FROM sushiswap
    UNION ALL
    SELECT * FROM curve
    UNION ALL
    SELECT * FROM dodo_v1
    UNION ALL
    SELECT * FROM dodo_dpp
    UNION ALL
    SELECT * FROM dodo_dvm
    UNION ALL
    SELECT * FROM dodo_dsp
    UNION ALL
    SELECT * FROM balancer_v1
    UNION ALL
    SELECT * FROM balancer_v2) joined
    WHERE contract_address =  (SELECT pc FROM pool_contract)
    ) 
    
, dex_pool_fees AS (SELECT DISTINCT ON (start_lp.contract_address, start_lp.block_time) start_lp.contract_address AS contract_address
    , start_lp.project
    , start_lp.lp_fee_percentage
    , start_lp.block_time AS start_block_time
    , COALESCE(end_lp.block_time, '3000-01-01') AS end_block_time
    FROM (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) start_lp
    LEFT JOIN (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) end_lp
    ON start_lp.contract_address = end_lp.contract_address AND start_lp.block_time < end_lp.block_time
    )

, time_series AS (
    SELECT distinct date_trunc((SELECT a FROM aggregation) ,generate_series(date_trunc('day', minimum_date),  maximum_date, '1 day')) AS time
    FROM (
        SELECT CASE WHEN sd < (SELECT MIN(start_block_time) FROM dex_pool_fees) THEN (SELECT MIN(start_block_time) FROM dex_pool_fees)
        ELSE sd END AS minimum_date
        , ed AS maximum_date
        FROM start_and_end_date
    ) md
    )

, pooled_tokens AS (
    SELECT CASE WHEN token_a_symbol > token_b_symbol THEN token_b_address ELSE token_a_address END AS token_a
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_address ELSE token_b_address END AS token_b
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_b_symbol ELSE token_a_symbol END AS token_a_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_symbol ELSE token_b_symbol END AS token_b_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, erctb.decimals) ELSE POWER(10, ercta.decimals) END AS token_a_decimals
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, ercta.decimals) ELSE POWER(10, erctb.decimals) END AS token_b_decimals
    FROM dex.trades dt
    LEFT JOIN erc20.""tokens"" ercta ON dt.token_a_address=ercta.contract_address
    LEFT JOIN erc20.""tokens"" erctb ON dt.token_b_address=erctb.contract_address
    WHERE exchange_contract_address=(SELECT pc FROM pool_contract)
    LIMIT 1
    )

, token_prices AS (
    SELECT time
    , MAX(price_token_a) AS price_token_a
    , MAX(price_token_b) AS price_token_b
    FROM
        (SELECT ts.time
        , COALESCE(price, median_price) AS price_token_a
        , NULL AS price_token_b
        FROM time_series ts
        LEFT JOIN prices.usd pu ON ts.time=pu.minute
        LEFT JOIN prices.""prices_from_dex_data"" pud ON date_trunc('hour', ts.time)=pud.hour
        WHERE pu.contract_address=(SELECT token_a FROM pooled_tokens)
        AND pud.contract_address=(SELECT token_a FROM pooled_tokens)
        UNION
        SELECT ts.time
        , NULL AS price_token_a
        , COALESCE(price, median_price) AS price_token_b
        FROM time_series ts
        LEFT JOIN prices.usd pu ON ts.time=pu.minute
        LEFT JOIN prices.""prices_from_dex_data"" pud ON date_trunc('hour', ts.time)=pud.hour
        WHERE pu.contract_address=(SELECT token_b FROM pooled_tokens)
        AND pud.contract_address=(SELECT token_b FROM pooled_tokens)
        ) ungrouped
    GROUP BY time
    )

, impermanent_loss_total AS (
    SELECT time
    , 2*sqrt(k)/(1+k)-1 AS impermanent_loss_total
    FROM (
        SELECT time,
        (SELECT price_token_a FROM token_prices ORDER BY time LIMIT 1)/price_token_a*
            (SELECT price_token_b FROM token_prices ORDER BY time LIMIT 1)/price_token_b AS k
        FROM token_prices
        ) k 
    )
        
, impermanent_loss AS (
    SELECT time
    , -ABS((2*sqrt(k)/(1+k)-1)-(2*sqrt(last_k)/(1+last_k)-1)) AS impermanent_loss
    FROM (
        SELECT time
        , (SELECT price_token_a FROM token_prices ORDER BY time LIMIT 1)/price_token_a*
            (SELECT price_token_b FROM token_prices ORDER BY time LIMIT 1)/price_token_b AS k
        , LAG((SELECT price_token_a FROM token_prices ORDER BY time LIMIT 1)/price_token_a*
            (SELECT price_token_b FROM token_prices ORDER BY time LIMIT 1)/price_token_b) OVER (ORDER BY time) AS last_k
        FROM token_prices
        ) k 
    )

, pool_volume AS (SELECT time
    , usd_volume
    , SUM(usd_volume) OVER (ORDER BY time RANGE UNBOUNDED PRECEDING) AS cumulative_usd_volume
    , usd_fees
    , SUM(usd_fees) OVER (ORDER BY time RANGE UNBOUNDED PRECEDING) AS cumulative_usd_fees
    FROM (SELECT date_trunc((SELECT a FROM aggregation), block_time) AS time
        , SUM(dt.usd_amount) AS usd_volume
        , SUM(dt.usd_amount*dpf.lp_fee_percentage/100) AS usd_fees
        FROM dex.trades dt
        LEFT JOIN dex_pool_fees dpf ON dt.block_time BETWEEN dpf.start_block_time AND dpf.end_block_time
        WHERE exchange_contract_address = (SELECT pc FROM pool_contract)
        AND dt.category='DEX'
        AND block_time >= '{{Since}}'
        GROUP BY time
        ) uncumulated
    )
    
, pooled_tokens_volume AS (
    SELECT t.time
    , SUM(SUM(amount_a/(SELECT token_a_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_a_amount
    , SUM(SUM(amount_b/(SELECT token_b_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_b_amount
    , MAX(price_token_a)*SUM(SUM(amount_a/(SELECT token_a_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_a_amount_usd
    , MAX(price_token_b)*SUM(SUM(amount_b/(SELECT token_b_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_b_amount_usd
    FROM (
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , SUM(value) AS amount_a
        , 0 AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""to"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_a FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , -SUM(value) AS amount_a
        , 0 AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""from"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_a FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , 0 AS amount_a
        , SUM(value) AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""to"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_b FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , 0 AS amount_a
        , -SUM(value) AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""from"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_b FROM pooled_tokens)
        GROUP BY 1
        ) t
    LEFT JOIN token_prices tp ON t.time=tp.time
    GROUP BY t.time
    )
    
, pool_yield AS (
    SELECT pv.time
    , pv.usd_fees/(ptv.token_a_amount_usd+ptv.token_b_amount_usd) AS pool_yield
    , SUM(SUM(pv.usd_fees/(ptv.token_a_amount_usd+ptv.token_b_amount_usd))) OVER (ORDER BY pv.time RANGE UNBOUNDED PRECEDING) AS cum_pool_yield
    FROM pool_volume pv
    LEFT JOIN pooled_tokens_volume ptv ON pv.time = ptv.time
    GROUP BY pv.time, pv.usd_fees,ptv.token_a_amount_usd,ptv.token_b_amount_usd
    )


SELECT tp.time AS ""Date""
, pv.usd_volume AS ""Trading Volume ($)""
, pv.usd_fees AS ""Generated Fees ($)""
, ptv.token_a_amount_usd+ptv.token_b_amount_usd AS ""TVL ($)""
, impermanent_loss AS ""Impermanent Loss %""
, py.pool_yield AS ""Pool Yield""
, py.pool_yield+impermanent_loss AS ""Net Pool Yield""
, py.cum_pool_yield+impermanent_loss_total AS ""Net Cumulated Pool Yield""
, AVG(POWER((1+py.pool_yield+impermanent_loss), 365)-1) OVER (ORDER BY tp.time ROWS BETWEEN 7 PRECEDING AND CURRENT ROW ) AS ""APY (1W MA)""
, AVG(POWER((1+py.pool_yield+impermanent_loss), 365)-1) OVER (ORDER BY tp.time ROWS BETWEEN 30 PRECEDING AND CURRENT ROW ) AS ""APY (1M MA)""
, AVG(POWER((1+py.pool_yield+impermanent_loss), 365)-1) OVER (ORDER BY tp.time ROWS BETWEEN 90 PRECEDING AND CURRENT ROW ) AS ""APY (3M MA)""
, ptv.token_a_amount AS ""Token A Amount""
, ptv.token_b_amount AS ""Token B Amount""
, ptv.token_a_amount_usd AS ""Token A TVL ($)""
, ptv.token_b_amount_usd AS ""Token B TVL ($)""
, tp.price_token_a AS ""Token A Price ($)""
, tp.price_token_b AS ""Token B Price ($)""
FROM token_prices tp
LEFT JOIN pool_volume pv ON tp.time = pv.time
LEFT JOIN pooled_tokens_volume ptv ON tp.time = ptv.time
LEFT JOIN impermanent_loss il ON tp.time=il.time
LEFT JOIN impermanent_loss_total ilt ON tp.time=ilt.time
LEFT JOIN pool_yield py ON tp.time = py.time
WHERE tp.time < date_trunc('day', NOW())
ORDER BY ""Date"" DESC"
477873,Pool Extra Info,,table,"WITH pool_contract AS (SELECT CASE WHEN LEFT('{{Pool}}', 1) = '\' THEN '{{Pool}}'::bytea 
    WHEN LEFT('{{Pool}}', 1) = '0' THEN ('\' || RIGHT('{{Pool}}', -1))::bytea
    END AS pc
    )

, tokens AS (
    SELECT CASE WHEN token_a_symbol > token_b_symbol THEN token_b_address::text ELSE token_a_address::text END AS token_a_address
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_address::text ELSE token_b_address::text END AS token_b_address
    , CASE WHEN token_a_symbol > token_b_symbol THEN erctb.decimals ELSE ercta.decimals END AS token_a_decimals
    , CASE WHEN token_a_symbol > token_b_symbol THEN ercta.decimals ELSE erctb.decimals END AS token_b_decimals
    , exchange_contract_address::text AS contract_address
    , project
    , CASE WHEN version IS NOT NULL THEN project || ' v' || version ELSE project END AS project_with_version
    FROM (SELECT * FROM dex.trades
    WHERE exchange_contract_address=(SELECT pc FROM pool_contract)
    AND category='DEX'
    LIMIT 1
    ) t
    LEFT JOIN erc20.""tokens"" ercta ON t.token_a_address=ercta.contract_address
    LEFT JOIN erc20.""tokens"" erctb ON t.token_b_address=erctb.contract_address
    GROUP BY exchange_contract_address, token_a_symbol, token_b_symbol, token_a_address, token_b_address, token_a_decimals, token_b_decimals, project, version
    )


SELECT 'Trade Here 👉' AS ""Column""
    , CASE WHEN project='Uniswap' THEN '<a href=""https://app.uniswap.org/#/swap?inputCurrency=0' || substring(token_a_address from 2) || '&outputCurrency=0' || substring(token_b_address from 2) ||'"" target=""_blank"" >On Uniswap</a>' 
    WHEN project='SushiSwap' THEN '<a href=""https://app.sushi.com/swap?inputCurrency=0' || substring(token_a_address from 2) || '&outputCurrency=0' || substring(token_b_address from 2) ||'"" target=""_blank"" >On Sushiswap</a>'
    WHEN project='Curve' THEN '<a href=""https://curve.fi/"" target=""_blank"" >On Curve</a>'
    WHEN project='Balancer' THEN '<a href=""https://app.balancer.fi/#/trade/ether/0' || substring(contract_address from 2) ||'"" target=""_blank"" >On Banlancer</a>'
    WHEN project IS NOT NULL THEN 'On ' || project_with_version
    ELSE '?' END AS ""Details""
FROM tokens
UNION ALL
    SELECT 'Pool Address' AS ""Column""
    , '<a href=""https://etherscan.io/address/0' || substring(contract_address from 2) || '"" target=""_blank"" >0' || substring(contract_address from 2) || '</a>' AS ""Details""
    FROM tokens
UNION ALL
    SELECT 'Token A Contract' AS ""Column""
    , '<a href=""https://etherscan.io/address/0' || substring(token_a_address from 2) || '"" target=""_blank"" >0' || substring(token_a_address from 2) || '</a>' AS ""Details""
    FROM tokens
UNION ALL
    SELECT 'Token A Decimals' AS ""Column""
    , token_a_decimals::text AS ""Details""
    FROM tokens
UNION ALL
    SELECT 'Token B Contract' AS ""Column""
    , '<a href=""https://etherscan.io/address/0' || substring(token_b_address from 2) || '"" target=""_blank"" >0' || substring(token_b_address from 2) || '</a>' AS ""Details""
    FROM tokens
UNION ALL
    SELECT 'Token B Decimals' AS ""Column""
    , token_b_decimals::text AS ""Details""
    FROM tokens
"
490645,Pooled Tokens,,table,"WITH pool_contract AS (SELECT CASE WHEN LEFT('{{Pool}}', 1) = '\' THEN '{{Pool}}'::bytea 
    WHEN LEFT('{{Pool}}', 1) = '0' THEN ('\' || RIGHT('{{Pool}}', -1))::bytea
    END AS pc
    )
    
, aggregation AS (SELECT CASE WHEN '{{Granularity}}'='Daily' THEN 'day'
    WHEN '{{Granularity}}'='Weekly' THEN 'week'
    WHEN '{{Granularity}}'='Monthly' THEN 'month'
    WHEN '{{Granularity}}'='Yearly' THEN 'year'
    END AS a
    )

, start_and_end_date AS (
    SELECT CASE WHEN dune_user_generated.is_date('{{Since}}')='true' AND '{{Since}}' < NOW() THEN '{{Since}}'::timestamp
        ELSE '2000-01-01'::timestamp END AS sd,
    CASE WHEN dune_user_generated.is_date('{{Until}}')='true' AND '{{Until}}' < NOW() THEN '{{Until}}'::timestamp
        ELSE NOW() END AS ed
    )

, uniswap_v1 AS (
    SELECT exchange AS contract_address
    , 'Uniswap v1' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap.""Factory_evt_NewExchange"")
    
, uniswap_v2 AS (
    SELECT pair AS contract_address
    , 'Uniswap v2' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v2.""Factory_evt_PairCreated""
    )
    
, uniswap_v3 AS (
    SELECT pool AS contract_address
    , 'Uniswap v3' AS project
    , fee/1e4 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v3.""Factory_evt_PoolCreated""
    )

, sushiswap AS (
    SELECT pair AS contract_address
    , 'SushiSwap' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM sushi.""Factory_evt_PairCreated""
    )

, curve AS (
    SELECT '\xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7'::bytea AS contract_address
        , 'Curve' AS project
        , 0.04 AS lp_fee_percentage
        , '2020-09-06 20:23'::timestamp AS block_time
        )

, dodo_v1 AS (
    SELECT ""dppAddress"" AS contract_address
    , 'DODO v1' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DPPFactory_call_initDODOPrivatePool"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v1' AS project
    , ""newLpFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DPP_evt_LpFeeRateChange""
    )
    
, dodo_dpp AS (
    SELECT ""output_newBornDODO"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DODOZoo_call_breedDODO"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v2' AS project
    , ""newLiquidityProviderFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DODO_evt_UpdateLiquidityProviderFeeRate""
    )
    
, dodo_dvm AS (
    SELECT ""output_newVendingMachine"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DVMFactory_call_createDODOVendingMachine"" WHERE call_success IS TRUE
    )
    
, dodo_dsp AS (
    SELECT ""output_newStablePool"" AS contract_address,
        'DODO v2' AS project,
        ""lpFeeRate""/1e16 AS lp_fee_percentage,
        call_block_time AS block_time 
    FROM dodo.""DSPFactory_call_createDODOStablePool"" WHERE call_success IS TRUE
    )

, balancer_v1 AS (
    SELECT contract_address
    , 'Balancer v1' AS project
    , ""swapFee""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time
    FROM balancer.""BPool_call_setSwapFee"" WHERE call_success = 'true'
    )
    
, balancer_v2 AS (
    SELECT contract_address
    , 'Balancer v2' AS project
    , ""swapFeePercentage""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM balancer_v2.""WeightedPool_evt_SwapFeePercentageChanged""
    )
 
, all_pools AS (SELECT * FROM (
    SELECT * FROM uniswap_v1
    UNION ALL
    SELECT * FROM uniswap_v2
    UNION ALL
    SELECT * FROM uniswap_v3
    UNION ALL
    SELECT * FROM sushiswap
    UNION ALL
    SELECT * FROM curve
    UNION ALL
    SELECT * FROM dodo_v1
    UNION ALL
    SELECT * FROM dodo_dpp
    UNION ALL
    SELECT * FROM dodo_dvm
    UNION ALL
    SELECT * FROM dodo_dsp
    UNION ALL
    SELECT * FROM balancer_v1
    UNION ALL
    SELECT * FROM balancer_v2) joined
    WHERE contract_address =  (SELECT pc FROM pool_contract)
    ) 
    
, dex_pool_fees AS (SELECT DISTINCT ON (start_lp.contract_address, start_lp.block_time) start_lp.contract_address AS contract_address
    , start_lp.project
    , start_lp.lp_fee_percentage
    , start_lp.block_time AS start_block_time
    , COALESCE(end_lp.block_time, '3000-01-01') AS end_block_time
    FROM (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) start_lp
    LEFT JOIN (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) end_lp
    ON start_lp.contract_address = end_lp.contract_address AND start_lp.block_time < end_lp.block_time
    )

, time_series AS (
    SELECT distinct date_trunc((SELECT a FROM aggregation) ,generate_series(date_trunc('day', minimum_date),  maximum_date, '1 day')) AS time
    FROM (
        SELECT CASE WHEN sd < (SELECT MIN(start_block_time) FROM dex_pool_fees) THEN (SELECT MIN(start_block_time) FROM dex_pool_fees)
        ELSE sd END AS minimum_date
        , ed AS maximum_date
        FROM start_and_end_date
    ) md
    )

, pooled_tokens AS (
    SELECT CASE WHEN token_a_symbol > token_b_symbol THEN token_b_address ELSE token_a_address END AS token_a
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_address ELSE token_b_address END AS token_b
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_b_symbol ELSE token_a_symbol END AS token_a_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_symbol ELSE token_b_symbol END AS token_b_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, erctb.decimals) ELSE POWER(10, ercta.decimals) END AS token_a_decimals
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, ercta.decimals) ELSE POWER(10, erctb.decimals) END AS token_b_decimals
    FROM dex.trades dt
    LEFT JOIN erc20.""tokens"" ercta ON dt.token_a_address=ercta.contract_address
    LEFT JOIN erc20.""tokens"" erctb ON dt.token_b_address=erctb.contract_address
    WHERE exchange_contract_address=(SELECT pc FROM pool_contract)
    LIMIT 1
    )

, token_prices AS (
    SELECT time
    , MAX(price_token_a) AS price_token_a
    , MAX(price_token_b) AS price_token_b
    FROM
        (SELECT ts.time
        , price AS price_token_a
        , NULL AS price_token_b
        FROM time_series ts
        LEFT JOIN prices.usd pu ON ts.time=pu.minute
        WHERE contract_address=(SELECT token_a FROM pooled_tokens)
        UNION
        SELECT ts.time
        , NULL AS price_token_a
        , price AS price_token_b
        FROM time_series ts
        LEFT JOIN prices.usd pu ON ts.time=pu.minute
        WHERE contract_address=(SELECT token_b FROM pooled_tokens)
        ) ungrouped
    GROUP BY time
    )

, pool_volume AS (SELECT time
    , usd_volume
    , SUM(usd_volume) OVER (ORDER BY time RANGE UNBOUNDED PRECEDING) AS cumulative_usd_volume
    , usd_fees
    , SUM(usd_fees) OVER (ORDER BY time RANGE UNBOUNDED PRECEDING) AS cumulative_usd_fees
    FROM (SELECT date_trunc((SELECT a FROM aggregation), block_time) AS time
        , SUM(dt.usd_amount) AS usd_volume
        , SUM(dt.usd_amount*dpf.lp_fee_percentage/10) AS usd_fees
        FROM dex.trades dt
        LEFT JOIN dex_pool_fees dpf ON dt.block_time BETWEEN dpf.start_block_time AND dpf.end_block_time
        WHERE exchange_contract_address = (SELECT pc FROM pool_contract)
        AND dt.category='DEX'
        AND block_time >= '{{Since}}'
        GROUP BY time
        ) uncumulated
    )
    

SELECT * 
FROM (SELECT t.time AS ""Date""
    , SUM(SUM(amount_a/(SELECT token_a_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS ""Token A Amount""
    , SUM(SUM(amount_b/(SELECT token_b_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS ""Token B Amount""
    , MAX(price_token_a)*SUM(SUM(amount_a/(SELECT token_a_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS ""Token A TVL (USD)""
    , MAX(price_token_b)*SUM(SUM(amount_b/(SELECT token_b_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS ""Token B TVL (USD)""
    FROM (
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , SUM(value) AS amount_a
        , 0 AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""to"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_a FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , -SUM(value) AS amount_a
        , 0 AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""from"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_a FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , 0 AS amount_a
        , SUM(value) AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""to"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_b FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , 0 AS amount_a
        , -SUM(value) AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""from"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_b FROM pooled_tokens)
        GROUP BY 1
        ) t
    LEFT JOIN token_prices tp ON t.time=tp.time
    GROUP BY t.time
    ) t2
WHERE ""Date"" >= (SELECT sd FROM start_and_end_date)
AND ""Date"" <= (SELECT ed FROM start_and_end_date)
AND ""Date"" < date_trunc('day', NOW())"
493903,All DEX Pools Trading the Same Tokens,During the Past Month,table,"WITH pool_contract AS (SELECT CASE WHEN LEFT('{{Pool}}', 1) = '\' THEN '{{Pool}}'::bytea 
    WHEN LEFT('{{Pool}}', 1) = '0' THEN ('\' || RIGHT('{{Pool}}', -1))::bytea
    END AS pc
    )
    
, tokens AS (
    SELECT CASE WHEN token_a_symbol > token_b_symbol THEN token_b_address ELSE token_a_address END AS token_a_address
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_address ELSE token_b_address END AS token_b_address
    FROM (SELECT * FROM dex.trades
    WHERE exchange_contract_address=(SELECT pc FROM pool_contract)
    AND category='DEX'
    LIMIT 1) t
    GROUP BY token_a_symbol, token_b_symbol, token_a_address, token_b_address
    )

 , ungrouped AS (
    SELECT CASE WHEN token_a_symbol < token_b_symbol THEN token_a_symbol || '-' || token_b_symbol
        ELSE token_b_symbol || '-' || token_a_symbol END AS pair
    , exchange_contract_address
    , CASE WHEN (version IS NOT NULL AND project NOT IN ('airswap', 'dYdX')) THEN project || ' v' || version
        WHEN project IN ('airswap', 'dYdX') THEN project || ' ' || version
        ELSE project END AS project
    , SUM(COALESCE(usd_amount,0)) AS volume
    FROM dex.""trades"" dt
    WHERE block_time >= NOW() - interval '1 month'
    AND category = 'DEX'
    AND project NOT IN ('0x API', '0x Native', '1inch', '1inch Limit Order Protocol')
    AND ((dt.token_a_address=(SELECT token_a_address FROM tokens) AND dt.token_b_address=(SELECT token_b_address FROM tokens))
        OR (dt.token_a_address=(SELECT token_b_address FROM tokens) AND dt.token_b_address=(SELECT token_a_address FROM tokens)))
    GROUP BY project, exchange_contract_address, token_a_symbol, token_b_symbol, version
    )


SELECT ROW_NUMBER() OVER (ORDER BY SUM(COALESCE(volume,0)) DESC) AS ""Rank""
, pair AS ""Pair""
, project AS ""Project""
, SUM(volume) AS ""USD Volume""
, '<a href=""https://etherscan.io/address/0' || substring(exchange_contract_address::text from 2) || '"" target=""_blank"" >0' || substring(exchange_contract_address::text from 2 for 5) || '...' || substring(exchange_contract_address::text from 39 for 4) || '</a>' AS ""Contract Address""
, '<a href=""https://dune.xyz/hildobby/DEX-Pool-Deep-Dive?Pool=0' || substring(exchange_contract_address::text from 2) || '"" target=""_blank"" >Dashboard Link</a>' AS ""Dune Analytics""
FROM ungrouped
GROUP BY project, exchange_contract_address, pair"
547659,Net Pool Yield APY,,chart,"WITH pool_contract AS (SELECT CASE WHEN LEFT('{{Pool}}', 1) = '\' THEN '{{Pool}}'::bytea 
    WHEN LEFT('{{Pool}}', 1) = '0' THEN ('\' || RIGHT('{{Pool}}', -1))::bytea
    END AS pc
    )
    
, aggregation AS (SELECT CASE WHEN '{{Granularity}}'='Daily' THEN 'day'
    WHEN '{{Granularity}}'='Weekly' THEN 'week'
    WHEN '{{Granularity}}'='Monthly' THEN 'month'
    WHEN '{{Granularity}}'='Yearly' THEN 'year'
    END AS a
    )

, start_and_end_date AS (
    SELECT CASE WHEN dune_user_generated.is_date('{{Since}}')='true' AND '{{Since}}' < NOW() THEN '{{Since}}'::timestamp
        ELSE '2000-01-01'::timestamp END AS sd,
    CASE WHEN dune_user_generated.is_date('{{Until}}')='true' AND '{{Until}}' < NOW() THEN '{{Until}}'::timestamp
        ELSE NOW() END AS ed
    )

, uniswap_v1 AS (
    SELECT exchange AS contract_address
    , 'Uniswap v1' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap.""Factory_evt_NewExchange"")
    
, uniswap_v2 AS (
    SELECT pair AS contract_address
    , 'Uniswap v2' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v2.""Factory_evt_PairCreated""
    )
    
, uniswap_v3 AS (
    SELECT pool AS contract_address
    , 'Uniswap v3' AS project
    , fee/1e4 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v3.""Factory_evt_PoolCreated""
    )

, sushiswap AS (
    SELECT pair AS contract_address
    , 'SushiSwap' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM sushi.""Factory_evt_PairCreated""
    )

, curve AS (
    SELECT '\xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7'::bytea AS contract_address
        , 'Curve' AS project
        , 0.04 AS lp_fee_percentage
        , '2020-09-06 20:23'::timestamp AS block_time
        )

, dodo_v1 AS (
    SELECT ""dppAddress"" AS contract_address
    , 'DODO v1' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DPPFactory_call_initDODOPrivatePool"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v1' AS project
    , ""newLpFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DPP_evt_LpFeeRateChange""
    )
    
, dodo_dpp AS (
    SELECT ""output_newBornDODO"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DODOZoo_call_breedDODO"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v2' AS project
    , ""newLiquidityProviderFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DODO_evt_UpdateLiquidityProviderFeeRate""
    )
    
, dodo_dvm AS (
    SELECT ""output_newVendingMachine"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DVMFactory_call_createDODOVendingMachine"" WHERE call_success IS TRUE
    )
    
, dodo_dsp AS (
    SELECT ""output_newStablePool"" AS contract_address,
        'DODO v2' AS project,
        ""lpFeeRate""/1e16 AS lp_fee_percentage,
        call_block_time AS block_time 
    FROM dodo.""DSPFactory_call_createDODOStablePool"" WHERE call_success IS TRUE
    )

, balancer_v1 AS (
    SELECT contract_address
    , 'Balancer v1' AS project
    , ""swapFee""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time
    FROM balancer.""BPool_call_setSwapFee"" WHERE call_success = 'true'
    )
    
, balancer_v2 AS (
    SELECT contract_address
    , 'Balancer v2' AS project
    , ""swapFeePercentage""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM balancer_v2.""WeightedPool_evt_SwapFeePercentageChanged""
    )
 
, all_pools AS (SELECT * FROM (
    SELECT * FROM uniswap_v1
    UNION ALL
    SELECT * FROM uniswap_v2
    UNION ALL
    SELECT * FROM uniswap_v3
    UNION ALL
    SELECT * FROM sushiswap
    UNION ALL
    SELECT * FROM curve
    UNION ALL
    SELECT * FROM dodo_v1
    UNION ALL
    SELECT * FROM dodo_dpp
    UNION ALL
    SELECT * FROM dodo_dvm
    UNION ALL
    SELECT * FROM dodo_dsp
    UNION ALL
    SELECT * FROM balancer_v1
    UNION ALL
    SELECT * FROM balancer_v2) joined
    WHERE contract_address =  (SELECT pc FROM pool_contract)
    ) 
    
, dex_pool_fees AS (SELECT DISTINCT ON (start_lp.contract_address, start_lp.block_time) start_lp.contract_address AS contract_address
    , start_lp.project
    , start_lp.lp_fee_percentage
    , start_lp.block_time AS start_block_time
    , COALESCE(end_lp.block_time, '3000-01-01') AS end_block_time
    FROM (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) start_lp
    LEFT JOIN (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) end_lp
    ON start_lp.contract_address = end_lp.contract_address AND start_lp.block_time < end_lp.block_time
    )

, time_series AS (
    SELECT distinct date_trunc((SELECT a FROM aggregation) ,generate_series(date_trunc('day', minimum_date),  maximum_date, '1 day')) AS time
    FROM (
        SELECT CASE WHEN sd < (SELECT MIN(start_block_time) FROM dex_pool_fees) THEN (SELECT MIN(start_block_time) FROM dex_pool_fees)
        ELSE sd END AS minimum_date
        , ed AS maximum_date
        FROM start_and_end_date
    ) md
    )

, pooled_tokens AS (
    SELECT CASE WHEN token_a_symbol > token_b_symbol THEN token_b_address ELSE token_a_address END AS token_a
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_address ELSE token_b_address END AS token_b
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_b_symbol ELSE token_a_symbol END AS token_a_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_symbol ELSE token_b_symbol END AS token_b_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, erctb.decimals) ELSE POWER(10, ercta.decimals) END AS token_a_decimals
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, ercta.decimals) ELSE POWER(10, erctb.decimals) END AS token_b_decimals
    FROM dex.trades dt
    LEFT JOIN erc20.""tokens"" ercta ON dt.token_a_address=ercta.contract_address
    LEFT JOIN erc20.""tokens"" erctb ON dt.token_b_address=erctb.contract_address
    WHERE exchange_contract_address=(SELECT pc FROM pool_contract)
    LIMIT 1
    )

, token_prices AS (
    SELECT time
    , MAX(price_token_a) AS price_token_a
    , MAX(price_token_b) AS price_token_b
    FROM
        (SELECT ts.time
        , price AS price_token_a
        , NULL AS price_token_b
        FROM time_series ts
        LEFT JOIN prices.usd pu ON ts.time=pu.minute
        WHERE contract_address=(SELECT token_a FROM pooled_tokens)
        UNION
        SELECT ts.time
        , NULL AS price_token_a
        , price AS price_token_b
        FROM time_series ts
        LEFT JOIN prices.usd pu ON ts.time=pu.minute
        WHERE contract_address=(SELECT token_b FROM pooled_tokens)
        ) ungrouped
    GROUP BY time
    )

, impermanent_loss_total AS (
    SELECT time
    , 2*sqrt(k)/(1+k)-1 AS impermanent_loss_total
    FROM (
        SELECT time,
        (SELECT price_token_a FROM token_prices ORDER BY time LIMIT 1)/price_token_a*
            (SELECT price_token_b FROM token_prices ORDER BY time LIMIT 1)/price_token_b AS k
        FROM token_prices
        ) k 
    )
        
, impermanent_loss AS (
    SELECT time
    , -ABS((2*sqrt(k)/(1+k)-1)-(2*sqrt(last_k)/(1+last_k)-1)) AS impermanent_loss
    FROM (
        SELECT time
        , (SELECT price_token_a FROM token_prices ORDER BY time LIMIT 1)/price_token_a*
            (SELECT price_token_b FROM token_prices ORDER BY time LIMIT 1)/price_token_b AS k
        , LAG((SELECT price_token_a FROM token_prices ORDER BY time LIMIT 1)/price_token_a*
            (SELECT price_token_b FROM token_prices ORDER BY time LIMIT 1)/price_token_b) OVER (ORDER BY time) AS last_k
        FROM token_prices
        ) k 
    )

, pool_volume AS (SELECT time
    , usd_volume
    , SUM(usd_volume) OVER (ORDER BY time RANGE UNBOUNDED PRECEDING) AS cumulative_usd_volume
    , usd_fees
    , SUM(usd_fees) OVER (ORDER BY time RANGE UNBOUNDED PRECEDING) AS cumulative_usd_fees
    FROM (SELECT date_trunc((SELECT a FROM aggregation), block_time) AS time
        , SUM(dt.usd_amount) AS usd_volume
        , SUM(dt.usd_amount*dpf.lp_fee_percentage/100) AS usd_fees
        FROM dex.trades dt
        LEFT JOIN dex_pool_fees dpf ON dt.block_time BETWEEN dpf.start_block_time AND dpf.end_block_time
        WHERE exchange_contract_address = (SELECT pc FROM pool_contract)
        AND dt.category='DEX'
        AND block_time >= '{{Since}}'
        GROUP BY time
        ) uncumulated
    )
    
    
, pooled_tokens_volume AS (
    SELECT t.time
    , SUM(SUM(amount_a/(SELECT token_a_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_a_amount
    , SUM(SUM(amount_b/(SELECT token_b_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_b_amount
    , MAX(price_token_a)*SUM(SUM(amount_a/(SELECT token_a_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_a_amount_usd
    , MAX(price_token_b)*SUM(SUM(amount_b/(SELECT token_b_decimals FROM pooled_tokens))) OVER(ORDER BY t.time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS token_b_amount_usd
    FROM (
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , SUM(value) AS amount_a
        , 0 AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""to"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_a FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , -SUM(value) AS amount_a
        , 0 AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""from"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_a FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , 0 AS amount_a
        , SUM(value) AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""to"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_b FROM pooled_tokens)
        GROUP BY 1
        UNION
        SELECT date_trunc((SELECT a FROM aggregation), evt_block_time) AS time
        , 0 AS amount_a
        , -SUM(value) AS amount_b
        FROM erc20.""ERC20_evt_Transfer""
        WHERE ""from"" = (SELECT pc FROM pool_contract)
        AND contract_address = (SELECT token_b FROM pooled_tokens)
        GROUP BY 1
        ) t
    LEFT JOIN token_prices tp ON t.time=tp.time
    GROUP BY t.time
    )
    
, pool_yield AS (
    SELECT pv.time
    , pv.usd_fees/(ptv.token_a_amount_usd+ptv.token_b_amount_usd) AS pool_yield
    , SUM(SUM(pv.usd_fees/(ptv.token_a_amount_usd+ptv.token_b_amount_usd))) OVER (ORDER BY pv.time RANGE UNBOUNDED PRECEDING) AS cum_pool_yield
    FROM pool_volume pv
    LEFT JOIN pooled_tokens_volume ptv ON pv.time = ptv.time
    GROUP BY pv.time, pv.usd_fees,ptv.token_a_amount_usd,ptv.token_b_amount_usd
    )


SELECT tp.time AS ""Date""
, AVG(POWER((1+py.pool_yield+impermanent_loss), 365)-1) OVER (ORDER BY tp.time ROWS BETWEEN 7 PRECEDING AND CURRENT ROW ) AS ""1W MA""
, AVG(POWER((1+py.pool_yield+impermanent_loss), 365)-1) OVER (ORDER BY tp.time ROWS BETWEEN 30 PRECEDING AND CURRENT ROW ) AS ""1M MA""
, AVG(POWER((1+py.pool_yield+impermanent_loss), 365)-1) OVER (ORDER BY tp.time ROWS BETWEEN 90 PRECEDING AND CURRENT ROW ) AS ""3M MA""
FROM token_prices tp
LEFT JOIN pool_yield py ON tp.time = py.time
LEFT JOIN impermanent_loss il ON tp.time=il.time
LEFT JOIN impermanent_loss_total ilt ON tp.time=ilt.time
WHERE tp.time < date_trunc('day', NOW())
AND tp.time > (SELECT MIN(time) FROM token_prices) + interval '7 days'"
490691,Pooled Token Prices,in $,table,"WITH pool_contract AS (SELECT CASE WHEN LEFT('{{Pool}}', 1) = '\' THEN '{{Pool}}'::bytea 
    WHEN LEFT('{{Pool}}', 1) = '0' THEN ('\' || RIGHT('{{Pool}}', -1))::bytea
    END AS pc
    )
    
, aggregation AS (SELECT CASE WHEN '{{Granularity}}'='Daily' THEN 'day'
    WHEN '{{Granularity}}'='Weekly' THEN 'week'
    WHEN '{{Granularity}}'='Monthly' THEN 'month'
    WHEN '{{Granularity}}'='Yearly' THEN 'year'
    END AS a
    )

, start_and_end_date AS (
    SELECT CASE WHEN dune_user_generated.is_date('{{Since}}')='true' AND '{{Since}}' < NOW() THEN '{{Since}}'::timestamp
        ELSE '2000-01-01'::timestamp END AS sd,
    CASE WHEN dune_user_generated.is_date('{{Until}}')='true' AND '{{Until}}' < NOW() THEN '{{Until}}'::timestamp
        ELSE NOW() END AS ed
    )

, uniswap_v1 AS (
    SELECT exchange AS contract_address
    , 'Uniswap v1' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap.""Factory_evt_NewExchange"")
    
, uniswap_v2 AS (
    SELECT pair AS contract_address
    , 'Uniswap v2' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v2.""Factory_evt_PairCreated""
    )
    
, uniswap_v3 AS (
    SELECT pool AS contract_address
    , 'Uniswap v3' AS project
    , fee/1e4 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM uniswap_v3.""Factory_evt_PoolCreated""
    )

, sushiswap AS (
    SELECT pair AS contract_address
    , 'SushiSwap' AS project
    , 0.3 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM sushi.""Factory_evt_PairCreated""
    )

, curve AS (
    SELECT '\xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7'::bytea AS contract_address
        , 'Curve' AS project
        , 0.04 AS lp_fee_percentage
        , '2020-09-06 20:23'::timestamp AS block_time
        )

, dodo_v1 AS (
    SELECT ""dppAddress"" AS contract_address
    , 'DODO v1' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DPPFactory_call_initDODOPrivatePool"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v1' AS project
    , ""newLpFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DPP_evt_LpFeeRateChange""
    )
    
, dodo_dpp AS (
    SELECT ""output_newBornDODO"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DODOZoo_call_breedDODO"" WHERE call_success IS TRUE    
    UNION
    SELECT contract_address
    , 'DODO v2' AS project
    , ""newLiquidityProviderFeeRate""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time 
    FROM  dodo.""DODO_evt_UpdateLiquidityProviderFeeRate""
    )
    
, dodo_dvm AS (
    SELECT ""output_newVendingMachine"" AS contract_address
    , 'DODO v2' AS project
    , ""lpFeeRate""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time 
    FROM dodo.""DVMFactory_call_createDODOVendingMachine"" WHERE call_success IS TRUE
    )
    
, dodo_dsp AS (
    SELECT ""output_newStablePool"" AS contract_address,
        'DODO v2' AS project,
        ""lpFeeRate""/1e16 AS lp_fee_percentage,
        call_block_time AS block_time 
    FROM dodo.""DSPFactory_call_createDODOStablePool"" WHERE call_success IS TRUE
    )

, balancer_v1 AS (
    SELECT contract_address
    , 'Balancer v1' AS project
    , ""swapFee""/1e16 AS lp_fee_percentage
    , call_block_time AS block_time
    FROM balancer.""BPool_call_setSwapFee"" WHERE call_success = 'true'
    )
    
, balancer_v2 AS (
    SELECT contract_address
    , 'Balancer v2' AS project
    , ""swapFeePercentage""/1e16 AS lp_fee_percentage
    , evt_block_time AS block_time
    FROM balancer_v2.""WeightedPool_evt_SwapFeePercentageChanged""
    )
 
, all_pools AS (SELECT * FROM (
    SELECT * FROM uniswap_v1
    UNION ALL
    SELECT * FROM uniswap_v2
    UNION ALL
    SELECT * FROM uniswap_v3
    UNION ALL
    SELECT * FROM sushiswap
    UNION ALL
    SELECT * FROM curve
    UNION ALL
    SELECT * FROM dodo_v1
    UNION ALL
    SELECT * FROM dodo_dpp
    UNION ALL
    SELECT * FROM dodo_dvm
    UNION ALL
    SELECT * FROM dodo_dsp
    UNION ALL
    SELECT * FROM balancer_v1
    UNION ALL
    SELECT * FROM balancer_v2) joined
    WHERE contract_address =  (SELECT pc FROM pool_contract)
    ) 
    
, dex_pool_fees AS (SELECT DISTINCT ON (start_lp.contract_address, start_lp.block_time) start_lp.contract_address AS contract_address
    , start_lp.project
    , start_lp.lp_fee_percentage
    , start_lp.block_time AS start_block_time
    , COALESCE(end_lp.block_time, '3000-01-01') AS end_block_time
    FROM (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) start_lp
    LEFT JOIN (
        SELECT * FROM all_pools ORDER BY ""contract_address"", block_time
        ) end_lp
    ON start_lp.contract_address = end_lp.contract_address AND start_lp.block_time < end_lp.block_time
    )

, time_series AS (
    SELECT distinct date_trunc((SELECT a FROM aggregation) ,generate_series(date_trunc('day', minimum_date),  maximum_date, '1 day')) AS time
    FROM (
        SELECT CASE WHEN sd < (SELECT MIN(start_block_time) FROM dex_pool_fees) THEN (SELECT MIN(start_block_time) FROM dex_pool_fees)
        ELSE sd END AS minimum_date
        , ed AS maximum_date
        FROM start_and_end_date
    ) md
    )

, pooled_tokens AS (
    SELECT CASE WHEN token_a_symbol > token_b_symbol THEN token_b_address ELSE token_a_address END AS token_a
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_address ELSE token_b_address END AS token_b
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_b_symbol ELSE token_a_symbol END AS token_a_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN token_a_symbol ELSE token_b_symbol END AS token_b_symbol
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, erctb.decimals) ELSE POWER(10, ercta.decimals) END AS token_a_decimals
    , CASE WHEN token_a_symbol > token_b_symbol THEN POWER(10, ercta.decimals) ELSE POWER(10, erctb.decimals) END AS token_b_decimals
    FROM dex.trades dt
    LEFT JOIN erc20.""tokens"" ercta ON dt.token_a_address=ercta.contract_address
    LEFT JOIN erc20.""tokens"" erctb ON dt.token_b_address=erctb.contract_address
    WHERE exchange_contract_address=(SELECT pc FROM pool_contract)
    LIMIT 1
    )


SELECT time AS ""Date""
, MAX(price_token_a) AS ""Token A Price""
, MAX(price_token_b) AS ""Token B Price""
FROM
    (SELECT ts.time
    , price AS price_token_a
    , NULL AS price_token_b
    FROM time_series ts
    LEFT JOIN prices.usd pu ON ts.time=pu.minute
    WHERE contract_address=(SELECT token_a FROM pooled_tokens)
    UNION
    SELECT ts.time
    , NULL AS price_token_a
    , price AS price_token_b
    FROM time_series ts
    LEFT JOIN prices.usd pu ON ts.time=pu.minute
    WHERE contract_address=(SELECT token_b FROM pooled_tokens)
    ) ungrouped
GROUP BY ""Date"""
82986,"Uniswap v3  Volume, Fees, TVL - Optimism by Pair x Day",,chart,"-- We keep Optimism in hourly throughout because we don't have prices in dex.trades
WITH dex_trades AS (
SELECT --pulled from eth dex_trades abstraction: https://github.com/duneanalytics/abstractions/blob/master/ethereum/dex/trades/insert_uniswap.sql
            t.evt_block_time AS block_time,
            'Uniswap' AS project,
            '3' AS version,
            'DEX' AS category,
            t.""recipient"" AS trader_a,
            NULL::bytea AS trader_b,
            abs(amount0) AS token_a_amount_raw,
            abs(amount1) AS token_b_amount_raw,
            NULL::numeric AS usd_amount,
            f.token0 AS token_a_address,
            f.token1 AS token_b_address,
            t.contract_address as exchange_contract_address,
            t.evt_tx_hash AS tx_hash,
            NULL::integer[] AS trace_address,
            t.evt_index
        FROM
            uniswap_v3.""Pair_evt_Swap"" t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" f ON f.pool = t.contract_address
)


,erc20_ERC20_evt_Transfer AS ( --h/t: https://ethereumdev.io/explore-ethereum-data-with-sql-queries-on-dune-analytics/
SELECT l.contract_address,
l.""tx_hash"" AS evt_tx_hash,
l.block_time AS evt_block_time,
substring(topic2, 13, 20)::bytea AS ""from"",
substring(topic3, 13, 20)::bytea AS ""to"",
bytea2numeric(data) AS value  FROM optimism.""logs"" l

INNER JOIN (SELECT DISTINCT pool FROM uniswap_v3.""Factory_evt_PoolCreated"") e
ON substring(topic3, 13, 20)::bytea = e.pool


WHERE ""topic1"" = '\xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef' --erc20transfer


UNION --some duplications if tx's are batching transfers between pools

SELECT l.contract_address,
l.""tx_hash"" AS evt_tx_hash,
l.block_time AS evt_block_time,
substring(topic2, 13, 20)::bytea AS ""from"",
substring(topic3, 13, 20)::bytea AS ""to"",
bytea2numeric(data) AS value  FROM optimism.""logs"" l

INNER JOIN (SELECT DISTINCT pool FROM uniswap_v3.""Factory_evt_PoolCreated"") e
ON substring(topic2, 13, 20)::bytea = e.pool


WHERE ""topic1"" = '\xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef' --erc20transfer

    
)

,gs AS (
    SELECT generate_series('2021-07-08'::TIMESTAMP, date_trunc('day', NOW()), '1 day') AS day
)
,gs_hr AS (
    SELECT generate_series('2021-07-08'::TIMESTAMP, date_trunc('hour', NOW()), '1 hour') AS hour
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
gs.hour,
token, symbol,
CASE WHEN symbol IN ('DAI','USDT','USDC') THEN 1
ELSE median_price
END AS median_price
FROM
(
SELECT *,
lead(hour, 1, now() ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour
FROM
(
SELECT
DATE_TRUNC('hour',block_time) AS hour,
token, symbol,
percentile_cont(0.5) WITHIN GROUP (ORDER BY token_price) AS median_price
FROM (
    SELECT *,
    usd_amount/token_amount AS token_price
    FROM
    (
        SELECT --tokena
        t.block_time, t.exchange_contract_address,
        ea.symbol,
        t.token_a_address AS token, --t.token_b_address,
        t.token_a_amount_raw/(10^ea.decimals) AS token_amount,
        --t.token_b_amount_raw/(10^eb.decimals) AS token_b_amount,
        CASE WHEN eb.symbol IN ('DAI','USDT','USDC') THEN --assume price = 1
            t.token_b_amount_raw/(10^eb.decimals) ELSE NULL
            END AS usd_amount
        /*t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_price--,
        --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_b_price*/
        FROM dex_trades t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
        t.""exchange_contract_address"" = p.pool
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea --both need to have known decimals, we're not going to assume anything.
        ON ea.""contract_address"" = t.token_a_address
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
        ON eb.""contract_address"" = t.token_b_address
        WHERE project = 'Uniswap' AND version = '3'
        AND t.block_time >= '2021-07-08'
        --AND 10^decimals > 0
        AND t.token_a_amount_raw > 100 --min to exclude weird stuff
        AND block_time > now() - interval '30 days'
    ) tokena
    
    UNION ALL
    
    SELECT *,
    usd_amount/token_amount AS token_price
    FROM
    (
        SELECT --tokenb
        t.block_time, t.exchange_contract_address,
        eb.symbol,
        --t.token_a_address,
        t.token_b_address AS token,
        --t.token_a_amount_raw/(10^ea.decimals) AS token_a_amount,
        t.token_b_amount_raw/(10^eb.decimals) AS token_amount,
        CASE WHEN ea.symbol IN ('DAI','USDT','USDC') THEN --assume price = 1
        t.token_a_amount_raw/(10^ea.decimals) ELSE NULL
        END AS usd_amount/*,
        --t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_a_price,
        --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_price*/
        FROM dex_trades t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
        t.""exchange_contract_address"" = p.pool
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea --both need to have known decimals, we're not going to assume anything.
        ON ea.""contract_address"" = t.token_a_address
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
        ON eb.""contract_address"" = t.token_b_address
        WHERE project = 'Uniswap' AND version = '3'
        AND t.block_time >= '2021-07-08'
        --AND 10^decimals > 0
        AND t.token_b_amount_raw > 100 --min to exclude weird stuff
        AND block_time > now() - interval '30 days'
    ) tokenb
) a
WHERE token_price > 0
GROUP BY 1,2,3

UNION ALL

SELECT
    '01-01-2000' AS dt, token::bytea, symbol, 1 AS median_price
    FROM ( values
            ('\x7f5c764cbc14f9669b88837ca1490cca17c31607','USDC')
            ,('\x94b008aa00579c1307b0ef2c499ad98a8ce58e58','USDT')
            ,('\xda10009cbd5d07dd0cecc66161fc93d7c9000da1','DAI')
        ) t (token, symbol)
) b
) c
INNER JOIN gs_hr gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour
)

,volume_and_fees AS ( --might not be pulling every trade?
SELECT
DATE_TRUNC('hour',""block_time"") AS hour,
--t.""token_a_address"",t.""token_a_amount_raw"",ea.symbol AS ""token_a_symbol"",--t.""token_a_symbol"",
--t.""token_b_address"",t.""token_b_amount_raw"",eb.symbol AS ""token_b_symbol"",--t.""token_b_symbol"",
""exchange_contract_address"",
a.fee,
SUM(COALESCE(""usd_amount"",
    (t.""token_a_amount_raw""/10^(ea.decimals))*pa.median_price,
    (t.""token_b_amount_raw""/10^(eb.decimals))*pb.median_price
    )) AS usd_volume,
SUM(COALESCE(""usd_amount"",
    (t.""token_a_amount_raw""/10^(ea.decimals))*pa.median_price,
    (t.""token_b_amount_raw""/10^(eb.decimals))*pb.median_price
    ))
    *(a.""fee""/1e6) AS usd_fees,
COUNT(*) AS num_trades
FROM dex_trades t
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
ON a.pool = t.""exchange_contract_address""
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea
    ON t.""token_a_address"" = ea.""contract_address""
    AND ""usd_amount"" IS NULL
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
    ON t.""token_b_address"" = eb.""contract_address""
    AND ea.""contract_address"" IS NULL
    AND ""usd_amount"" IS NULL
LEFT JOIN dex_price pa
    ON t.""token_a_address"" = pa.token
    AND ea.""contract_address"" = pa.token
    AND ""usd_amount"" IS NULL
    AND DATE_TRUNC('hour',""block_time"") = pa.hour
    AND pa.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
LEFT JOIN dex_price pb
    ON t.""token_b_address"" = pb.token
    AND ea.""contract_address"" IS NULL
    AND eb.""contract_address"" = pb.token
    AND ""usd_amount"" IS NULL
    AND DATE_TRUNC('hour',""block_time"") = pb.hour
    AND pb.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')

WHERE ""project"" = 'Uniswap' AND ""version"" = '3'
AND DATE_TRUNC('day',t.""block_time"") >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')

GROUP BY 1,2,3

HAVING COUNT(*) > 0

)



,lp_daily_token_balances AS(

SELECT 
gs.hour,pool,token,
running_balance,
(CASE WHEN gs.hour = e.hour THEN daily_change ELSE 0 END) AS daily_change
FROM
( SELECT *
    FROM
    (
    SELECT
    hour, pool, token, raw_value,
        lead(hour, 1, now() ) OVER (PARTITION BY pool, token
                            ORDER BY hour asc) AS next_hour,
        SUM(raw_value) --when there's a true change
            OVER (PARTITION BY pool, token ORDER BY hour ASC) AS running_balance,
        SUM(raw_value)
            OVER (PARTITION BY hour,pool, token) AS daily_change --did it this way to make group by's easier
    FROM
    (
    SELECT
    hour,
    exchange_contract_address AS pool, contract_address AS token,
    SUM(val) AS raw_value
    FROM (
         --get deposits into the lp pool
        SELECT 
        CASE WHEN DATE_TRUNC('hour',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('hour',e.""evt_block_time"")
            ELSE DATE_TRUNC('hour',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS hour,
        ""to"" AS exchange_contract_address,
        e.""contract_address"", SUM(value) AS val
        FROM erc20_ERC20_evt_Transfer e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""to"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens

        GROUP BY 1,2,3
        
        UNION ALL
        
        SELECT 
        CASE WHEN DATE_TRUNC('hour',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('hour',e.""evt_block_time"")
            ELSE DATE_TRUNC('hour',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS hour,
        ""from"" AS exchange_contract_address,
        e.""contract_address"", SUM(-value) AS val
        FROM erc20_ERC20_evt_Transfer e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""from"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens
        
        GROUP BY 1,2,3
        
        ) a
    GROUP BY 1,2,3
    ) b
    ) c
    WHERE c.next_hour >= DATE_TRUNC('day',NOW()) - interval '{{Trailing Num Days}} days'

) e
INNER JOIN gs_hr gs
ON e.hour <= gs.hour
AND gs.hour < e.next_hour

)


,lp_tvl AS( --calculate tvl
SELECT *,
DENSE_RANK() OVER (PARTITION BY DATE_TRUNC('day',hour) ORDER BY hour DESC) AS hrank --for getting eod tvl later
FROM (
SELECT a.hour, pool,

SUM(COALESCE(pb.median_price)*a.daily_change_raw/(10^COALESCE(e.decimals))) AS total_daily_change,
SUM(COALESCE(pb.median_price)*a.running_balance_raw/(10^COALESCE(e.decimals))) AS total_running_balance --# of tokens are in the LP
    
FROM (
    SELECT
    d.hour,
    d.pool,
    d.token,
    SUM(daily_change) AS daily_change_raw,
    SUM(running_balance) AS running_balance_raw
    FROM lp_daily_token_balances d
    
    WHERE d.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    GROUP BY 1,2,3
    
    ) a
    LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list e
    ON a.token = e.""contract_address""
    --AND p.price IS NULL
    LEFT JOIN dex_price pb
    ON a.token = pb.token
    AND e.""contract_address"" = pb.token
    --AND p.price IS NULL
    AND a.hour = pb.hour
    AND pb.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    
    WHERE a.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')

GROUP BY 1,2
) hourly_tvl
)

, net_liq AS
(
SELECT
hour,exchange_contract_address,
SUM(added_value_usd) AS total_liq_added, --also calling this liquidity volume
SUM(removed_value_usd) AS total_liq_removed,
SUM(net_value_usd) AS total_liq_net
FROM (
SELECT
a.hour, a.token, a.exchange_contract_address,
SUM(CASE WHEN value > 0 THEN value/(10^COALESCE(e.decimals)) ELSE 0 END) AS added_value_tokens,
SUM(CASE WHEN value < 0 THEN value/(10^COALESCE(e.decimals)) ELSE 0 END) AS removed_value_tokens,
SUM(value/(10^COALESCE(e.decimals))) AS net_value_tokens,

SUM(CASE WHEN value > 0 THEN COALESCE(pb.median_price)*(
    value/(10^COALESCE(e.decimals))
    ) ELSE 0 END) AS added_value_usd,
SUM(CASE WHEN value < 0 THEN COALESCE(pb.median_price)*(
    value/(10^COALESCE(e.decimals))
    )  ELSE 0 END) AS removed_value_usd,
SUM( COALESCE(pb.median_price)*(
    value/(10^COALESCE(e.decimals))
    ) ) AS net_value_usd

FROM
(
    SELECT --adds
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value,
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20_ERC20_evt_Transfer e
    INNER JOIN
    ( --get all liquidity event txs // couldn't find a way to connect tokenID to pool - data is missing...
          SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_IncreaseLiquidity""
        WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_DecreaseLiquidity""
        WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    ) l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""to""
    WHERE DATE_TRUNC('day',e.evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    
    UNION
    
    SELECT --removes
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value*(-1),
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20_ERC20_evt_Transfer e
    INNER JOIN
    ( --get all liquidity event txs // couldn't find a way to connect tokenID to pool - data is missing...
          SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_IncreaseLiquidity""
            WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_DecreaseLiquidity""
        WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    ) l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""from""
    WHERE DATE_TRUNC('day',e.evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
) a
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list e
    ON a.token = e.""contract_address""
    --AND p.price IS NULL
    LEFT JOIN dex_price pb
    ON a.token = pb.token
    AND e.""contract_address"" = pb.token
    --AND p.price IS NULL
    AND a.hour = pb.hour
    AND pb.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
GROUP BY 1,2,3
) d
GROUP BY 1,2

)



SELECT
--pair, fee_tier,
CASE WHEN daily_trade_rank <= 15 THEN pair--CONCAT(pair,' - ', ROUND(fee_tier*100,2)::text,'%')
ELSE 'Other'
END AS pair_other,
day, trailing_days,
SUM(volume) AS volume,
SUM(fees) AS fees,
SUM(trades) AS trades,
SUM(tvl) AS tvl,
SUM(fees)*365/SUM(tvl) AS fees_tvl_yr,
SUM(net_liq) AS net_liq

FROM (

SELECT
CONCAT(
COALESCE( (CASE WHEN ea.symbol ='WETH' THEN 'ETH' ELSE ea.symbol END)
            ,REPLACE(p.""token0""::text,'\','0') )
,'/',
COALESCE( (CASE WHEN eb.symbol ='WETH' THEN 'ETH' ELSE eb.symbol END)
            ,REPLACE(p.""token1""::text,'\','0') )
) AS pair,
--p.fee/1e6 AS fee_tier,
DATE_TRUNC('day',hour) AS day,
SUM(volume) AS volume,
SUM(fees) AS fees,
SUM(trades) AS trades,
SUM(CASE WHEN hrank = 1 THEN tvl ELSE 0 END) AS tvl,
--fees_tvl_yr,
SUM(net_liq) AS net_liq,
DENSE_RANK() OVER (ORDER BY DATE_TRUNC('day',hour) DESC) AS trailing_days,
DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('day',hour) ORDER BY SUM(volume) DESC NULLS LAST) AS daily_trade_rank

FROM (
    SELECT l.hour, l.pool, hrank,/*SUM(l.total_daily_change) AS daily_tvl_change,*/
    SUM(usd_volume) AS volume,
    SUM(usd_fees) AS fees,
    SUM(num_trades) AS trades,
    SUM(l.total_running_balance) AS tvl,
    (
        SUM(usd_fees)::decimal/SUM(l.total_running_balance)::decimal
    )*(365/*/{{Trailing Num Days}}::decimal*/) fees_tvl_yr,
    SUM(nl.total_liq_net) AS net_liq
    
    FROM lp_tvl l
    LEFT JOIN volume_and_fees vf
    ON vf.hour = l.hour
    AND vf.""exchange_contract_address"" = l.pool
    
    LEFT JOIN net_liq nl
    ON nl.hour = l.hour
    AND nl.exchange_contract_address = l.pool
    
    GROUP BY 1,2,3
    ORDER BY hour DESC
) a
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
    a.pool = p.pool
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea
    ON ea.""contract_address"" = p.""token0""
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
    ON eb.""contract_address"" = p.""token1""
    
GROUP BY 1,2
) b
GROUP BY 1,2,3

ORDER BY SUM(volume) DESC NULLS LAST"
82975,"Uniswap v3  Volume, Fees, TVL - Optimism",,table,"-- We keep Optimism in hourly throughout because we don't have prices in dex.trades
WITH dex_trades AS (
SELECT --pulled from eth dex_trades abstraction: https://github.com/duneanalytics/abstractions/blob/master/ethereum/dex/trades/insert_uniswap.sql
            t.evt_block_time AS block_time,
            'Uniswap' AS project,
            '3' AS version,
            'DEX' AS category,
            t.""recipient"" AS trader_a,
            NULL::bytea AS trader_b,
            abs(amount0) AS token_a_amount_raw,
            abs(amount1) AS token_b_amount_raw,
            NULL::numeric AS usd_amount,
            f.token0 AS token_a_address,
            f.token1 AS token_b_address,
            t.contract_address as exchange_contract_address,
            t.evt_tx_hash AS tx_hash,
            NULL::integer[] AS trace_address,
            t.evt_index
        FROM
            uniswap_v3.""Pair_evt_Swap"" t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" f ON f.pool = t.contract_address
)

,gs AS (
    SELECT generate_series('2021-07-08'::TIMESTAMP, date_trunc('day', NOW()), '1 day') AS day
)
,gs_hr AS (
    SELECT generate_series('2021-07-08'::TIMESTAMP, date_trunc('hour', NOW()), '1 hour') AS hour
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
gs.hour,
token, symbol,
CASE WHEN symbol IN ('DAI','USDT','USDC') THEN 1
ELSE median_price
END AS median_price
FROM
(
SELECT *,
lead(hour, 1, now() ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour
FROM
(
SELECT
DATE_TRUNC('hour',block_time) AS hour,
token, symbol,
percentile_cont(0.5) WITHIN GROUP (ORDER BY token_price) AS median_price
FROM (
    SELECT *,
    usd_amount/token_amount AS token_price
    FROM
    (
        SELECT --tokena
        t.block_time, t.exchange_contract_address,
        ea.symbol,
        t.token_a_address AS token, --t.token_b_address,
        t.token_a_amount_raw/(10^ea.decimals) AS token_amount,
        --t.token_b_amount_raw/(10^eb.decimals) AS token_b_amount,
        CASE WHEN eb.symbol IN ('DAI','USDT','USDC') THEN --assume price = 1
            t.token_b_amount_raw/(10^eb.decimals) ELSE NULL
            END AS usd_amount
        /*t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_price--,
        --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_b_price*/
        FROM dex_trades t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
        t.""exchange_contract_address"" = p.pool
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea --both need to have known decimals, we're not going to assume anything.
        ON ea.""contract_address"" = t.token_a_address
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
        ON eb.""contract_address"" = t.token_b_address
        WHERE project = 'Uniswap' AND version = '3'
        AND t.block_time >= '2021-07-08'
        --AND 10^decimals > 0
        AND t.token_a_amount_raw > 100 --min to exclude weird stuff
        AND block_time > now() - interval '{{Trailing Num Days}} days'
    ) tokena
    
    UNION ALL
    
    SELECT *,
    usd_amount/token_amount AS token_price
    FROM
    (
        SELECT --tokenb
        t.block_time, t.exchange_contract_address,
        eb.symbol,
        --t.token_a_address,
        t.token_b_address AS token,
        --t.token_a_amount_raw/(10^ea.decimals) AS token_a_amount,
        t.token_b_amount_raw/(10^eb.decimals) AS token_amount,
        CASE WHEN ea.symbol IN ('DAI','USDT','USDC') THEN --assume price = 1
        t.token_a_amount_raw/(10^ea.decimals) ELSE NULL
        END AS usd_amount/*,
        --t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_a_price,
        --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_price*/
        FROM dex_trades t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
        t.""exchange_contract_address"" = p.pool
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea --both need to have known decimals, we're not going to assume anything.
        ON ea.""contract_address"" = t.token_a_address
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
        ON eb.""contract_address"" = t.token_b_address
        WHERE project = 'Uniswap' AND version = '3'
        AND t.block_time >= '2021-07-08'
        --AND 10^decimals > 0
        AND t.token_b_amount_raw > 100 --min to exclude weird stuff
        AND block_time > now() - interval '{{Trailing Num Days}} days'
    ) tokenb
) a
WHERE token_price > 0
GROUP BY 1,2,3

UNION ALL

SELECT
    '01-01-2000' AS dt, token::bytea, symbol, 1 AS median_price
    FROM ( values
            ('\x7f5c764cbc14f9669b88837ca1490cca17c31607','USDC')
            ,('\x94b008aa00579c1307b0ef2c499ad98a8ce58e58','USDT')
            ,('\xda10009cbd5d07dd0cecc66161fc93d7c9000da1','DAI')
        ) t (token, symbol)
) b
) c
INNER JOIN gs_hr gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour
)

,volume_and_fees AS ( --might not be pulling every trade?
SELECT
DATE_TRUNC('hour',""block_time"") AS hour,
--t.""token_a_address"",t.""token_a_amount_raw"",ea.symbol AS ""token_a_symbol"",--t.""token_a_symbol"",
--t.""token_b_address"",t.""token_b_amount_raw"",eb.symbol AS ""token_b_symbol"",--t.""token_b_symbol"",
""exchange_contract_address"",
a.fee,
SUM(COALESCE(""usd_amount"",
    (t.""token_a_amount_raw""/10^(ea.decimals))*pa.median_price,
    (t.""token_b_amount_raw""/10^(eb.decimals))*pb.median_price
    )) AS usd_volume,
SUM(COALESCE(""usd_amount"",
    (t.""token_a_amount_raw""/10^(ea.decimals))*pa.median_price,
    (t.""token_b_amount_raw""/10^(eb.decimals))*pb.median_price
    ))
    *(a.""fee""/1e6) AS usd_fees,
COUNT(*) AS num_trades
FROM dex_trades t
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
ON a.pool = t.""exchange_contract_address""
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea
    ON t.""token_a_address"" = ea.""contract_address""
    AND ""usd_amount"" IS NULL
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
    ON t.""token_b_address"" = eb.""contract_address""
    AND ea.""contract_address"" IS NULL
    AND ""usd_amount"" IS NULL
LEFT JOIN dex_price pa
    ON t.""token_a_address"" = pa.token
    AND ea.""contract_address"" = pa.token
    AND ""usd_amount"" IS NULL
    AND DATE_TRUNC('hour',""block_time"") = pa.hour
    AND pa.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
LEFT JOIN dex_price pb
    ON t.""token_b_address"" = pb.token
    AND ea.""contract_address"" IS NULL
    AND eb.""contract_address"" = pb.token
    AND ""usd_amount"" IS NULL
    AND DATE_TRUNC('hour',""block_time"") = pb.hour
    AND pb.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')

WHERE ""project"" = 'Uniswap' AND ""version"" = '3'
AND date_trunc('day',t.""block_time"") >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')

GROUP BY 1,2,3

HAVING COUNT(*) > 0

)



,lp_daily_token_balances AS(

SELECT 
gs.hour,pool,token,
running_balance,
(CASE WHEN gs.hour = e.hour THEN daily_change ELSE 0 END) AS daily_change
FROM
( SELECT *
    FROM
    (
    SELECT
    hour, pool, token, raw_value,
        lead(hour, 1, now() ) OVER (PARTITION BY pool, token
                            ORDER BY hour asc) AS next_hour,
        SUM(raw_value) --when there's a true change
            OVER (PARTITION BY pool, token ORDER BY hour ASC) AS running_balance,
        SUM(raw_value)
            OVER (PARTITION BY hour,pool, token) AS daily_change --did it this way to make group by's easier
    FROM
    (
    SELECT
    hour,
    exchange_contract_address AS pool, contract_address AS token,
    SUM(val) AS raw_value
    FROM (
         --get deposits into the lp pool
        SELECT 
        CASE WHEN DATE_TRUNC('hour',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('hour',e.""evt_block_time"")
            ELSE DATE_TRUNC('hour',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS hour,
        ""to"" AS exchange_contract_address,
        e.""contract_address"", SUM(value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""to"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens

        GROUP BY 1,2,3
        
        UNION ALL
        
        SELECT 
        CASE WHEN DATE_TRUNC('hour',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('hour',e.""evt_block_time"")
            ELSE DATE_TRUNC('hour',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS hour,
        ""from"" AS exchange_contract_address,
        e.""contract_address"", SUM(-value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""from"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens
        
        GROUP BY 1,2,3
        
        ) a
    GROUP BY 1,2,3
    ) b
    ) c
    WHERE c.next_hour >= DATE_TRUNC('day',NOW()) - interval '{{Trailing Num Days}} days'

) e
INNER JOIN gs_hr gs
ON e.hour <= gs.hour
AND gs.hour < e.next_hour

)


,lp_tvl AS( --calculate tvl
SELECT *,
DENSE_RANK() OVER (PARTITION BY DATE_TRUNC('day',hour) ORDER BY hour DESC) AS hrank --for getting eod tvl later
FROM (
SELECT a.hour, pool,

SUM(COALESCE(pb.median_price)*a.daily_change_raw/(10^COALESCE(e.decimals))) AS total_daily_change,
SUM(COALESCE(pb.median_price)*a.running_balance_raw/(10^COALESCE(e.decimals))) AS total_running_balance --# of tokens are in the LP
    
FROM (
    SELECT
    d.hour,
    d.pool,
    d.token,
    SUM(daily_change) AS daily_change_raw,
    SUM(running_balance) AS running_balance_raw
    FROM lp_daily_token_balances d
    
    WHERE d.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    GROUP BY 1,2,3
    
    ) a
    LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list e
    ON a.token = e.""contract_address""
    --AND p.price IS NULL
    LEFT JOIN dex_price pb
    ON a.token = pb.token
    AND e.""contract_address"" = pb.token
    --AND p.price IS NULL
    AND a.hour = pb.hour
    AND pb.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    
    WHERE a.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')

GROUP BY 1,2
) hourly_tvl
)

, net_liq AS
(
SELECT
hour,exchange_contract_address,
SUM(added_value_usd) AS total_liq_added, --also calling this liquidity volume
SUM(removed_value_usd) AS total_liq_removed,
SUM(net_value_usd) AS total_liq_net
FROM (
SELECT
a.hour, a.token, a.exchange_contract_address,
SUM(CASE WHEN value > 0 THEN value/(10^COALESCE(e.decimals)) ELSE 0 END) AS added_value_tokens,
SUM(CASE WHEN value < 0 THEN value/(10^COALESCE(e.decimals)) ELSE 0 END) AS removed_value_tokens,
SUM(value/(10^COALESCE(e.decimals))) AS net_value_tokens,

SUM(CASE WHEN value > 0 THEN COALESCE(pb.median_price)*(
    value/(10^COALESCE(e.decimals))
    ) ELSE 0 END) AS added_value_usd,
SUM(CASE WHEN value < 0 THEN COALESCE(pb.median_price)*(
    value/(10^COALESCE(e.decimals))
    )  ELSE 0 END) AS removed_value_usd,
SUM( COALESCE(pb.median_price)*(
    value/(10^COALESCE(e.decimals))
    ) ) AS net_value_usd

FROM
(
    SELECT --adds
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value,
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN
    ( --get all liquidity event txs // couldn't find a way to connect tokenID to pool - data is missing...
          SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_IncreaseLiquidity""
        WHERE date_trunc('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION ALL SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE date_trunc('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION ALL SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_DecreaseLiquidity""
        WHERE date_trunc('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION ALL SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE date_trunc('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    ) l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""to""
    WHERE date_trunc('day',e.evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    
    UNION
    
    SELECT --removes
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value*(-1),
    date_trunc('day',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN
    ( --get all liquidity event txs // couldn't find a way to connect tokenID to pool - data is missing...
          SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_IncreaseLiquidity""
            WHERE date_trunc('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION ALL SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE date_trunc('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION ALL SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_DecreaseLiquidity""
        WHERE date_trunc('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION ALL SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE date_trunc('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    ) l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""from""
    WHERE date_trunc('day',e.evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
) a
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list e
    ON a.token = e.""contract_address""
    --AND p.price IS NULL
    LEFT JOIN dex_price pb
    ON a.token = pb.token
    AND e.""contract_address"" = pb.token
    --AND p.price IS NULL
    AND a.hour = pb.hour
    AND pb.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
GROUP BY 1,2,3
) d
GROUP BY 1,2

)


SELECT 
DATE_TRUNC('day',hour) AS day,
SUM(volume) AS volume,
SUM(fees) AS fees,
SUM(CASE WHEN hrank = 1 THEN tvl ELSE 0 END) AS tvl, --eod tvl
SUM(net_liq) AS net_liq,
SUM(fees_tvl_yr) AS fees_tvl_yr, SUM(trades) AS trades/*,
DENSE_RANK() OVER (ORDER BY day DESC) AS trailing_days*/
FROM (
    SELECT l.hour, hrank,--::date, --SUM(l.total_daily_change) AS daily_tvl_change,
    SUM(usd_volume) AS volume,
    SUM(usd_fees) AS fees,
   SUM(l.total_running_balance) AS tvl,
   SUM(nl.total_liq_net) AS net_liq,
    (
        SUM(usd_fees)::decimal/SUM(l.total_running_balance)::decimal
    )*(365) fees_tvl_yr,
    SUM(num_trades) AS trades
    
    FROM lp_tvl l
    LEFT JOIN volume_and_fees vf
    ON vf.hour = l.hour
    AND vf.""exchange_contract_address"" = l.pool
    LEFT JOIN net_liq nl
    ON nl.hour = l.hour
    AND nl.exchange_contract_address = l.pool
    GROUP BY 1,2

) a

GROUP BY 1
ORDER BY 1 DESC"
84042,"Uniswap v3  Volume, Fees, TVL - Ethereum by Pool x Day (liq)",,table,"-- Eth Data
WITH
gs AS (
    SELECT generate_series('2021-05-04'::TIMESTAMP, date_trunc('day', NOW()), '1 day') AS day
)
,gs_hr AS (
    SELECT generate_series('2021-05-04'::TIMESTAMP, date_trunc('hour', NOW()), '1 hour') AS hour
)

,prices AS (
SELECT
DATE_TRUNC('day',""minute"") AS day_group, dayrank,
DATE_TRUNC('hour',""minute"") AS hour,
""contract_address"",""decimals"",""price"",""symbol""
FROM
    (
    SELECT *,
    DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('hour',""minute""), ""contract_address"" ORDER BY ""minute"" DESC) AS mrank,
    DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('day',""minute""), ""contract_address"" ORDER BY ""minute"" DESC) AS dayrank
    FROM prices.""usd""
    WHERE
        ""minute"" >= DATE_TRUNC('day',now()) - interval '{{Trailing Num Days}} days'
        --AND NOT IN (SELECT contract_address FROM prices.usd p)
        AND ""contract_address"" IN (SELECT ""token0"" FROM uniswap_v3.""Factory_evt_PoolCreated""
                                    UNION ALL SELECT ""token1"" FROM uniswap_v3.""Factory_evt_PoolCreated"")
    ) a
WHERE mrank = 1
AND symbol
NOT IN (
    'SAITAMA'
        ) --exclude tokens that ruin volume/tvl/and everything
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
gs.hour,
token, symbol, median_price,
DATE_TRUNC('day',gs.hour) AS day_group,
DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('day',gs.hour), token ORDER BY gs.hour DESC) AS dayrank
FROM
(
SELECT *,
lead(hour, 1, now() ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour
FROM
(
SELECT
DATE_TRUNC('hour',block_time) AS hour,
token, symbol,
percentile_cont(0.5) WITHIN GROUP (ORDER BY token_price) AS median_price,
COUNT(*) AS num_samples
FROM (
    SELECT --tokena
    t.block_time, t.exchange_contract_address,
    ea.symbol,
    t.token_a_address AS token, --t.token_b_address,
    t.token_a_amount_raw/(10^ea.decimals) AS token_amount,
    --t.token_b_amount_raw/(10^eb.decimals) AS token_b_amount,
    t.usd_amount,
    t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_price--,
    --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_b_price
    FROM dex.trades t
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
    t.""exchange_contract_address"" = p.pool
    INNER JOIN erc20.""tokens"" ea --both need to have known decimals, we're not going to assume anything.
    ON ea.""contract_address"" = t.token_a_address
    --INNER JOIN erc20.""tokens"" eb
    --ON eb.""contract_address"" = t.token_b_address
    WHERE project = 'Uniswap' AND version = '3'
    AND t.block_time >= '2021-05-04'
    AND 10^decimals > 0
    AND t.token_a_amount_raw > 100 --min to exclude weird stuff
    AND t.block_time >= DATE_TRUNC('day',now()) - interval '{{Trailing Num Days}} days'
    AND usd_amount > 0
    
    UNION ALL
    
    SELECT --tokenb
    t.block_time, t.exchange_contract_address,
    eb.symbol,
    --t.token_a_address,
    t.token_b_address AS token,
    --t.token_a_amount_raw/(10^ea.decimals) AS token_a_amount,
    t.token_b_amount_raw/(10^eb.decimals) AS token_amount,
    t.usd_amount,
    --t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_a_price,
    t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_price
    FROM dex.trades t
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
    t.""exchange_contract_address"" = p.pool
    --INNER JOIN erc20.""tokens"" ea --both need to have known decimals, we're not going to assume anything.
    --ON ea.""contract_address"" = t.token_a_address
    INNER JOIN erc20.""tokens"" eb
    ON eb.""contract_address"" = t.token_b_address
    WHERE project = 'Uniswap' AND version = '3'
    AND t.block_time >= '2021-05-04'
    AND 10^decimals > 0
    AND t.token_b_amount_raw > 100 --min to exclude weird stuff
    AND t.block_time >= DATE_TRUNC('day',now()) - interval '{{Trailing Num Days}} days'
    AND usd_amount > 0
) a
WHERE token_price > 0
GROUP BY 1,2,3

HAVING COUNT(*) > 3 -- need more than 3 samples to take the price
) b
) c
INNER JOIN gs_hr gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour

WHERE symbol
NOT IN (
    'SAITAMA'
        ) --exclude tokens that ruin volume/tvl/and everything
)
/*
,dex_price AS (
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
DATE_TRUNC('day',gs.hour) AS day_group,
gs.hour,
token, median_price,
DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('day',gs.hour), token ORDER BY gs.hour DESC) AS dayrank
FROM
(
SELECT *,
lead(hour, 1, now() ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour
FROM
(
SELECT
DATE_TRUNC('hour',hour) AS hour,
token, median_price
FROM (
    SELECT ""hour"",""contract_address"" AS token,""median_price"", --DENSE_RANK() OVER (PARTITION BY DATE_TRUNC('day',hour) ORDER BY hour DESC) AS hrank
    FROM dex.""view_token_prices"" t
    
    WHERE
    hour >= DATE_TRUNC('day',now()) - interval '{{Trailing Num Days}} days' - interval '7 days' --buffer
    --AND NOT IN (SELECT contract_address FROM prices.usd p)
    AND ""contract_address"" IN (SELECT ""token0"" FROM uniswap_v3.""Factory_evt_PoolCreated""
                                UNION ALL SELECT ""token1"" FROM uniswap_v3.""Factory_evt_PoolCreated"")
    AND sample_size >=10
) a
WHERE median_price > 0
--AND hrank = 1

GROUP BY 1,2,3
) b
) c
INNER JOIN gs_hr gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour
)*/


,volume_and_fees AS (
SELECT
DATE_TRUNC('day',""block_time"") AS day,
--t.""token_a_address"",t.""token_a_amount_raw"",t.""token_a_symbol"",
--t.""token_b_address"",t.""token_b_amount_raw"",t.""token_b_symbol"",
""exchange_contract_address"",
a.fee,
SUM(""usd_amount"") AS usd_volume,
SUM(""usd_amount"")
    *(a.""fee""/1e6) AS usd_fees,
COUNT(*) AS num_trades
FROM dex.trades t
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
ON a.pool = t.""exchange_contract_address""
LEFT JOIN erc20.""tokens"" ea
    ON t.""token_a_address"" = ea.""contract_address""
    AND ""usd_amount"" IS NULL
LEFT JOIN erc20.""tokens"" eb
    ON t.""token_b_address"" = eb.""contract_address""
    AND ea.""contract_address"" IS NULL
    AND ""usd_amount"" IS NULL

WHERE ""project"" = 'Uniswap' AND ""version"" = '3'
AND DATE_TRUNC('day',t.""block_time"") >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
AND t.exchange_contract_address IN (SELECT pool FROM uniswap_v3.""Factory_evt_PoolCreated"")
    
    

GROUP BY 1,2,3

HAVING SUM(""usd_amount"") > 0

)

,lp_daily_token_balances AS( --daily

SELECT 
gs.day,pool,token,
running_balance,
(CASE WHEN gs.day = e.day THEN daily_change ELSE 0 END) AS daily_change
FROM
( SELECT *
    FROM
    (
    SELECT
    day, pool, token, raw_value,
        lead(day, 1, now() ) OVER (PARTITION BY pool, token
                            ORDER BY day asc) AS next_day,
        SUM(raw_value) --when there's a true change
            OVER (PARTITION BY pool, token ORDER BY day ASC) AS running_balance,
        SUM(raw_value)
            OVER (PARTITION BY day,pool, token) AS daily_change --did it this way to make group by's easier
    FROM
    (
    SELECT
    day,
    exchange_contract_address AS pool, contract_address AS token,
    SUM(val) AS raw_value
    FROM (
         --get deposits into the lp pool
        SELECT 
        CASE WHEN DATE_TRUNC('day',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('day',e.""evt_block_time"")
            ELSE DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS day,
        ""to"" AS exchange_contract_address,
        e.""contract_address"", SUM(value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""to"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens

        GROUP BY 1,2,3
        
        UNION ALL
        
        SELECT 
        CASE WHEN DATE_TRUNC('day',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('day',e.""evt_block_time"")
            ELSE DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS day,
        ""from"" AS exchange_contract_address,
        e.""contract_address"", SUM(-value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""from"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens
        
        GROUP BY 1,2,3
        
        ) a
    GROUP BY 1,2,3
    ) b
    ) c
    WHERE c.next_day >= DATE_TRUNC('day',NOW()) - interval '{{Trailing Num Days}} days'

) e
INNER JOIN gs
ON e.day <= gs.day
AND gs.day < e.next_day

)


,lp_tvl AS( --calculate tvl --daily

SELECT a.day, pool,

SUM(COALESCE(p.price, pb.median_price)*COALESCE(a.daily_change_raw,0)/(10^COALESCE(e.decimals,p.decimals))) AS total_daily_change,
SUM(COALESCE(p.price, pb.median_price)*COALESCE(a.running_balance_raw,0)/(10^COALESCE(e.decimals,p.decimals))) AS total_running_balance --# of tokens are in the LP
    
    
FROM ( -- maybe chunk this out where prices come in later
    SELECT
    d.day,
    d.pool,
    d.token,
    SUM(daily_change) AS daily_change_raw,
    SUM(running_balance) AS running_balance_raw
    FROM lp_daily_token_balances d
    
    WHERE d.day >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    GROUP BY 1,2,3
    
    ) a
    LEFT JOIN (SELECT * FROM prices WHERE dayrank = 1) p
    ON a.token = p.""contract_address""
    AND a.day = p.day_group
    
    LEFT JOIN erc20.""tokens"" e
    ON a.token = e.""contract_address""
    AND p.price IS NULL
    
    LEFT JOIN (SELECT * FROM dex_price WHERE dayrank = 1) pb
    ON a.token = pb.token
    AND p.price IS NULL
    AND a.day = pb.day_group

GROUP BY 1,2
)


, net_liq AS --hourly then agg
(
SELECT
DATE_TRUNC('day',hour) AS day,exchange_contract_address,
SUM(added_value_usd) AS total_liq_added, --also calling this liquidity volume
SUM(removed_value_usd) AS total_liq_removed,
SUM(net_value_usd) AS total_liq_net
FROM (
SELECT
a.hour, a.token, a.exchange_contract_address,
SUM(CASE WHEN value > 0 THEN value/(10^COALESCE(e.decimals,p.decimals)) ELSE 0 END) AS added_value_tokens,
SUM(CASE WHEN value < 0 THEN value/(10^COALESCE(e.decimals,p.decimals)) ELSE 0 END) AS removed_value_tokens,
SUM(value/(10^COALESCE(e.decimals,p.decimals))) AS net_value_tokens,

SUM(CASE WHEN value > 0 THEN COALESCE(p.price,pb.median_price)*(
    value/(10^COALESCE(e.decimals,p.decimals))
    ) ELSE 0 END) AS added_value_usd,
SUM(CASE WHEN value < 0 THEN COALESCE(p.price,pb.median_price)*(
    value/(10^COALESCE(e.decimals,p.decimals))
    )  ELSE 0 END) AS removed_value_usd,
SUM( COALESCE(p.price,pb.median_price)*(
    value/(10^COALESCE(e.decimals,p.decimals))
    ) ) AS net_value_usd

FROM
(
    SELECT --adds
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value,
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN
    ( --get all liquidity event txs // couldn't find a way to connect tokenID to pool - data is missing...
          SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_IncreaseLiquidity""
          WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_DecreaseLiquidity""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    ) l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""to""
    WHERE e.evt_block_time >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    
    UNION ALL
    
    SELECT --removes
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value*(-1),
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN
    ( --get all liquidity event txs // couldn't find a way to connect tokenID to pool - data is missing...
          SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_IncreaseLiquidity""
            WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_DecreaseLiquidity""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    ) l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""from""
    WHERE e.evt_block_time >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
) a
LEFT JOIN prices p
    ON a.token = p.""contract_address""
    AND
    p.hour = a.hour
LEFT JOIN erc20.""tokens"" e
    ON a.token = e.""contract_address""
    AND p.price IS NULL
LEFT JOIN dex_price pb
    ON a.token = pb.token
    AND e.""contract_address"" = pb.token
    AND p.price IS NULL
    AND a.hour = pb.hour
GROUP BY 1,2,3
) d
GROUP BY 1,2

)

SELECT
--pair, fee_tier,CONCAT(pair,' - ', ROUND(fee_tier*100,2)::text,'%') AS pool_n,
CASE WHEN daily_trade_rank <= 15 THEN CONCAT(pair,' - ', ROUND(fee_tier*100,2)::text,'%')
ELSE 'Other'
END AS pair_other,
day, trailing_days,
SUM(volume) AS volume,
SUM(fees) AS fees,
SUM(trades) AS trades,
SUM(tvl) AS tvl,
SUM(net_liq) AS net_liq,
SUM(added_liq) AS added_liq,
SUM(fees)*365/SUM(tvl) AS fees_tvl_yr

FROM (

SELECT
CONCAT(
COALESCE( (CASE WHEN ea.symbol ='WETH' THEN 'ETH' ELSE ea.symbol END)
            ,REPLACE(p.""token0""::text,'\','0') )
,'/',
COALESCE( (CASE WHEN eb.symbol ='WETH' THEN 'ETH' ELSE eb.symbol END)
            ,REPLACE(p.""token1""::text,'\','0') )
) AS pair,
p.fee/1e6 AS fee_tier,
day,
volume,
fees,
trades,
tvl,
fees_tvl_yr,
net_liq,
added_liq,
DENSE_RANK() OVER (ORDER BY day DESC) AS trailing_days,
DENSE_RANK() OVER(PARTITION BY day ORDER BY ABS(net_liq) DESC NULLS LAST) AS daily_trade_rank

FROM (
    SELECT l.day, l.pool, /*SUM(l.total_daily_change) AS daily_tvl_change,*/
    SUM(usd_volume) AS volume,
    SUM(usd_fees) AS fees,
    SUM(num_trades) AS trades,
    SUM(l.total_running_balance) AS tvl,
    (
        SUM(usd_fees)::decimal/SUM(l.total_running_balance)::decimal
    )*(365/*/{{Trailing Num Days}}::decimal*/) fees_tvl_yr,
    SUM(nl.total_liq_net) AS net_liq,
    SUM(total_liq_added) AS added_liq
    
    FROM lp_tvl l
    LEFT JOIN volume_and_fees vf
    ON vf.day = l.day
    AND vf.""exchange_contract_address"" = l.pool
    
    LEFT JOIN net_liq nl
    ON nl.day = l.day
    AND nl.exchange_contract_address = l.pool
    
    GROUP BY 1,2
    ORDER BY day DESC
) a
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
    a.pool = p.pool
LEFT JOIN erc20.""tokens"" ea
    ON ea.""contract_address"" = p.""token0""
LEFT JOIN erc20.""tokens"" eb
    ON eb.""contract_address"" = p.""token1""
) b
GROUP BY 1,2,3
--,4,5,6

ORDER BY day DESC, SUM(volume) DESC NULLS LAST"
84043,"Uniswap v3  Volume, Fees, TVL - Optimism by Pool x Day (liq)",,chart,"-- We keep Optimism in hourly throughout because we don't have prices in dex.trades
WITH dex_trades AS (
SELECT --pulled from eth dex_trades abstraction: https://github.com/duneanalytics/abstractions/blob/master/ethereum/dex/trades/insert_uniswap.sql
            t.evt_block_time AS block_time,
            'Uniswap' AS project,
            '3' AS version,
            'DEX' AS category,
            t.""recipient"" AS trader_a,
            NULL::bytea AS trader_b,
            abs(amount0) AS token_a_amount_raw,
            abs(amount1) AS token_b_amount_raw,
            NULL::numeric AS usd_amount,
            f.token0 AS token_a_address,
            f.token1 AS token_b_address,
            t.contract_address as exchange_contract_address,
            t.evt_tx_hash AS tx_hash,
            NULL::integer[] AS trace_address,
            t.evt_index
        FROM
            uniswap_v3.""Pair_evt_Swap"" t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" f ON f.pool = t.contract_address
)


,erc20_ERC20_evt_Transfer AS ( --h/t: https://ethereumdev.io/explore-ethereum-data-with-sql-queries-on-dune-analytics/
SELECT l.contract_address,
l.""tx_hash"" AS evt_tx_hash,
l.block_time AS evt_block_time,
substring(topic2, 13, 20)::bytea AS ""from"",
substring(topic3, 13, 20)::bytea AS ""to"",
bytea2numeric(data) AS value  FROM optimism.""logs"" l

INNER JOIN (SELECT DISTINCT pool FROM uniswap_v3.""Factory_evt_PoolCreated"") e
ON substring(topic3, 13, 20)::bytea = e.pool


WHERE ""topic1"" = '\xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef' --erc20transfer


UNION --some duplications if tx's are batching transfers between pools

SELECT l.contract_address,
l.""tx_hash"" AS evt_tx_hash,
l.block_time AS evt_block_time,
substring(topic2, 13, 20)::bytea AS ""from"",
substring(topic3, 13, 20)::bytea AS ""to"",
bytea2numeric(data) AS value  FROM optimism.""logs"" l

INNER JOIN (SELECT DISTINCT pool FROM uniswap_v3.""Factory_evt_PoolCreated"") e
ON substring(topic2, 13, 20)::bytea = e.pool


WHERE ""topic1"" = '\xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef' --erc20transfer

    
)

,gs AS (
    SELECT generate_series('2021-07-08'::TIMESTAMP, date_trunc('day', NOW()), '1 day') AS day
)
,gs_hr AS (
    SELECT generate_series('2021-07-08'::TIMESTAMP, date_trunc('hour', NOW()), '1 hour') AS hour
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
gs.hour,
token, symbol,
CASE WHEN symbol IN ('DAI','USDT','USDC') THEN 1
ELSE median_price
END AS median_price
FROM
(
SELECT *,
lead(hour, 1, now() ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour
FROM
(
SELECT
DATE_TRUNC('hour',block_time) AS hour,
token, symbol,
percentile_cont(0.5) WITHIN GROUP (ORDER BY token_price) AS median_price
FROM (
    SELECT *,
    usd_amount/token_amount AS token_price
    FROM
    (
        SELECT --tokena
        t.block_time, t.exchange_contract_address,
        ea.symbol,
        t.token_a_address AS token, --t.token_b_address,
        t.token_a_amount_raw/(10^ea.decimals) AS token_amount,
        --t.token_b_amount_raw/(10^eb.decimals) AS token_b_amount,
        CASE WHEN eb.symbol IN ('DAI','USDT','USDC') THEN --assume price = 1
            t.token_b_amount_raw/(10^eb.decimals) ELSE NULL
            END AS usd_amount
        /*t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_price--,
        --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_b_price*/
        FROM dex_trades t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
        t.""exchange_contract_address"" = p.pool
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea --both need to have known decimals, we're not going to assume anything.
        ON ea.""contract_address"" = t.token_a_address
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
        ON eb.""contract_address"" = t.token_b_address
        WHERE project = 'Uniswap' AND version = '3'
        AND t.block_time >= '2021-07-08'
        --AND 10^decimals > 0
        AND t.token_a_amount_raw > 100 --min to exclude weird stuff
        AND block_time > now() - interval '{{Trailing Num Days}} days'
    ) tokena
    
    UNION ALL
    
    SELECT *,
    usd_amount/token_amount AS token_price
    FROM
    (
        SELECT --tokenb
        t.block_time, t.exchange_contract_address,
        eb.symbol,
        --t.token_a_address,
        t.token_b_address AS token,
        --t.token_a_amount_raw/(10^ea.decimals) AS token_a_amount,
        t.token_b_amount_raw/(10^eb.decimals) AS token_amount,
        CASE WHEN ea.symbol IN ('DAI','USDT','USDC') THEN --assume price = 1
        t.token_a_amount_raw/(10^ea.decimals) ELSE NULL
        END AS usd_amount/*,
        --t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_a_price,
        --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_price*/
        FROM dex_trades t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
        t.""exchange_contract_address"" = p.pool
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea --both need to have known decimals, we're not going to assume anything.
        ON ea.""contract_address"" = t.token_a_address
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
        ON eb.""contract_address"" = t.token_b_address
        WHERE project = 'Uniswap' AND version = '3'
        AND t.block_time >= '2021-07-08'
        --AND 10^decimals > 0
        AND t.token_b_amount_raw > 100 --min to exclude weird stuff
        AND block_time > now() - interval '{{Trailing Num Days}} days'
    ) tokenb
) a
WHERE token_price > 0
GROUP BY 1,2,3

UNION ALL

SELECT
    '01-01-2000' AS dt, token::bytea, symbol, 1 AS median_price
    FROM ( values
            ('\x7f5c764cbc14f9669b88837ca1490cca17c31607','USDC')
            ,('\x94b008aa00579c1307b0ef2c499ad98a8ce58e58','USDT')
            ,('\xda10009cbd5d07dd0cecc66161fc93d7c9000da1','DAI')
        ) t (token, symbol)
) b
) c
INNER JOIN gs_hr gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour
)

,volume_and_fees AS ( --might not be pulling every trade?
SELECT
DATE_TRUNC('hour',""block_time"") AS hour,
--t.""token_a_address"",t.""token_a_amount_raw"",ea.symbol AS ""token_a_symbol"",--t.""token_a_symbol"",
--t.""token_b_address"",t.""token_b_amount_raw"",eb.symbol AS ""token_b_symbol"",--t.""token_b_symbol"",
""exchange_contract_address"",
a.fee,
SUM(COALESCE(""usd_amount"",
    (t.""token_a_amount_raw""/10^(ea.decimals))*pa.median_price,
    (t.""token_b_amount_raw""/10^(eb.decimals))*pb.median_price
    )) AS usd_volume,
SUM(COALESCE(""usd_amount"",
    (t.""token_a_amount_raw""/10^(ea.decimals))*pa.median_price,
    (t.""token_b_amount_raw""/10^(eb.decimals))*pb.median_price
    ))
    *(a.""fee""/1e6) AS usd_fees,
COUNT(*) AS num_trades
FROM dex_trades t
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
ON a.pool = t.""exchange_contract_address""
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea
    ON t.""token_a_address"" = ea.""contract_address""
    AND ""usd_amount"" IS NULL
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
    ON t.""token_b_address"" = eb.""contract_address""
    AND ea.""contract_address"" IS NULL
    AND ""usd_amount"" IS NULL
LEFT JOIN dex_price pa
    ON t.""token_a_address"" = pa.token
    AND ea.""contract_address"" = pa.token
    AND ""usd_amount"" IS NULL
    AND DATE_TRUNC('hour',""block_time"") = pa.hour
    AND pa.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
LEFT JOIN dex_price pb
    ON t.""token_b_address"" = pb.token
    AND ea.""contract_address"" IS NULL
    AND eb.""contract_address"" = pb.token
    AND ""usd_amount"" IS NULL
    AND DATE_TRUNC('hour',""block_time"") = pb.hour
    AND pb.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')

WHERE ""project"" = 'Uniswap' AND ""version"" = '3'
AND DATE_TRUNC('day',t.""block_time"") >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')

GROUP BY 1,2,3

HAVING COUNT(*) > 0

)



,lp_daily_token_balances AS(

SELECT 
gs.hour,pool,token,
running_balance,
(CASE WHEN gs.hour = e.hour THEN daily_change ELSE 0 END) AS daily_change
FROM
( SELECT *
    FROM
    (
    SELECT
    hour, pool, token, raw_value,
        lead(hour, 1, now() ) OVER (PARTITION BY pool, token
                            ORDER BY hour asc) AS next_hour,
        SUM(raw_value) --when there's a true change
            OVER (PARTITION BY pool, token ORDER BY hour ASC) AS running_balance,
        SUM(raw_value)
            OVER (PARTITION BY hour,pool, token) AS daily_change --did it this way to make group by's easier
    FROM
    (
    SELECT
    hour,
    exchange_contract_address AS pool, contract_address AS token,
    SUM(val) AS raw_value
    FROM (
         --get deposits into the lp pool
        SELECT 
        CASE WHEN DATE_TRUNC('hour',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('hour',e.""evt_block_time"")
            ELSE DATE_TRUNC('hour',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS hour,
        ""to"" AS exchange_contract_address,
        e.""contract_address"", SUM(value) AS val
        FROM erc20_ERC20_evt_Transfer e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""to"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens

        GROUP BY 1,2,3
        
        UNION ALL
        
        SELECT 
        CASE WHEN DATE_TRUNC('hour',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('hour',e.""evt_block_time"")
            ELSE DATE_TRUNC('hour',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS hour,
        ""from"" AS exchange_contract_address,
        e.""contract_address"", SUM(-value) AS val
        FROM erc20_ERC20_evt_Transfer e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""from"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens
        
        GROUP BY 1,2,3
        
        ) a
    GROUP BY 1,2,3
    ) b
    ) c
    WHERE c.next_hour >= DATE_TRUNC('day',NOW()) - interval '{{Trailing Num Days}} days'

) e
INNER JOIN gs_hr gs
ON e.hour <= gs.hour
AND gs.hour < e.next_hour

)


,lp_tvl AS( --calculate tvl
SELECT *,
DENSE_RANK() OVER (PARTITION BY DATE_TRUNC('day',hour) ORDER BY hour DESC) AS hrank --for getting eod tvl later
FROM (
SELECT a.hour, pool,

SUM(COALESCE(pb.median_price)*a.daily_change_raw/(10^COALESCE(e.decimals))) AS total_daily_change,
SUM(COALESCE(pb.median_price)*a.running_balance_raw/(10^COALESCE(e.decimals))) AS total_running_balance --# of tokens are in the LP
    
FROM (
    SELECT
    d.hour,
    d.pool,
    d.token,
    SUM(daily_change) AS daily_change_raw,
    SUM(running_balance) AS running_balance_raw
    FROM lp_daily_token_balances d
    
    WHERE d.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    GROUP BY 1,2,3
    
    ) a
    LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list e
    ON a.token = e.""contract_address""
    --AND p.price IS NULL
    LEFT JOIN dex_price pb
    ON a.token = pb.token
    AND e.""contract_address"" = pb.token
    --AND p.price IS NULL
    AND a.hour = pb.hour
    AND pb.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    
    WHERE a.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')

GROUP BY 1,2
) hourly_tvl
)

,lp_events AS (
SELECT evt_tx_hash FROM
        (
        SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_IncreaseLiquidity""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION ALL SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION ALL SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_DecreaseLiquidity""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION ALL SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
        ) e
GROUP BY 1 --distinct
)

, net_liq AS
(
SELECT
hour,exchange_contract_address,
SUM(added_value_usd) AS total_liq_added, --also calling this liquidity volume
SUM(removed_value_usd) AS total_liq_removed,
SUM(net_value_usd) AS total_liq_net
FROM (
SELECT
a.hour, a.token, a.exchange_contract_address,
SUM(CASE WHEN value > 0 THEN value/(10^COALESCE(e.decimals)) ELSE 0 END) AS added_value_tokens,
SUM(CASE WHEN value < 0 THEN value/(10^COALESCE(e.decimals)) ELSE 0 END) AS removed_value_tokens,
SUM(value/(10^COALESCE(e.decimals))) AS net_value_tokens,

SUM(CASE WHEN value > 0 THEN COALESCE(pb.median_price)*(
    value/(10^COALESCE(e.decimals))
    ) ELSE 0 END) AS added_value_usd,
SUM(CASE WHEN value < 0 THEN COALESCE(pb.median_price)*(
    value/(10^COALESCE(e.decimals))
    )  ELSE 0 END) AS removed_value_usd,
SUM( COALESCE(pb.median_price)*(
    value/(10^COALESCE(e.decimals))
    ) ) AS net_value_usd

FROM
(
    SELECT --adds
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value,
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20_ERC20_evt_Transfer e
    INNER JOIN lp_events l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""to""
    WHERE DATE_TRUNC('day',e.evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    
    UNION
    
    SELECT --removes
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value*(-1),
    DATE_TRUNC('day',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20_ERC20_evt_Transfer e
    INNER JOIN lp_events l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""from""
    WHERE DATE_TRUNC('day',e.evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
) a
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list e
    ON a.token = e.""contract_address""
    --AND p.price IS NULL
    LEFT JOIN dex_price pb
    ON a.token = pb.token
    AND e.""contract_address"" = pb.token
    --AND p.price IS NULL
    AND a.hour = pb.hour
    AND pb.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
GROUP BY 1,2,3
) d
GROUP BY 1,2

)

SELECT
--pair, fee_tier,
CASE WHEN daily_trade_rank <= 15 THEN CONCAT(pair,' - ', ROUND(fee_tier*100,2)::text,'%')
ELSE 'Other'
END AS pair_other,
day, trailing_days,
SUM(volume) AS volume,
SUM(fees) AS fees,
SUM(trades) AS trades,
SUM(tvl) AS tvl,
SUM(fees)*365/SUM(tvl) AS fees_tvl_yr,
SUM(net_liq) AS net_liq,
SUM(added_liq) AS added_liq

FROM (

SELECT
CONCAT(
COALESCE( (CASE WHEN ea.symbol ='WETH' THEN 'ETH' ELSE ea.symbol END)
            ,REPLACE(p.""token0""::text,'\','0') )
,'/',
COALESCE( (CASE WHEN eb.symbol ='WETH' THEN 'ETH' ELSE eb.symbol END)
            ,REPLACE(p.""token1""::text,'\','0') )
) AS pair, p.fee/1e6 AS fee_tier,
--p.fee/1e6 AS fee_tier,
DATE_TRUNC('day',hour) AS day,
SUM(volume) AS volume,
SUM(fees) AS fees,
SUM(trades) AS trades,
SUM(CASE WHEN hrank = 1 THEN tvl ELSE 0 END) AS tvl,
--fees_tvl_yr,
SUM(net_liq) AS net_liq,
SUM(added_liq) AS added_liq,
DENSE_RANK() OVER (ORDER BY DATE_TRUNC('day',hour) DESC) AS trailing_days,
DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('day',hour) ORDER BY ABS(SUM(net_liq)) DESC NULLS LAST) AS daily_trade_rank

FROM (
    SELECT l.hour, l.pool, hrank,/*SUM(l.total_daily_change) AS daily_tvl_change,*/
    SUM(usd_volume) AS volume,
    SUM(usd_fees) AS fees,
    SUM(num_trades) AS trades,
    SUM(l.total_running_balance) AS tvl,
    (
        SUM(usd_fees)::decimal/SUM(l.total_running_balance)::decimal
    )*(365/*/{{Trailing Num Days}}::decimal*/) fees_tvl_yr,
    SUM(nl.total_liq_net) AS net_liq,
    SUM(nl.total_liq_added) AS added_liq
    
    FROM lp_tvl l
    LEFT JOIN volume_and_fees vf
    ON vf.hour = l.hour
    AND vf.""exchange_contract_address"" = l.pool
    
    LEFT JOIN net_liq nl
    ON nl.hour = l.hour
    AND nl.exchange_contract_address = l.pool
    
    GROUP BY 1,2,3
    ORDER BY hour DESC
) a
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
    a.pool = p.pool
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea
    ON ea.""contract_address"" = p.""token0""
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
    ON eb.""contract_address"" = p.""token1""
    
GROUP BY 1,2,3
) b
GROUP BY 1,2,3

ORDER BY SUM(net_liq) DESC NULLS LAST"
82987,"Uniswap v3  Volume, Fees, TVL - Optimism by Pool (Agg)",,table,"-- We keep Optimism in hourly throughout because we don't have prices in dex.trades
WITH dex_trades AS (
SELECT --pulled from eth dex_trades abstraction: https://github.com/duneanalytics/abstractions/blob/master/ethereum/dex/trades/insert_uniswap.sql
            t.evt_block_time AS block_time,
            'Uniswap' AS project,
            '3' AS version,
            'DEX' AS category,
            t.""recipient"" AS trader_a,
            NULL::bytea AS trader_b,
            abs(amount0) AS token_a_amount_raw,
            abs(amount1) AS token_b_amount_raw,
            NULL::numeric AS usd_amount,
            f.token0 AS token_a_address,
            f.token1 AS token_b_address,
            t.contract_address as exchange_contract_address,
            t.evt_tx_hash AS tx_hash,
            NULL::integer[] AS trace_address,
            t.evt_index
        FROM
            uniswap_v3.""Pair_evt_Swap"" t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" f ON f.pool = t.contract_address
)


,gs AS (
    SELECT generate_series('2021-07-08'::TIMESTAMP, date_trunc('day', NOW()), '1 day') AS day
)
,gs_hr AS (
    SELECT generate_series('2021-07-08'::TIMESTAMP, date_trunc('hour', NOW()), '1 hour') AS hour
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
gs.hour,
token, symbol,
CASE WHEN symbol IN ('DAI','USDT','USDC') THEN 1
ELSE median_price
END AS median_price
FROM
(
SELECT *,
lead(hour, 1, now() ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour
FROM
(
SELECT
DATE_TRUNC('hour',block_time) AS hour,
token, symbol,
percentile_cont(0.5) WITHIN GROUP (ORDER BY token_price) AS median_price
FROM (
    SELECT *,
    usd_amount/token_amount AS token_price
    FROM
    (
        SELECT --tokena
        t.block_time, t.exchange_contract_address,
        ea.symbol,
        t.token_a_address AS token, --t.token_b_address,
        t.token_a_amount_raw/(10^ea.decimals) AS token_amount,
        --t.token_b_amount_raw/(10^eb.decimals) AS token_b_amount,
        CASE WHEN eb.symbol IN ('DAI','USDT','USDC') THEN --assume price = 1
            t.token_b_amount_raw/(10^eb.decimals) ELSE NULL
            END AS usd_amount
        /*t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_price--,
        --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_b_price*/
        FROM dex_trades t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
        t.""exchange_contract_address"" = p.pool
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea --both need to have known decimals, we're not going to assume anything.
        ON ea.""contract_address"" = t.token_a_address
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
        ON eb.""contract_address"" = t.token_b_address
        WHERE project = 'Uniswap' AND version = '3'
        AND t.block_time >= '2021-07-08'
        --AND 10^decimals > 0
        AND t.token_a_amount_raw > 100 --min to exclude weird stuff
        AND block_time > now() - interval '{{Trailing Num Days}} days'
    ) tokena
    
    UNION ALL
    
    SELECT *,
    usd_amount/token_amount AS token_price
    FROM
    (
        SELECT --tokenb
        t.block_time, t.exchange_contract_address,
        eb.symbol,
        --t.token_a_address,
        t.token_b_address AS token,
        --t.token_a_amount_raw/(10^ea.decimals) AS token_a_amount,
        t.token_b_amount_raw/(10^eb.decimals) AS token_amount,
        CASE WHEN ea.symbol IN ('DAI','USDT','USDC') THEN --assume price = 1
        t.token_a_amount_raw/(10^ea.decimals) ELSE NULL
        END AS usd_amount/*,
        --t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_a_price,
        --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_price*/
        FROM dex_trades t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
        t.""exchange_contract_address"" = p.pool
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea --both need to have known decimals, we're not going to assume anything.
        ON ea.""contract_address"" = t.token_a_address
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
        ON eb.""contract_address"" = t.token_b_address
        WHERE project = 'Uniswap' AND version = '3'
        AND t.block_time >= '2021-07-08'
        --AND 10^decimals > 0
        AND t.token_b_amount_raw > 100 --min to exclude weird stuff
        AND block_time > now() - interval '{{Trailing Num Days}} days'
    ) tokenb
) a
WHERE token_price > 0
GROUP BY 1,2,3

UNION ALL

SELECT
    '01-01-2000' AS dt, token::bytea, symbol, 1 AS median_price
    FROM ( values
            ('\x7f5c764cbc14f9669b88837ca1490cca17c31607','USDC')
            ,('\x94b008aa00579c1307b0ef2c499ad98a8ce58e58','USDT')
            ,('\xda10009cbd5d07dd0cecc66161fc93d7c9000da1','DAI')
        ) t (token, symbol)
) b
) c
INNER JOIN gs_hr gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour
)

,volume_and_fees AS ( --might not be pulling every trade?
SELECT
DATE_TRUNC('hour',""block_time"") AS hour,
--t.""token_a_address"",t.""token_a_amount_raw"",ea.symbol AS ""token_a_symbol"",--t.""token_a_symbol"",
--t.""token_b_address"",t.""token_b_amount_raw"",eb.symbol AS ""token_b_symbol"",--t.""token_b_symbol"",
""exchange_contract_address"",
a.fee,
SUM(COALESCE(""usd_amount"",
    (t.""token_a_amount_raw""/10^(ea.decimals))*pa.median_price,
    (t.""token_b_amount_raw""/10^(eb.decimals))*pb.median_price
    )) AS usd_volume,
SUM(COALESCE(""usd_amount"",
    (t.""token_a_amount_raw""/10^(ea.decimals))*pa.median_price,
    (t.""token_b_amount_raw""/10^(eb.decimals))*pb.median_price
    ))
    *(a.""fee""/1e6) AS usd_fees,
COUNT(*) AS num_trades
FROM dex_trades t
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
ON a.pool = t.""exchange_contract_address""
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea
    ON t.""token_a_address"" = ea.""contract_address""
    AND ""usd_amount"" IS NULL
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
    ON t.""token_b_address"" = eb.""contract_address""
    AND ea.""contract_address"" IS NULL
    AND ""usd_amount"" IS NULL
LEFT JOIN dex_price pa
    ON t.""token_a_address"" = pa.token
    AND ea.""contract_address"" = pa.token
    AND ""usd_amount"" IS NULL
    AND DATE_TRUNC('hour',""block_time"") = pa.hour
    AND pa.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
LEFT JOIN dex_price pb
    ON t.""token_b_address"" = pb.token
    AND ea.""contract_address"" IS NULL
    AND eb.""contract_address"" = pb.token
    AND ""usd_amount"" IS NULL
    AND DATE_TRUNC('hour',""block_time"") = pb.hour
    AND pb.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')

WHERE ""project"" = 'Uniswap' AND ""version"" = '3'
AND DATE_TRUNC('day',t.""block_time"") >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')

GROUP BY 1,2,3

HAVING COUNT(*) > 0

)



,lp_daily_token_balances AS(

SELECT 
gs.hour,pool,token,
running_balance,
(CASE WHEN gs.hour = e.hour THEN daily_change ELSE 0 END) AS daily_change
FROM
( SELECT *
    FROM
    (
    SELECT
    hour, pool, token, raw_value,
        lead(hour, 1, now() ) OVER (PARTITION BY pool, token
                            ORDER BY hour asc) AS next_hour,
        SUM(raw_value) --when there's a true change
            OVER (PARTITION BY pool, token ORDER BY hour ASC) AS running_balance,
        SUM(raw_value)
            OVER (PARTITION BY hour,pool, token) AS daily_change --did it this way to make group by's easier
    FROM
    (
    SELECT
    hour,
    exchange_contract_address AS pool, contract_address AS token,
    SUM(val) AS raw_value
    FROM (
         --get deposits into the lp pool
        SELECT 
        CASE WHEN DATE_TRUNC('hour',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('hour',e.""evt_block_time"")
            ELSE DATE_TRUNC('hour',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS hour,
        ""to"" AS exchange_contract_address,
        e.""contract_address"", SUM(value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON e.""to"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens

        GROUP BY 1,2,3
        
        UNION ALL
        
        SELECT 
        CASE WHEN DATE_TRUNC('hour',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('hour',e.""evt_block_time"")
            ELSE DATE_TRUNC('hour',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS hour,
        ""from"" AS exchange_contract_address,
        e.""contract_address"", SUM(-value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON e.""from"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens
        
        GROUP BY 1,2,3
        
        ) a
    GROUP BY 1,2,3
    ) b
    ) c
    WHERE c.next_hour >= DATE_TRUNC('day',NOW()) - interval '{{Trailing Num Days}} days'

) e
INNER JOIN gs_hr gs
ON e.hour <= gs.hour
AND gs.hour < e.next_hour

)


,lp_tvl AS( --calculate tvl
SELECT *,
DENSE_RANK() OVER (PARTITION BY DATE_TRUNC('day',hour) ORDER BY hour DESC) AS hrank --for getting eod tvl later
FROM (
SELECT a.hour, pool,

SUM(COALESCE(pb.median_price)*a.daily_change_raw/(10^COALESCE(e.decimals))) AS total_daily_change,
SUM(COALESCE(pb.median_price)*a.running_balance_raw/(10^COALESCE(e.decimals))) AS total_running_balance --# of tokens are in the LP
    
FROM (
    SELECT
    d.hour,
    d.pool,
    d.token,
    SUM(daily_change) AS daily_change_raw,
    SUM(running_balance) AS running_balance_raw
    FROM lp_daily_token_balances d
    
    WHERE d.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    GROUP BY 1,2,3
    
    ) a
    LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list e
    ON a.token = e.""contract_address""
    --AND p.price IS NULL
    LEFT JOIN dex_price pb
    ON a.token = pb.token
    AND e.""contract_address"" = pb.token
    --AND p.price IS NULL
    AND a.hour = pb.hour
    AND pb.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    
    WHERE a.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')

GROUP BY 1,2
) hourly_tvl
)

,lp_events AS (
SELECT evt_tx_hash FROM
        (
        SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_IncreaseLiquidity""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION ALL SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION ALL SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_DecreaseLiquidity""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION ALL SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
        ) e
GROUP BY 1 --distinct
)

, net_liq AS
(
SELECT
hour,exchange_contract_address,
SUM(added_value_usd) AS total_liq_added, --also calling this liquidity volume
SUM(removed_value_usd) AS total_liq_removed,
SUM(net_value_usd) AS total_liq_net
FROM (
SELECT
a.hour, a.token, a.exchange_contract_address,
SUM(CASE WHEN value > 0 THEN value/(10^COALESCE(e.decimals)) ELSE 0 END) AS added_value_tokens,
SUM(CASE WHEN value < 0 THEN value/(10^COALESCE(e.decimals)) ELSE 0 END) AS removed_value_tokens,
SUM(value/(10^COALESCE(e.decimals))) AS net_value_tokens,

SUM(CASE WHEN value > 0 THEN COALESCE(pb.median_price)*(
    value/(10^COALESCE(e.decimals))
    ) ELSE 0 END) AS added_value_usd,
SUM(CASE WHEN value < 0 THEN COALESCE(pb.median_price)*(
    value/(10^COALESCE(e.decimals))
    )  ELSE 0 END) AS removed_value_usd,
SUM( COALESCE(pb.median_price)*(
    value/(10^COALESCE(e.decimals))
    ) ) AS net_value_usd

FROM
(
    SELECT --adds
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value,
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN lp_events l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""to""
    WHERE DATE_TRUNC('day',e.evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    
    UNION
    
    SELECT --removes
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value*(-1),
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN lp_events l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""from""
    WHERE DATE_TRUNC('day',e.evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
) a
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list e
    ON a.token = e.""contract_address""
    --AND p.price IS NULL
    LEFT JOIN dex_price pb
    ON a.token = pb.token
    AND e.""contract_address"" = pb.token
    --AND p.price IS NULL
    AND a.hour = pb.hour
    AND pb.hour >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
GROUP BY 1,2,3
) d
GROUP BY 1,2

),

unique_swappers AS (
SELECT
""exchange_contract_address"",
    COUNT(DISTINCT trader_a) AS num_swappers
FROM dex_trades

WHERE ""project"" = 'Uniswap' AND ""version"" = '3'
AND DATE_TRUNC('day',""block_time"") >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')

GROUP BY 1
)

SELECT
--pair, fee_tier,
/*CASE WHEN daily_trade_rank <= 25 THEN*/ CONCAT(pair,' - ', ROUND(fee_tier*100,2)::text,'%')
/*ELSE 'Other'
END */AS pair_other,
--day, trailing_days,
volume,
volume / (SUM(volume) OVER ()) AS pct_volume,
num_swappers,

tvl,
tvl / (SUM(tvl) OVER ()) AS pct_tvl,
fees,
fees / (SUM(fees) OVER ()) AS pct_fees,
trades,
trades / (SUM(trades) OVER ()) AS pct_trades,
volume::decimal / num_swappers::decimal AS vol_per_swapper,
volume::decimal / trades::decimal AS vol_per_trade,
trades::decimal / num_swappers::decimal AS trades_per_swapper,
net_liq,
--net_liq / (SUM(net_liq) OVER ()) AS pct_net_liq,
--fees/tvl AS fees_tvl,
CASE WHEN tvl < 1 THEN NULL ELSE 
fees*(365/('{{Trailing Num Days}}'))/tvl END AS fees_tvl_yr,

'<a href=""https://info.uniswap.org/#/optimism/pools/' || REPLACE(pool::text,'\','0') || '"" target=""_blank"">' || 'Uniswap Pool Link' || '</a>'
AS uni_pool_link,
REPLACE(pool::text,'\','0') AS pool_txt,
pair

FROM (

SELECT
a.pool,
CONCAT(
COALESCE(ea.symbol,REPLACE(p.""token0""::text,'\','0'))
,'/',
COALESCE(eb.symbol,REPLACE(p.""token1""::text,'\','0'))
) AS pair,
p.fee/1e6 AS fee_tier,
--day,
SUM(volume) AS volume,
SUM(fees) AS fees,
SUM(trades) AS trades,
num_swappers,
SUM(tvl) AS tvl,
SUM(net_liq) AS net_liq/*,
SUM(fees)*365/SUM(tvl) AS fees_tvl_yr*//*,
DENSE_RANK() OVER (ORDER BY day DESC) AS trailing_days,
DENSE_RANK() OVER(PARTITION BY day ORDER BY trades DESC) AS daily_trade_rank*/

FROM (
    SELECT /*l.day,*/ l.pool, /*SUM(l.total_daily_change) AS daily_tvl_change,*/
    SUM(usd_volume) AS volume,
    SUM(usd_fees) AS fees,
    SUM(num_trades) AS trades,
    SUM(CASE WHEN DATE_TRUNC('day',now()) = l.hour THEN
        l.total_running_balance ELSE 0 END) AS tvl, --get today's tvl (latest tvl)
    SUM(nl.total_liq_net) AS net_liq,
    us.num_swappers
    
    FROM lp_tvl l
    LEFT JOIN volume_and_fees vf
    ON vf.hour = l.hour
    AND vf.""exchange_contract_address"" = l.pool
    LEFT JOIN net_liq nl
    ON nl.hour = l.hour
    AND nl.exchange_contract_address = l.pool
    LEFT JOIN unique_swappers us
        ON us.exchange_contract_address = l.pool
    GROUP BY 1,us.num_swappers--,2
    --ORDER BY hour DESC
) a
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
    a.pool = p.pool
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea
    ON ea.""contract_address"" = p.""token0""
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
    ON eb.""contract_address"" = p.""token1""
GROUP BY 1,2,3, num_swappers
) b

WHERE volume >0 or tvl> 0

GROUP BY CONCAT(pair,' - ', ROUND(fee_tier*100,2)::text,'%'),
volume, fees, trades, tvl, pool, net_liq, pair, num_swappers

ORDER BY /*day DESC,*/ SUM(volume) DESC NULLS LAST"
108719,"Uniswap v3  Volume, Fees, TVL - Ethereum",,counter,"-- Eth Data
WITH
gs AS (
    SELECT generate_series('2021-05-04'::TIMESTAMP, date_trunc('day', NOW()), '1 day') AS day
)
,gs_hr AS (
    SELECT generate_series('2021-05-04'::TIMESTAMP, date_trunc('hour', NOW()), '1 hour') AS hour
)

,prices AS (
SELECT
DATE_TRUNC('day',""minute"") AS day_group, dayrank,
DATE_TRUNC('hour',""minute"") AS hour,
""contract_address"",""decimals"",""price"",""symbol""
FROM
    (
    SELECT *,
    DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('hour',""minute""), ""contract_address"" ORDER BY ""minute"" DESC) AS mrank,
    DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('day',""minute""), ""contract_address"" ORDER BY ""minute"" DESC) AS dayrank
    FROM prices.""usd""
    WHERE
        ""minute"" >= DATE_TRUNC('day',now()) - interval '{{Trailing Num Days}} days'
        --AND NOT IN (SELECT contract_address FROM prices.usd p)
        AND ""contract_address"" IN (SELECT ""token0"" FROM uniswap_v3.""Factory_evt_PoolCreated""
                                    UNION ALL SELECT ""token1"" FROM uniswap_v3.""Factory_evt_PoolCreated"")
    ) a
WHERE mrank = 1
AND symbol
NOT IN (
    'SAITAMA'
        ) --exclude tokens that ruin volume/tvl/and everything
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
gs.hour,
token, symbol, median_price,
DATE_TRUNC('day',gs.hour) AS day_group,
DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('day',gs.hour), token ORDER BY gs.hour DESC) AS dayrank
FROM
(
SELECT *,
lead(hour, 1, now() ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour
FROM
(
SELECT
DATE_TRUNC('hour',block_time) AS hour,
token, symbol,
percentile_cont(0.5) WITHIN GROUP (ORDER BY token_price) AS median_price,
COUNT(*) AS num_samples
FROM (
    SELECT --tokena
    t.block_time, t.exchange_contract_address,
    ea.symbol,
    t.token_a_address AS token, --t.token_b_address,
    t.token_a_amount_raw/(10^ea.decimals) AS token_amount,
    --t.token_b_amount_raw/(10^eb.decimals) AS token_b_amount,
    t.usd_amount,
    t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_price--,
    --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_b_price
    FROM dex.trades t
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
    t.""exchange_contract_address"" = p.pool
    INNER JOIN erc20.""tokens"" ea --both need to have known decimals, we're not going to assume anything.
    ON ea.""contract_address"" = t.token_a_address
    --INNER JOIN erc20.""tokens"" eb
    --ON eb.""contract_address"" = t.token_b_address
    WHERE project = 'Uniswap' AND version = '3'
    AND t.block_time >= '2021-05-04'
    AND 10^decimals > 0
    AND t.token_a_amount_raw > 100 --min to exclude weird stuff
    AND t.block_time >= DATE_TRUNC('day',now()) - interval '{{Trailing Num Days}} days'
    AND usd_amount > 0
    
    UNION ALL
    
    SELECT --tokenb
    t.block_time, t.exchange_contract_address,
    eb.symbol,
    --t.token_a_address,
    t.token_b_address AS token,
    --t.token_a_amount_raw/(10^ea.decimals) AS token_a_amount,
    t.token_b_amount_raw/(10^eb.decimals) AS token_amount,
    t.usd_amount,
    --t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_a_price,
    t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_price
    FROM dex.trades t
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
    t.""exchange_contract_address"" = p.pool
    --INNER JOIN erc20.""tokens"" ea --both need to have known decimals, we're not going to assume anything.
    --ON ea.""contract_address"" = t.token_a_address
    INNER JOIN erc20.""tokens"" eb
    ON eb.""contract_address"" = t.token_b_address
    WHERE project = 'Uniswap' AND version = '3'
    AND t.block_time >= '2021-05-04'
    AND 10^decimals > 0
    AND t.token_b_amount_raw > 100 --min to exclude weird stuff
    AND t.block_time >= DATE_TRUNC('day',now()) - interval '{{Trailing Num Days}} days'
    AND usd_amount > 0
) a
WHERE token_price > 0
GROUP BY 1,2,3

HAVING COUNT(*) > 5 -- need more than 5 samples to take the price
) b
) c
INNER JOIN gs_hr gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour
)
/*
,dex_price AS (
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
DATE_TRUNC('day',gs.hour) AS day_group,
gs.hour,
token, median_price,
DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('day',gs.hour), token ORDER BY gs.hour DESC) AS dayrank
FROM
(
SELECT *,
lead(hour, 1, now() ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour
FROM
(
SELECT
DATE_TRUNC('hour',hour) AS hour,
token, median_price
FROM (
    SELECT ""hour"",""contract_address"" AS token,""median_price"", --DENSE_RANK() OVER (PARTITION BY DATE_TRUNC('day',hour) ORDER BY hour DESC) AS hrank
    FROM dex.""view_token_prices"" t
    
    WHERE
    hour >= DATE_TRUNC('day',now()) - interval '{{Trailing Num Days}} days' - interval '7 days' --buffer
    --AND NOT IN (SELECT contract_address FROM prices.usd p)
    AND ""contract_address"" IN (SELECT ""token0"" FROM uniswap_v3.""Factory_evt_PoolCreated""
                                UNION ALL SELECT ""token1"" FROM uniswap_v3.""Factory_evt_PoolCreated"")
    AND sample_size >=10
) a
WHERE median_price > 0
--AND hrank = 1

GROUP BY 1,2,3
) b
) c
INNER JOIN gs_hr gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour
)*/


,volume_and_fees AS (
SELECT
DATE_TRUNC('day',""block_time"") AS day,
--t.""token_a_address"",t.""token_a_amount_raw"",t.""token_a_symbol"",
--t.""token_b_address"",t.""token_b_amount_raw"",t.""token_b_symbol"",
""exchange_contract_address"",
a.fee,
SUM(""usd_amount"") AS usd_volume,
SUM(""usd_amount"")
    *(a.""fee""/1e6) AS usd_fees,
COUNT(*) AS num_trades
FROM dex.trades t
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
ON a.pool = t.""exchange_contract_address""
LEFT JOIN erc20.""tokens"" ea
    ON t.""token_a_address"" = ea.""contract_address""
    AND ""usd_amount"" IS NULL
LEFT JOIN erc20.""tokens"" eb
    ON t.""token_b_address"" = eb.""contract_address""
    AND ea.""contract_address"" IS NULL
    AND ""usd_amount"" IS NULL

WHERE ""project"" = 'Uniswap' AND ""version"" = '3'
AND DATE_TRUNC('day',t.""block_time"") >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
AND t.exchange_contract_address IN (SELECT pool FROM uniswap_v3.""Factory_evt_PoolCreated"")
    
    

GROUP BY 1,2,3

HAVING SUM(""usd_amount"") > 0

)

,lp_daily_token_balances AS( --daily

SELECT 
gs.day,pool,token,
running_balance,
(CASE WHEN gs.day = e.day THEN daily_change ELSE 0 END) AS daily_change
FROM
( SELECT *
    FROM
    (
    SELECT
    day, pool, token, raw_value,
        lead(day, 1, now() ) OVER (PARTITION BY pool, token
                            ORDER BY day asc) AS next_day,
        SUM(raw_value) --when there's a true change
            OVER (PARTITION BY pool, token ORDER BY day ASC) AS running_balance,
        SUM(raw_value)
            OVER (PARTITION BY day,pool, token) AS daily_change --did it this way to make group by's easier
    FROM
    (
    SELECT
    day,
    exchange_contract_address AS pool, contract_address AS token,
    SUM(val) AS raw_value
    FROM (
         --get deposits into the lp pool
        SELECT 
        CASE WHEN DATE_TRUNC('day',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('day',e.""evt_block_time"")
            ELSE DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS day,
        ""to"" AS exchange_contract_address,
        e.""contract_address"", SUM(value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""to"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens

        GROUP BY 1,2,3
        
        UNION ALL
        
        SELECT 
        CASE WHEN DATE_TRUNC('day',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('day',e.""evt_block_time"")
            ELSE DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS day,
        ""from"" AS exchange_contract_address,
        e.""contract_address"", SUM(-value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""from"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens
        
        GROUP BY 1,2,3
        
        ) a
    GROUP BY 1,2,3
    ) b
    ) c
    WHERE c.next_day >= DATE_TRUNC('day',NOW()) - interval '{{Trailing Num Days}} days'

) e
INNER JOIN gs
ON e.day <= gs.day
AND gs.day < e.next_day

)


,lp_tvl AS( --calculate tvl --daily

SELECT a.day, pool,

SUM(COALESCE(p.price, pb.median_price)*COALESCE(a.daily_change_raw,0)/(10^COALESCE(e.decimals,p.decimals))) AS total_daily_change,
SUM(COALESCE(p.price, pb.median_price)*COALESCE(a.running_balance_raw,0)/(10^COALESCE(e.decimals,p.decimals))) AS total_running_balance --# of tokens are in the LP
    
    
FROM ( -- maybe chunk this out where prices come in later
    SELECT
    d.day,
    d.pool,
    d.token,
    SUM(daily_change) AS daily_change_raw,
    SUM(running_balance) AS running_balance_raw
    FROM lp_daily_token_balances d
    
    WHERE d.day >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    GROUP BY 1,2,3
    
    ) a
    LEFT JOIN (SELECT * FROM prices WHERE dayrank = 1) p
    ON a.token = p.""contract_address""
    AND a.day = p.day_group
    
    LEFT JOIN erc20.""tokens"" e
    ON a.token = e.""contract_address""
    AND p.price IS NULL
    
    LEFT JOIN (SELECT * FROM dex_price WHERE dayrank = 1) pb
    ON a.token = pb.token
    AND p.price IS NULL
    AND a.day = pb.day_group

GROUP BY 1,2
)


, net_liq AS --hourly then agg
(
SELECT
DATE_TRUNC('day',hour) AS day,exchange_contract_address,
SUM(added_value_usd) AS total_liq_added, --also calling this liquidity volume
SUM(removed_value_usd) AS total_liq_removed,
SUM(net_value_usd) AS total_liq_net
FROM (
SELECT
a.hour, a.token, a.exchange_contract_address,
SUM(CASE WHEN value > 0 THEN value/(10^COALESCE(e.decimals,p.decimals)) ELSE 0 END) AS added_value_tokens,
SUM(CASE WHEN value < 0 THEN value/(10^COALESCE(e.decimals,p.decimals)) ELSE 0 END) AS removed_value_tokens,
SUM(value/(10^COALESCE(e.decimals,p.decimals))) AS net_value_tokens,

SUM(CASE WHEN value > 0 THEN COALESCE(p.price,pb.median_price)*(
    value/(10^COALESCE(e.decimals,p.decimals))
    ) ELSE 0 END) AS added_value_usd,
SUM(CASE WHEN value < 0 THEN COALESCE(p.price,pb.median_price)*(
    value/(10^COALESCE(e.decimals,p.decimals))
    )  ELSE 0 END) AS removed_value_usd,
SUM( COALESCE(p.price,pb.median_price)*(
    value/(10^COALESCE(e.decimals,p.decimals))
    ) ) AS net_value_usd

FROM
(
    SELECT --adds
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value,
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN
    ( --get all liquidity event txs // couldn't find a way to connect tokenID to pool - data is missing...
          SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_IncreaseLiquidity""
          WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_DecreaseLiquidity""
        WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    ) l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""to""
    WHERE e.evt_block_time >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    
    UNION ALL
    
    SELECT --removes
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value*(-1),
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN
    ( --get all liquidity event txs // couldn't find a way to connect tokenID to pool - data is missing...
          SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_IncreaseLiquidity""
            WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_DecreaseLiquidity""
        WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE DATE_TRUNC('day',evt_block_time) >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    ) l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""from""
    WHERE e.evt_block_time >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
) a
LEFT JOIN prices p
    ON a.token = p.""contract_address""
    AND
    p.hour = a.hour
LEFT JOIN erc20.""tokens"" e
    ON a.token = e.""contract_address""
    AND p.price IS NULL
LEFT JOIN dex_price pb
    ON a.token = pb.token
    AND e.""contract_address"" = pb.token
    AND p.price IS NULL
    AND a.hour = pb.hour
GROUP BY 1,2,3
) d
GROUP BY 1,2

)

--, counting_stats AS (
SELECT */*,
DENSE_RANK() OVER(ORDER BY day DESC) AS drank*/
FROM (
    SELECT l.day, /*SUM(l.total_daily_change) AS daily_tvl_change,*/
    SUM(usd_volume) AS volume,
    SUM(usd_fees) AS fees,
    SUM(l.total_running_balance) AS tvl,
    SUM(total_liq_net) AS net_liq,
    (
        SUM(usd_fees)::decimal/SUM(l.total_running_balance)::decimal
    )*(365) fees_tvl_yr,
    SUM(num_trades) AS trades
    FROM lp_tvl l
    LEFT JOIN volume_and_fees vf
    ON vf.day = l.day
    AND vf.""exchange_contract_address"" = l.pool
    LEFT JOIN net_liq nl
    ON nl.day = l.day
    AND nl.exchange_contract_address = l.pool
    GROUP BY 1
    ) a
--)
ORDER BY day DESC"
82988,"Uniswap v3  Volume, Fees, TVL - Ethereum by Pool (Agg)",,table,"-- Eth Data
WITH
gs AS (
    SELECT generate_series('2021-05-04'::TIMESTAMP, date_trunc('day', NOW()), '1 day') AS day
)
,gs_hr AS (
    SELECT generate_series('2021-05-04'::TIMESTAMP, date_trunc('hour', NOW()), '1 hour') AS hour
)

,volume_and_fees AS (
SELECT
DATE_TRUNC('day',""block_time"") AS day,
""exchange_contract_address"",
a.fee,
SUM(""usd_amount"") AS usd_volume,
SUM(""usd_amount"")
    *(a.""fee""/1e6) AS usd_fees,
COUNT(*) AS num_trades
FROM dex.trades t
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
ON a.pool = t.""exchange_contract_address""

WHERE ""project"" = 'Uniswap' AND ""version"" = '3'
AND DATE_TRUNC('day',t.""block_time"") >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
AND t.exchange_contract_address IN (SELECT pool FROM uniswap_v3.""Factory_evt_PoolCreated"")

GROUP BY 1,2,3

HAVING SUM(""usd_amount"") > 0

)

,prices AS (
SELECT
DATE_TRUNC('day',""minute"") AS day_group, dayrank,
DATE_TRUNC('hour',""minute"") AS hour,
""contract_address"",""decimals"",""price"",""symbol""
FROM
    (
    SELECT *,
        DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('hour',""minute""), ""contract_address"" ORDER BY ""minute"" DESC) AS mrank,
        DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('day',""minute""), ""contract_address"" ORDER BY ""minute"" DESC) AS dayrank
    FROM prices.""usd""
    WHERE
        ""minute"" >= DATE_TRUNC('day',now()) - interval '{{Trailing Num Days}} days'
        --AND NOT IN (SELECT contract_address FROM prices.usd p)
        AND ""contract_address"" IN (SELECT ""token0"" FROM uniswap_v3.""Factory_evt_PoolCreated""
                                        WHERE ""pool"" IN (SELECT ""exchange_contract_address"" FROM volume_and_fees)
                                    UNION ALL SELECT ""token1"" FROM uniswap_v3.""Factory_evt_PoolCreated""
                                        WHERE ""pool"" IN (SELECT ""exchange_contract_address"" FROM volume_and_fees)
                                    )
    ) a
WHERE mrank = 1
AND symbol
NOT IN (
    'SAITAMA'
        ) --exclude tokens that ruin volume/tvl/and everything
)
,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
gs.hour,
token, symbol, median_price,
DATE_TRUNC('day',gs.hour) AS day_group,
DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('day',gs.hour), token ORDER BY gs.hour DESC) AS dayrank
FROM
(
SELECT *,
lead(hour, 1, now() ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour
FROM
(
SELECT
DATE_TRUNC('hour',block_time) AS hour,
token, symbol,
percentile_cont(0.5) WITHIN GROUP (ORDER BY token_price) AS median_price,
COUNT(*) AS num_samples
FROM (
    SELECT --tokena
    t.block_time, t.exchange_contract_address,
    ea.symbol,
    t.token_a_address AS token, --t.token_b_address,
    t.token_a_amount_raw/(10^ea.decimals) AS token_amount,
    --t.token_b_amount_raw/(10^eb.decimals) AS token_b_amount,
    t.usd_amount,
    t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_price--,
    --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_b_price
    FROM dex.trades t
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
    t.""exchange_contract_address"" = p.pool
    INNER JOIN erc20.""tokens"" ea --both need to have known decimals, we're not going to assume anything.
    ON ea.""contract_address"" = t.token_a_address
    --INNER JOIN erc20.""tokens"" eb
    --ON eb.""contract_address"" = t.token_b_address
    WHERE project = 'Uniswap' AND version = '3'
    AND t.block_time >= '2021-05-04'
    AND 10^decimals > 0
    AND t.token_a_amount_raw > 100 --min to exclude weird stuff
    AND t.block_time >= DATE_TRUNC('day',now()) - interval '{{Trailing Num Days}} days'
    AND usd_amount > 0
    AND p.""pool"" IN (SELECT ""exchange_contract_address"" FROM volume_and_fees)
    
    UNION ALL
    
    SELECT --tokenb
    t.block_time, t.exchange_contract_address,
    eb.symbol,
    --t.token_a_address,
    t.token_b_address AS token,
    --t.token_a_amount_raw/(10^ea.decimals) AS token_a_amount,
    t.token_b_amount_raw/(10^eb.decimals) AS token_amount,
    t.usd_amount,
    --t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_a_price,
    t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_price
    FROM dex.trades t
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
    t.""exchange_contract_address"" = p.pool
    --INNER JOIN erc20.""tokens"" ea --both need to have known decimals, we're not going to assume anything.
    --ON ea.""contract_address"" = t.token_a_address
    INNER JOIN erc20.""tokens"" eb
    ON eb.""contract_address"" = t.token_b_address
    WHERE project = 'Uniswap' AND version = '3'
    AND t.block_time >= '2021-05-04'
    AND 10^decimals > 0
    AND t.token_b_amount_raw > 100 --min to exclude weird stuff
    AND t.block_time >= DATE_TRUNC('day',now()) - interval '{{Trailing Num Days}} days'
    AND usd_amount > 0
    AND p.""pool"" IN (SELECT ""exchange_contract_address"" FROM volume_and_fees)
) a
WHERE token_price > 0
GROUP BY 1,2,3

HAVING COUNT(*) > 3 -- need more than 3 samples to take the price
) b
) c
INNER JOIN gs_hr gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour

WHERE symbol
NOT IN (
    'SAITAMA'
        ) --exclude tokens that ruin volume/tvl/and everything
)

,lp_daily_token_balances AS( --daily

SELECT 
gs.day,pool,token,
running_balance,
(CASE WHEN gs.day = e.day THEN daily_change ELSE 0 END) AS daily_change
FROM
( SELECT *
    FROM
    (
    SELECT
    day, pool, token, raw_value,
        lead(day, 1, now() ) OVER (PARTITION BY pool, token
                            ORDER BY day asc) AS next_day,
        SUM(raw_value) --when there's a true change
            OVER (PARTITION BY pool, token ORDER BY day ASC) AS running_balance,
        SUM(raw_value)
            OVER (PARTITION BY day,pool, token) AS daily_change --did it this way to make group by's easier
    FROM
    (
    SELECT
    day,
    exchange_contract_address AS pool, contract_address AS token,
    SUM(val) AS raw_value
    FROM (
         --get deposits into the lp pool
        SELECT 
        CASE WHEN DATE_TRUNC('day',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('day',e.""evt_block_time"")
            ELSE DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS day,
        ""to"" AS exchange_contract_address,
        e.""contract_address"", SUM(value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""to"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens

        GROUP BY 1,2,3
        
        UNION ALL
        
        SELECT 
        CASE WHEN DATE_TRUNC('day',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('day',e.""evt_block_time"")
            ELSE DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS day,
        ""from"" AS exchange_contract_address,
        e.""contract_address"", SUM(-value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""from"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens
        
        GROUP BY 1,2,3
        
        ) a
    GROUP BY 1,2,3
    ) b
    ) c
    WHERE c.next_day >= DATE_TRUNC('day',NOW()) - interval '{{Trailing Num Days}} days'

) e
INNER JOIN gs
ON e.day <= gs.day
AND gs.day < e.next_day

)


,lp_tvl AS( --calculate tvl --daily

SELECT a.day, pool,

SUM(COALESCE(p.price, pb.median_price)*COALESCE(a.daily_change_raw,0)/(10^COALESCE(e.decimals,p.decimals))) AS total_daily_change,
SUM(COALESCE(p.price, pb.median_price)*COALESCE(a.running_balance_raw,0)/(10^COALESCE(e.decimals,p.decimals))) AS total_running_balance --# of tokens are in the LP
    
    
FROM ( -- maybe chunk this out where prices come in later
    SELECT
    d.day,
    d.pool,
    d.token,
    SUM(daily_change) AS daily_change_raw,
    SUM(running_balance) AS running_balance_raw
    FROM lp_daily_token_balances d
    
    WHERE d.day >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    GROUP BY 1,2,3
    
    ) a
    LEFT JOIN (SELECT * FROM prices WHERE dayrank = 1) p
    ON a.token = p.""contract_address""
    AND a.day = p.day_group
    
    LEFT JOIN erc20.""tokens"" e
    ON a.token = e.""contract_address""
    AND p.price IS NULL
    
    LEFT JOIN (SELECT * FROM dex_price WHERE dayrank = 1) pb
    ON a.token = pb.token
    AND p.price IS NULL
    AND a.day = pb.day_group

GROUP BY 1,2
)


, net_liq AS --hourly then agg
(
SELECT
DATE_TRUNC('day',hour) AS day,exchange_contract_address,
SUM(added_value_usd) AS total_liq_added, --also calling this liquidity volume
SUM(removed_value_usd) AS total_liq_removed,
SUM(net_value_usd) AS total_liq_net
FROM (
SELECT
a.hour, a.token, a.exchange_contract_address,
SUM(CASE WHEN value > 0 THEN value/(10^COALESCE(e.decimals,p.decimals)) ELSE 0 END) AS added_value_tokens,
SUM(CASE WHEN value < 0 THEN value/(10^COALESCE(e.decimals,p.decimals)) ELSE 0 END) AS removed_value_tokens,
SUM(value/(10^COALESCE(e.decimals,p.decimals))) AS net_value_tokens,

SUM(CASE WHEN value > 0 THEN COALESCE(p.price,pb.median_price)*(
    value/(10^COALESCE(e.decimals,p.decimals))
    ) ELSE 0 END) AS added_value_usd,
SUM(CASE WHEN value < 0 THEN COALESCE(p.price,pb.median_price)*(
    value/(10^COALESCE(e.decimals,p.decimals))
    )  ELSE 0 END) AS removed_value_usd,
SUM( COALESCE(p.price,pb.median_price)*(
    value/(10^COALESCE(e.decimals,p.decimals))
    ) ) AS net_value_usd

FROM
(
    SELECT --adds
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value,
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN
    ( --get all liquidity event txs // couldn't find a way to connect tokenID to pool - data is missing...
          SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_IncreaseLiquidity""
          WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_DecreaseLiquidity""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    ) l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""to""
    WHERE e.evt_block_time >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    AND a.""pool"" IN (SELECT ""exchange_contract_address"" FROM volume_and_fees)
    
    UNION ALL
    
    SELECT --removes
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value*(-1),
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN
    ( --get all liquidity event txs // couldn't find a way to connect tokenID to pool - data is missing...
          SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_IncreaseLiquidity""
            WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_DecreaseLiquidity""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    ) l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""from""
    WHERE e.evt_block_time >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    AND a.""pool"" IN (SELECT ""exchange_contract_address"" FROM volume_and_fees)
) a
LEFT JOIN prices p
    ON a.token = p.""contract_address""
    AND
    p.hour = a.hour
LEFT JOIN erc20.""tokens"" e
    ON a.token = e.""contract_address""
    AND p.price IS NULL
LEFT JOIN dex_price pb
    ON a.token = pb.token
    AND e.""contract_address"" = pb.token
    AND p.price IS NULL
    AND a.hour = pb.hour
GROUP BY 1,2,3
) d
GROUP BY 1,2

)

,unique_swappers AS (
SELECT
""exchange_contract_address"",
    COUNT(DISTINCT trader_a) AS num_swappers
FROM dex.trades

WHERE ""project"" = 'Uniswap' AND ""version"" = '3'
AND DATE_TRUNC('hour',""block_time"") >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
AND ""exchange_contract_address"" IN (SELECT ""exchange_contract_address"" FROM volume_and_fees)

GROUP BY 1
)


SELECT
--pair, fee_tier,

'<a href=https://dune.xyz/msilb7/Uniswap-v3-Pair-Deep-Dive?Pool%20Address='
|| REPLACE(pool::text,'\','0')  || '"" target=""_blank"">'
|| CONCAT(pair,' - ', ROUND(fee_tier*100,2)::text,'%') || '</a>' AS pair_other,

--day, trailing_days,
volume,
volume / (SUM(volume) OVER ()) AS pct_volume,
num_swappers,

tvl,
tvl / (SUM(tvl) OVER ()) AS pct_tvl,
fees,
fees / (SUM(fees) OVER ()) AS pct_fees,
trades,
trades / (SUM(trades) OVER ()) AS pct_trades,
volume::decimal / num_swappers::decimal AS vol_per_swapper,
volume::decimal / trades::decimal AS vol_per_trade,
trades::decimal / num_swappers::decimal AS trades_per_swapper,
net_liq,
--net_liq / (SUM(net_liq) OVER ()) AS pct_net_liq,
--fees/tvl AS fees_tvl,
CASE WHEN tvl < 1 THEN NULL ELSE 
fees*(365/('{{Trailing Num Days}}'))/tvl END AS fees_tvl_yr,

CONCAT(pair,' - ', ROUND(fee_tier*100,2)::text,'%') AS pool_name,

'<a href=https://dune.xyz/msilb7/Uniswap-v3-Pair-Deep-Dive?Pool%20Address='
|| REPLACE(pool::text,'\','0') || '"" target=""_blank"">'
|| 'Pool Deep-Dive Dashboard Link' || '</a>' AS dd_link,

'<a href=""https://info.uniswap.org/#/optimism/pools/' || REPLACE(pool::text,'\','0') || '"" target=""_blank"">' || 'Uniswap Pool Link' || '</a>'
AS uni_pool_link,
REPLACE(pool::text,'\','0') AS pool_txt,
pair

FROM (

SELECT
a.pool,
CONCAT(
COALESCE(ea.symbol,REPLACE(p.""token0""::text,'\','0'))
,'/',
COALESCE(eb.symbol,REPLACE(p.""token1""::text,'\','0'))
) AS pair,
p.fee/1e6 AS fee_tier,
--day,
SUM(volume) AS volume,
SUM(fees) AS fees,
SUM(trades) AS trades,
num_swappers,
SUM(tvl) AS tvl,
SUM(net_liq) AS net_liq/*,
SUM(fees)*365/SUM(tvl) AS fees_tvl_yr*//*,
DENSE_RANK() OVER (ORDER BY day DESC) AS trailing_days,
DENSE_RANK() OVER(PARTITION BY day ORDER BY trades DESC) AS daily_trade_rank*/

FROM (
    SELECT /*l.day,*/ l.pool, /*SUM(l.total_daily_change) AS daily_tvl_change,*/
    SUM(usd_volume) AS volume,
    SUM(usd_fees) AS fees,
    SUM(num_trades) AS trades,
    SUM(CASE WHEN DATE_TRUNC('day',now()) = l.day THEN
        l.total_running_balance ELSE 0 END) AS tvl, --get today's tvl (latest tvl)
    SUM(nl.total_liq_net) AS net_liq,
    us.num_swappers
    
    FROM lp_tvl l
    LEFT JOIN volume_and_fees vf
    ON vf.day = l.day
    AND vf.""exchange_contract_address"" = l.pool
    LEFT JOIN net_liq nl
    ON nl.day = l.day
    AND nl.exchange_contract_address = l.pool
    LEFT JOIN unique_swappers us
        ON us.exchange_contract_address = l.pool
    GROUP BY 1,us.num_swappers--,2
    --ORDER BY day DESC
) a
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
    a.pool = p.pool
LEFT JOIN erc20.""tokens"" ea
    ON ea.""contract_address"" = p.""token0""
LEFT JOIN erc20.""tokens"" eb
    ON eb.""contract_address"" = p.""token1""
GROUP BY 1,2,3, num_swappers
) b

WHERE volume >0 and tvl> 0

GROUP BY CONCAT(pair,' - ', ROUND(fee_tier*100,2)::text,'%'),
volume, fees, trades, tvl, pool, net_liq, pair, num_swappers

ORDER BY /*day DESC,*/ SUM(volume) DESC NULLS LAST"
82985,"Uniswap v3  Volume, Fees, TVL - Ethereum by Pair x Day",,table,"-- Eth Data
WITH
gs AS (
    SELECT generate_series('2021-05-04'::TIMESTAMP, date_trunc('day', NOW()), '1 day') AS day
)
,gs_hr AS (
    SELECT generate_series('2021-05-04'::TIMESTAMP, date_trunc('hour', NOW()), '1 hour') AS hour
)

,prices AS (
SELECT
DATE_TRUNC('day',""minute"") AS day_group, dayrank,
DATE_TRUNC('hour',""minute"") AS hour,
""contract_address"",""decimals"",""price"",""symbol""
FROM
    (
    SELECT *,
    DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('hour',""minute""), ""contract_address"" ORDER BY ""minute"" DESC) AS mrank,
    DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('day',""minute""), ""contract_address"" ORDER BY ""minute"" DESC) AS dayrank
    FROM prices.""usd""
    WHERE
        ""minute"" >= DATE_TRUNC('day',now()) - interval '{{Trailing Num Days}} days'
        --AND NOT IN (SELECT contract_address FROM prices.usd p)
        AND ""contract_address"" IN (SELECT ""token0"" FROM uniswap_v3.""Factory_evt_PoolCreated""
                                    UNION ALL SELECT ""token1"" FROM uniswap_v3.""Factory_evt_PoolCreated"")
    ) a
WHERE mrank = 1
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
gs.hour,
token, symbol, median_price,
DATE_TRUNC('day',gs.hour) AS day_group,
DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('day',gs.hour), token ORDER BY gs.hour DESC) AS dayrank
FROM
(
SELECT *,
lead(hour, 1, now() ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour
FROM
(
SELECT
DATE_TRUNC('hour',block_time) AS hour,
token, symbol,
percentile_cont(0.5) WITHIN GROUP (ORDER BY token_price) AS median_price,
COUNT(*) AS num_samples
FROM (
    SELECT --tokena
    t.block_time, t.exchange_contract_address,
    ea.symbol,
    t.token_a_address AS token, --t.token_b_address,
    t.token_a_amount_raw/(10^ea.decimals) AS token_amount,
    --t.token_b_amount_raw/(10^eb.decimals) AS token_b_amount,
    t.usd_amount,
    t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_price--,
    --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_b_price
    FROM dex.trades t
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
    t.""exchange_contract_address"" = p.pool
    INNER JOIN erc20.""tokens"" ea --both need to have known decimals, we're not going to assume anything.
    ON ea.""contract_address"" = t.token_a_address
    --INNER JOIN erc20.""tokens"" eb
    --ON eb.""contract_address"" = t.token_b_address
    WHERE project = 'Uniswap' AND version = '3'
    AND t.block_time >= '2021-05-04'
    AND 10^decimals > 0
    AND t.token_a_amount_raw > 100 --min to exclude weird stuff
    AND t.block_time >= DATE_TRUNC('day',now()) - interval '{{Trailing Num Days}} days'
    AND usd_amount > 0
    
    UNION ALL
    
    SELECT --tokenb
    t.block_time, t.exchange_contract_address,
    eb.symbol,
    --t.token_a_address,
    t.token_b_address AS token,
    --t.token_a_amount_raw/(10^ea.decimals) AS token_a_amount,
    t.token_b_amount_raw/(10^eb.decimals) AS token_amount,
    t.usd_amount,
    --t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_a_price,
    t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_price
    FROM dex.trades t
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
    t.""exchange_contract_address"" = p.pool
    --INNER JOIN erc20.""tokens"" ea --both need to have known decimals, we're not going to assume anything.
    --ON ea.""contract_address"" = t.token_a_address
    INNER JOIN erc20.""tokens"" eb
    ON eb.""contract_address"" = t.token_b_address
    WHERE project = 'Uniswap' AND version = '3'
    AND t.block_time >= '2021-05-04'
    AND 10^decimals > 0
    AND t.token_b_amount_raw > 100 --min to exclude weird stuff
    AND t.block_time >= DATE_TRUNC('day',now()) - interval '{{Trailing Num Days}} days'
    AND usd_amount > 0
) a
WHERE token_price > 0
GROUP BY 1,2,3

HAVING COUNT(*) > 3 -- need more than 3 samples to take the price
) b
) c
INNER JOIN gs_hr gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour
)
/*
,dex_price AS (
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
DATE_TRUNC('day',gs.hour) AS day_group,
gs.hour,
token, median_price,
DENSE_RANK() OVER(PARTITION BY DATE_TRUNC('day',gs.hour), token ORDER BY gs.hour DESC) AS dayrank
FROM
(
SELECT *,
lead(hour, 1, now() ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour
FROM
(
SELECT
DATE_TRUNC('hour',hour) AS hour,
token, median_price
FROM (
    SELECT ""hour"",""contract_address"" AS token,""median_price"", --DENSE_RANK() OVER (PARTITION BY DATE_TRUNC('day',hour) ORDER BY hour DESC) AS hrank
    FROM dex.""view_token_prices"" t
    
    WHERE
    hour >= DATE_TRUNC('day',now()) - interval '{{Trailing Num Days}} days' - interval '7 days' --buffer
    --AND NOT IN (SELECT contract_address FROM prices.usd p)
    AND ""contract_address"" IN (SELECT ""token0"" FROM uniswap_v3.""Factory_evt_PoolCreated""
                                UNION ALL SELECT ""token1"" FROM uniswap_v3.""Factory_evt_PoolCreated"")
    AND sample_size >=10
) a
WHERE median_price > 0
--AND hrank = 1

GROUP BY 1,2,3
) b
) c
INNER JOIN gs_hr gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour
)*/


,volume_and_fees AS (
SELECT
DATE_TRUNC('day',""block_time"") AS day,
--t.""token_a_address"",t.""token_a_amount_raw"",t.""token_a_symbol"",
--t.""token_b_address"",t.""token_b_amount_raw"",t.""token_b_symbol"",
""exchange_contract_address"",
a.fee,
SUM(""usd_amount"") AS usd_volume,
SUM(""usd_amount"")
    *(a.""fee""/1e6) AS usd_fees,
COUNT(*) AS num_trades
FROM dex.trades t
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
ON a.pool = t.""exchange_contract_address""
LEFT JOIN erc20.""tokens"" ea
    ON t.""token_a_address"" = ea.""contract_address""
    AND ""usd_amount"" IS NULL
LEFT JOIN erc20.""tokens"" eb
    ON t.""token_b_address"" = eb.""contract_address""
    AND ea.""contract_address"" IS NULL
    AND ""usd_amount"" IS NULL

WHERE ""project"" = 'Uniswap' AND ""version"" = '3'
AND DATE_TRUNC('day',t.""block_time"") >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
AND t.exchange_contract_address IN (SELECT pool FROM uniswap_v3.""Factory_evt_PoolCreated"")
    
    

GROUP BY 1,2,3

HAVING SUM(""usd_amount"") > 0

)

,lp_daily_token_balances AS( --daily

SELECT 
gs.day,pool,token,
running_balance,
(CASE WHEN gs.day = e.day THEN daily_change ELSE 0 END) AS daily_change
FROM
( SELECT *
    FROM
    (
    SELECT
    day, pool, token, raw_value,
        lead(day, 1, now() ) OVER (PARTITION BY pool, token
                            ORDER BY day asc) AS next_day,
        SUM(raw_value) --when there's a true change
            OVER (PARTITION BY pool, token ORDER BY day ASC) AS running_balance,
        SUM(raw_value)
            OVER (PARTITION BY day,pool, token) AS daily_change --did it this way to make group by's easier
    FROM
    (
    SELECT
    day,
    exchange_contract_address AS pool, contract_address AS token,
    SUM(val) AS raw_value
    FROM (
         --get deposits into the lp pool
        SELECT 
        CASE WHEN DATE_TRUNC('day',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('day',e.""evt_block_time"")
            ELSE DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS day,
        ""to"" AS exchange_contract_address,
        e.""contract_address"", SUM(value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""to"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens

        GROUP BY 1,2,3
        
        UNION ALL
        
        SELECT 
        CASE WHEN DATE_TRUNC('day',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('day',e.""evt_block_time"")
            ELSE DATE_TRUNC('day',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 day'::interval
            END AS day,
        ""from"" AS exchange_contract_address,
        e.""contract_address"", SUM(-value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""from"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens
        
        GROUP BY 1,2,3
        
        ) a
    GROUP BY 1,2,3
    ) b
    ) c
    WHERE c.next_day >= DATE_TRUNC('day',NOW()) - interval '{{Trailing Num Days}} days'

) e
INNER JOIN gs
ON e.day <= gs.day
AND gs.day < e.next_day

)


,lp_tvl AS( --calculate tvl --daily

SELECT a.day, pool,

SUM(COALESCE(p.price, pb.median_price)*COALESCE(a.daily_change_raw,0)/(10^COALESCE(e.decimals,p.decimals))) AS total_daily_change,
SUM(COALESCE(p.price, pb.median_price)*COALESCE(a.running_balance_raw,0)/(10^COALESCE(e.decimals,p.decimals))) AS total_running_balance --# of tokens are in the LP
    
    
FROM ( -- maybe chunk this out where prices come in later
    SELECT
    d.day,
    d.pool,
    d.token,
    SUM(daily_change) AS daily_change_raw,
    SUM(running_balance) AS running_balance_raw
    FROM lp_daily_token_balances d
    
    WHERE d.day >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    GROUP BY 1,2,3
    
    ) a
    LEFT JOIN (SELECT * FROM prices WHERE dayrank = 1) p
    ON a.token = p.""contract_address""
    AND a.day = p.day_group
    
    LEFT JOIN erc20.""tokens"" e
    ON a.token = e.""contract_address""
    AND p.price IS NULL
    
    LEFT JOIN (SELECT * FROM dex_price WHERE dayrank = 1) pb
    ON a.token = pb.token
    AND p.price IS NULL
    AND a.day = pb.day_group

GROUP BY 1,2
)


, net_liq AS --hourly then agg
(
SELECT
DATE_TRUNC('day',hour) AS day,exchange_contract_address,
SUM(added_value_usd) AS total_liq_added, --also calling this liquidity volume
SUM(removed_value_usd) AS total_liq_removed,
SUM(net_value_usd) AS total_liq_net
FROM (
SELECT
a.hour, a.token, a.exchange_contract_address,
SUM(CASE WHEN value > 0 THEN value/(10^COALESCE(e.decimals,p.decimals)) ELSE 0 END) AS added_value_tokens,
SUM(CASE WHEN value < 0 THEN value/(10^COALESCE(e.decimals,p.decimals)) ELSE 0 END) AS removed_value_tokens,
SUM(value/(10^COALESCE(e.decimals,p.decimals))) AS net_value_tokens,

SUM(CASE WHEN value > 0 THEN COALESCE(p.price,pb.median_price)*(
    value/(10^COALESCE(e.decimals,p.decimals))
    ) ELSE 0 END) AS added_value_usd,
SUM(CASE WHEN value < 0 THEN COALESCE(p.price,pb.median_price)*(
    value/(10^COALESCE(e.decimals,p.decimals))
    )  ELSE 0 END) AS removed_value_usd,
SUM( COALESCE(p.price,pb.median_price)*(
    value/(10^COALESCE(e.decimals,p.decimals))
    ) ) AS net_value_usd

FROM
(
    SELECT --adds
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value,
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN
    ( --get all liquidity event txs // couldn't find a way to connect tokenID to pool - data is missing...
          SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_IncreaseLiquidity""
          WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_DecreaseLiquidity""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    ) l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""to""
    WHERE e.evt_block_time >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
    
    UNION ALL
    
    SELECT --removes
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value*(-1),
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN
    ( --get all liquidity event txs // couldn't find a way to connect tokenID to pool - data is missing...
          SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_IncreaseLiquidity""
            WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_DecreaseLiquidity""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '{{Trailing Num Days}} days')
    ) l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""from""
    WHERE e.evt_block_time >= DATE_TRUNC('day',now() - interval '{{Trailing Num Days}} days')
) a
LEFT JOIN prices p
    ON a.token = p.""contract_address""
    AND
    p.hour = a.hour
LEFT JOIN erc20.""tokens"" e
    ON a.token = e.""contract_address""
    AND p.price IS NULL
LEFT JOIN dex_price pb
    ON a.token = pb.token
    AND e.""contract_address"" = pb.token
    AND p.price IS NULL
    AND a.hour = pb.hour
GROUP BY 1,2,3
) d
GROUP BY 1,2

)


SELECT
--pair, fee_tier,CONCAT(pair,' - ', ROUND(fee_tier*100,2)::text,'%') AS pool_n,
CASE WHEN daily_trade_rank <= 15 THEN pair--CONCAT(pair,' - ', ROUND(fee_tier*100,2)::text,'%')
ELSE 'Other'
END AS pair_other,
day, trailing_days,
SUM(volume) AS volume,
SUM(fees) AS fees,
SUM(trades) AS trades,
SUM(tvl) AS tvl,
SUM(net_liq) AS net_liq,
SUM(fees)*365/SUM(tvl) AS fees_tvl_yr

FROM (

SELECT
CONCAT(
COALESCE( (CASE WHEN ea.symbol ='WETH' THEN 'ETH' ELSE ea.symbol END)
            ,REPLACE(p.""token0""::text,'\','0') )
,'/',
COALESCE( (CASE WHEN eb.symbol ='WETH' THEN 'ETH' ELSE eb.symbol END)
            ,REPLACE(p.""token1""::text,'\','0') )
) AS pair,
--p.fee/1e6 AS fee_tier,
day,
SUM(volume) AS volume,
SUM(fees) AS fees,
SUM(trades) AS trades,
SUM(tvl) AS tvl,
--SUM(fees_tvl_yr) AS,
SUM(net_liq) AS net_liq,
DENSE_RANK() OVER (ORDER BY day DESC) AS trailing_days,
DENSE_RANK() OVER(PARTITION BY day ORDER BY SUM(volume) DESC NULLS LAST) AS daily_trade_rank

FROM (
    SELECT l.day, l.pool, /*SUM(l.total_daily_change) AS daily_tvl_change,*/
    SUM(usd_volume) AS volume,
    SUM(usd_fees) AS fees,
    SUM(num_trades) AS trades,
    SUM(l.total_running_balance) AS tvl,
    (
        SUM(usd_fees)::decimal/SUM(l.total_running_balance)::decimal
    )*(365/*/{{Trailing Num Days}}::decimal*/) fees_tvl_yr,
    SUM(nl.total_liq_net) AS net_liq
    
    FROM lp_tvl l
    LEFT JOIN volume_and_fees vf
    ON vf.day = l.day
    AND vf.""exchange_contract_address"" = l.pool
    
    LEFT JOIN net_liq nl
    ON nl.day = l.day
    AND nl.exchange_contract_address = l.pool
    
    GROUP BY 1,2
    ORDER BY day DESC
) a
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
    a.pool = p.pool
LEFT JOIN erc20.""tokens"" ea
    ON ea.""contract_address"" = p.""token0""
LEFT JOIN erc20.""tokens"" eb
    ON eb.""contract_address"" = p.""token1""

GROUP BY 1,2
) b
GROUP BY 1,2,3
--,4,5,6

ORDER BY day DESC, SUM(volume) DESC NULLS LAST"
88408,"Uniswap v3  Volume, Fees, TVL - Optimism (gas) - 24H",,table,"-- Eth Data
WITH dex_trades AS (
SELECT --pulled from eth dex_trades abstraction: https://github.com/duneanalytics/abstractions/blob/master/ethereum/dex/trades/insert_uniswap.sql
            t.evt_block_time AS block_time,
            'Uniswap' AS project,
            '3' AS version,
            'DEX' AS category,
            t.""recipient"" AS trader_a,
            NULL::bytea AS trader_b,
            abs(amount0) AS token_a_amount_raw,
            abs(amount1) AS token_b_amount_raw,
            NULL::numeric AS usd_amount,
            f.token0 AS token_a_address,
            f.token1 AS token_b_address,
            t.contract_address as exchange_contract_address,
            t.evt_tx_hash AS tx_hash,
            NULL::integer[] AS trace_address,
            t.evt_index
        FROM
            uniswap_v3.""Pair_evt_Swap"" t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" f ON f.pool = t.contract_address
),
erc20_tokens AS (
--Sourcing from UNI Info tokens page: https://info.uniswap.org/#/optimism/tokens
SELECT contract_address::bytea, symbol::text, decimals::decimal
FROM
    (values
        ('\x4200000000000000000000000000000000000006','ETH',18),
        ('\xda10009cbd5d07dd0cecc66161fc93d7c9000da1','DAI',18),
        ('\x68f180fcce6836688e9084f035309e29bf0a2095','WBTC',8),
        ('\x94b008aa00579c1307b0ef2c499ad98a8ce58e58','USDT',6),
        ('\x8700daec35af8ff88c16bdf0418774cb3d7599b4','SNX',18),
        ('\x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9','sUSD',18),
        ('\x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6','LINK',18)
    ) a (contract_address, symbol, decimals)
)

,erc20_ERC20_evt_Transfer AS ( --h/t: https://ethereumdev.io/explore-ethereum-data-with-sql-queries-on-dune-analytics/
SELECT l.contract_address,
l.""tx_hash"" AS evt_tx_hash,
l.block_time AS evt_block_time,
substring(topic2, 13, 20)::bytea AS ""from"",
substring(topic3, 13, 20)::bytea AS ""to"",
bytea2numeric(data) AS value  FROM optimism.""logs"" l

INNER JOIN (SELECT DISTINCT exchange_contract_address FROM dex_trades) e
ON substring(topic3, 13, 20)::bytea = e.exchange_contract_address


WHERE ""topic1"" = '\xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef' --erc20transfer


UNION --some duplications if tx's are batching transfers between pools

SELECT l.contract_address,
l.""tx_hash"" AS evt_tx_hash,
l.block_time AS evt_block_time,
substring(topic2, 13, 20)::bytea AS ""from"",
substring(topic3, 13, 20)::bytea AS ""to"",
bytea2numeric(data) AS value  FROM optimism.""logs"" l

INNER JOIN (SELECT DISTINCT exchange_contract_address FROM dex_trades) e
ON substring(topic2, 13, 20)::bytea = e.exchange_contract_address


WHERE ""topic1"" = '\xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef' --erc20transfer

    
)

,gs AS (
    SELECT generate_series('2021-07-08'::TIMESTAMP, date_trunc('hour', NOW()), '1 hour') AS day
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
gs.day,
token, symbol,
median_price
FROM
(
SELECT *,
lead(day, 1, now() ) OVER (PARTITION BY token
                            ORDER BY day asc) AS next_day
FROM
(
SELECT
DATE_TRUNC('hour',block_time) AS day,
token, symbol,
CASE WHEN symbol IN ('DAI','USDT') THEN 1
ELSE percentile_cont(0.5) WITHIN GROUP (ORDER BY token_price)
END AS median_price
FROM (
    SELECT *,
    usd_amount/token_amount AS token_price
    FROM
    (
        SELECT --tokena
        t.block_time, t.exchange_contract_address,
        ea.symbol,
        t.token_a_address AS token, --t.token_b_address,
        t.token_a_amount_raw/(10^ea.decimals) AS token_amount,
        --t.token_b_amount_raw/(10^eb.decimals) AS token_b_amount,
        CASE WHEN eb.symbol IN ('USDT','DAI') THEN --assume price = 1
            t.token_b_amount_raw/(10^eb.decimals) ELSE NULL
            END AS usd_amount
        /*t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_price--,
        --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_b_price*/
        FROM dex_trades t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
        t.""exchange_contract_address"" = p.pool
        INNER JOIN erc20_tokens ea --both need to have known decimals, we're not going to assume anything.
        ON ea.""contract_address"" = t.token_a_address
        INNER JOIN erc20_tokens eb
        ON eb.""contract_address"" = t.token_b_address
        WHERE project = 'Uniswap' AND version = '3'
        AND t.block_time >= '2021-07-08'
        --AND 10^decimals > 0
        AND t.token_a_amount_raw > 0
        AND block_time > now() - interval '24 hours'
    ) tokena
    
    UNION ALL
    
    SELECT *,
    usd_amount/token_amount AS token_price
    FROM
    (
        SELECT --tokenb
        t.block_time, t.exchange_contract_address,
        eb.symbol,
        --t.token_a_address,
        t.token_b_address AS token,
        --t.token_a_amount_raw/(10^ea.decimals) AS token_a_amount,
        t.token_b_amount_raw/(10^eb.decimals) AS token_amount,
        CASE WHEN ea.symbol IN ('USDT','DAI') THEN --assume price = 1
        t.token_a_amount_raw/(10^ea.decimals) ELSE NULL
        END AS usd_amount/*,
        --t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_a_price,
        --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_price*/
        FROM dex_trades t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
        t.""exchange_contract_address"" = p.pool
        INNER JOIN erc20_tokens ea --both need to have known decimals, we're not going to assume anything.
        ON ea.""contract_address"" = t.token_a_address
        INNER JOIN erc20_tokens eb
        ON eb.""contract_address"" = t.token_b_address
        WHERE project = 'Uniswap' AND version = '3'
        AND t.block_time >= '2021-07-08'
        --AND 10^decimals > 0
        AND t.token_b_amount_raw > 0
        AND block_time > now() - interval '24 hours'
    ) tokenb
) a
WHERE token_price > 0
GROUP BY 1,2,3

UNION --to prefill with stables
SELECT '2021-07-08 00:00','\xda10009cbd5d07dd0cecc66161fc93d7c9000da1','DAI',1
UNION
SELECT '2021-07-08 00:00','\x94b008aa00579c1307b0ef2c499ad98a8ce58e58','USDT',1
) b

) c
INNER JOIN gs
ON c.day <= gs.day
AND gs.day < c.next_day


)
-- GAS LIMIT ON OPTIMISM
-- https://community.optimism.io/docs/developers/fees.html#fees-for-l2-transactions
/*
Just like on Ethereum, fees on Optimistic Ethereum are denominated in ETH. The formula for gas cost on Ethereum is:

fee = transaction.gasPrice * gasUsed
However, the formula for gas cost on Optimistic Ethereum is:

fee = transaction.gasPrice * transaction.gasLimit (⇐ this part is different)
*/
,gas AS
(
SELECT 
DATE_TRUNC('hour',t.block_time) AS hour,
(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price))/1e9 AS median_gwei,
(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price*""gas_limit"")) AS median_gas_used,
(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price*e.""gas_limit""))/1e18 AS median_gas_used_eth,
((PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price*e.""gas_limit""*p.median_price))/1e18) AS median_gas_used_usd,
COUNT(*) AS num_trades
FROM dex_trades t
INNER JOIN optimism.""transactions"" e
ON e.""hash"" = t.""tx_hash"" 
--AND e.""block_time"" = t.""block_time""
INNER JOIN dex_price p
ON p.day = DATE_TRUNC('hour',t.block_time)
AND p.symbol = 'ETH'
--AND p.minute = DATE_TRUNC('minute',e.block_time)

WHERE t.""project"" = 'Uniswap' AND t.""version"" = '3'
AND t.block_time >= '2021-05-04'
AND e.block_time >= '2021-05-04'
AND p.day >= '2021-05-04'
AND DATE_TRUNC('minute',t.""block_time"") > DATE_TRUNC('minute',now() - interval '24 hours')
AND DATE_TRUNC('minute',p.""day"") > DATE_TRUNC('minute',now() - interval '24 hours')
AND DATE_TRUNC('minute',e.""block_time"") > DATE_TRUNC('minute',now() - interval '24 hours')

GROUP BY 1
)

SELECT * FROM gas



"
88483,Uniswap v3 - Ethereum (Gas),,table,"WITH
gas AS
(
SELECT 
DATE_TRUNC('day',t.evt_block_time) AS day,
(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price))/1e9 AS median_gwei,
(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price*e.""gas_used"")) AS median_gas_used,
(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price*e.""gas_used""))/1e18 AS median_gas_used_eth,
((PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price*e.""gas_used""*p.price))/1e18) AS median_gas_used_usd

FROM uniswap_v3.""Pair_evt_Swap"" t
INNER JOIN ethereum.""transactions"" e
    ON e.""hash"" = t.""evt_tx_hash"" 
    AND t.""evt_block_time"" > DATE_TRUNC('minute',now() - interval '{{Trailing Num Days}} days')
    AND e.""block_time"" > DATE_TRUNC('minute',now() - interval '{{Trailing Num Days}} days')
--AND e.""block_time"" = t.""block_time""
INNER JOIN prices.""layer1_usd_eth"" p
ON p.minute = DATE_TRUNC('minute',t.evt_block_time)
--AND p.minute = DATE_TRUNC('minute',e.block_time)

WHERE /*t.""project"" = 'Uniswap' AND t.""version"" = '3'
AND */ e.hash IN (SELECT evt_tx_hash FROM uniswap_v3.""Pair_evt_Swap"" WHERE ""evt_block_time"" > DATE_TRUNC('minute',now() - interval '{{Trailing Num Days}} days') )
AND e.""to"" IN (SELECT ""address"" FROM ethereum.""contracts"" WHERE ""namespace"" = 'uniswap_v3')
-- AND t.block_time >= '2021-05-04'
-- AND e.block_time >= '2021-05-04'
-- AND p.minute >= '2021-05-04'
AND ABS(t.""amount0"")/*""token_a_amount""*/ > 1000000
AND ABS(t.""amount1"")/*""token_b_amount""*/ > 1000000
AND t.""evt_block_time"" > DATE_TRUNC('minute',now() - interval '{{Trailing Num Days}} days')
AND p.""minute"" > DATE_TRUNC('minute',now() - interval '{{Trailing Num Days}} days')
AND e.""block_time"" > DATE_TRUNC('minute',now() - interval '{{Trailing Num Days}} days')

GROUP BY 1
)

SELECT * FROM gas
ORDER BY day DESC"
87950,"Uniswap v3  Volume, Fees, TVL - Ethereum (Gas) - 24H",,table,"WITH
gas AS
(
SELECT 
DATE_TRUNC('hour',t.block_time) AS hour,
(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price))/1e9 AS median_gwei,
(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price*e.""gas_used"")) AS median_gas_used,
(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price*e.""gas_used""))/1e18 AS median_gas_used_eth,
((PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price*e.""gas_used""*p.price))/1e18) AS median_gas_used_usd

FROM dex.trades t
INNER JOIN ethereum.""transactions"" e
ON e.""hash"" = t.""tx_hash"" 
--AND e.""block_time"" = t.""block_time""
INNER JOIN prices.""layer1_usd_eth"" p
ON p.minute = DATE_TRUNC('minute',t.block_time)
--AND p.minute = DATE_TRUNC('minute',e.block_time)

WHERE t.""project"" = 'Uniswap' AND t.""version"" = '3'
AND e.""to"" IN (SELECT ""address"" FROM ethereum.""contracts"" c WHERE c.namespace = 'uniswap_v3')
AND t.block_time >= '2021-05-04'
AND e.block_time >= '2021-05-04'
AND p.minute >= '2021-05-04'
AND t.""token_a_amount"" > 0
AND t.""token_b_amount"" > 0
AND DATE_TRUNC('minute',t.""block_time"") > DATE_TRUNC('minute',now() - interval '24 hours')
AND DATE_TRUNC('minute',p.""minute"") > DATE_TRUNC('minute',now() - interval '24 hours')
AND DATE_TRUNC('minute',e.""block_time"") > DATE_TRUNC('minute',now() - interval '24 hours')

GROUP BY 1
)

SELECT * FROM gas
ORDER BY hour DESC"
88480,"Uniswap v3  Volume, Fees, TVL - Optimism (gas)",,table,"-- Eth Data
WITH dex_trades AS (
SELECT --pulled from eth dex_trades abstraction: https://github.com/duneanalytics/abstractions/blob/master/ethereum/dex/trades/insert_uniswap.sql
            t.evt_block_time AS block_time,
            'Uniswap' AS project,
            '3' AS version,
            'DEX' AS category,
            t.""recipient"" AS trader_a,
            NULL::bytea AS trader_b,
            abs(amount0) AS token_a_amount_raw,
            abs(amount1) AS token_b_amount_raw,
            NULL::numeric AS usd_amount,
            f.token0 AS token_a_address,
            f.token1 AS token_b_address,
            t.contract_address as exchange_contract_address,
            t.evt_tx_hash AS tx_hash,
            NULL::integer[] AS trace_address,
            t.evt_index
        FROM
            uniswap_v3.""Pair_evt_Swap"" t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" f ON f.pool = t.contract_address
)

,erc20_ERC20_evt_Transfer AS ( --h/t: https://ethereumdev.io/explore-ethereum-data-with-sql-queries-on-dune-analytics/
SELECT l.contract_address,
l.""tx_hash"" AS evt_tx_hash,
l.block_time AS evt_block_time,
substring(topic2, 13, 20)::bytea AS ""from"",
substring(topic3, 13, 20)::bytea AS ""to"",
bytea2numeric(data) AS value  FROM optimism.""logs"" l

INNER JOIN (SELECT DISTINCT exchange_contract_address FROM dex_trades) e
ON substring(topic3, 13, 20)::bytea = e.exchange_contract_address


WHERE ""topic1"" = '\xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef' --erc20transfer


UNION --some duplications if tx's are batching transfers between pools

SELECT l.contract_address,
l.""tx_hash"" AS evt_tx_hash,
l.block_time AS evt_block_time,
substring(topic2, 13, 20)::bytea AS ""from"",
substring(topic3, 13, 20)::bytea AS ""to"",
bytea2numeric(data) AS value  FROM optimism.""logs"" l

INNER JOIN (SELECT DISTINCT exchange_contract_address FROM dex_trades) e
ON substring(topic2, 13, 20)::bytea = e.exchange_contract_address


WHERE ""topic1"" = '\xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef' --erc20transfer

    
)

,gs AS (
    SELECT generate_series('2021-07-08'::TIMESTAMP, date_trunc('day', NOW()), '1 day') AS day
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last day of swaps (6 hr if no swaps in the last day)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
gs.day,
token, symbol,
median_price
FROM
(
SELECT *,
lead(day, 1, now() ) OVER (PARTITION BY token
                            ORDER BY day asc) AS next_day
FROM
(
SELECT
DATE_TRUNC('day',block_time) AS day,
token, symbol,
CASE WHEN symbol IN ('DAI','USDT') THEN 1
ELSE percentile_cont(0.5) WITHIN GROUP (ORDER BY token_price)
END AS median_price
FROM (
    SELECT *,
    usd_amount/token_amount AS token_price
    FROM
    (
        SELECT --tokena
        t.block_time, t.exchange_contract_address,
        ea.symbol,
        t.token_a_address AS token, --t.token_b_address,
        t.token_a_amount_raw/(10^ea.decimals) AS token_amount,
        --t.token_b_amount_raw/(10^eb.decimals) AS token_b_amount,
        CASE WHEN eb.symbol IN ('USDT','DAI') THEN --assume price = 1
            t.token_b_amount_raw/(10^eb.decimals) ELSE NULL
            END AS usd_amount
        /*t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_price--,
        --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_b_price*/
        FROM dex_trades t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
        t.""exchange_contract_address"" = p.pool
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea --both need to have known decimals, we're not going to assume anything.
        ON ea.""contract_address"" = t.token_a_address
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
        ON eb.""contract_address"" = t.token_b_address
        WHERE project = 'Uniswap' AND version = '3'
        AND t.block_time >= '2021-07-13'
        --AND 10^decimals > 0
        AND t.token_a_amount_raw > 0
        AND block_time > now() - interval '{{Trailing Num Days}} days'
    ) tokena
    
    UNION ALL
    
    SELECT *,
    usd_amount/token_amount AS token_price
    FROM
    (
        SELECT --tokenb
        t.block_time, t.exchange_contract_address,
        eb.symbol,
        --t.token_a_address,
        t.token_b_address AS token,
        --t.token_a_amount_raw/(10^ea.decimals) AS token_a_amount,
        t.token_b_amount_raw/(10^eb.decimals) AS token_amount,
        CASE WHEN ea.symbol IN ('USDT','DAI') THEN --assume price = 1
        t.token_a_amount_raw/(10^ea.decimals) ELSE NULL
        END AS usd_amount/*,
        --t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_a_price,
        --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_price*/
        FROM dex_trades t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
        t.""exchange_contract_address"" = p.pool
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea --both need to have known decimals, we're not going to assume anything.
        ON ea.""contract_address"" = t.token_a_address
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
        ON eb.""contract_address"" = t.token_b_address
        WHERE project = 'Uniswap' AND version = '3'
        AND t.block_time >= '2021-07-08'
        --AND 10^decimals > 0
        AND t.token_b_amount_raw > 0
        AND block_time > now() - interval '{{Trailing Num Days}} days'
    ) tokenb
) a
WHERE token_price > 0
GROUP BY 1,2,3

UNION --to prefill with stables
SELECT '2021-07-08 00:00','\xda10009cbd5d07dd0cecc66161fc93d7c9000da1','DAI',1
UNION
SELECT '2021-07-08 00:00','\x94b008aa00579c1307b0ef2c499ad98a8ce58e58','USDT',1
) b

) c
INNER JOIN gs
ON c.day <= gs.day
AND gs.day < c.next_day


)
-- GAS LIMIT ON OPTIMISM
-- https://community.optimism.io/docs/developers/fees.html#fees-for-l2-transactions
/*
Just like on Ethereum, fees on Optimistic Ethereum are denominated in ETH. The formula for gas cost on Ethereum is:

fee = transaction.gasPrice * gasUsed
However, the formula for gas cost on Optimistic Ethereum is:

fee = transaction.gasPrice * transaction.gasLimit (⇐ this part is different)
*/
,gas AS
(
SELECT 
DATE_TRUNC('day',t.block_time) AS day,
(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price))/1e9 AS median_gwei,
(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price*""gas_limit"")) AS median_gas_used,
(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price*e.""gas_limit""))/1e18 AS median_gas_used_eth,
((PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY e.gas_price*e.""gas_limit""*p.median_price))/1e18) AS median_gas_used_usd

FROM dex_trades t
INNER JOIN optimism.""transactions"" e
ON e.""hash"" = t.""tx_hash"" 
--AND e.""block_time"" = t.""block_time""
INNER JOIN dex_price p
ON p.day = DATE_TRUNC('day',t.block_time)
AND p.symbol = 'ETH'
--AND p.minute = DATE_TRUNC('minute',e.block_time)

WHERE t.""project"" = 'Uniswap' AND t.""version"" = '3'
AND t.block_time >= '2021-05-04'
AND e.block_time >= '2021-05-04'
AND p.day >= '2021-05-04'
AND DATE_TRUNC('minute',t.""block_time"") > DATE_TRUNC('minute',now() - interval '{{Trailing Num Days}} days')
AND DATE_TRUNC('minute',p.""day"") > DATE_TRUNC('minute',now() - interval '{{Trailing Num Days}} days')
AND DATE_TRUNC('minute',e.""block_time"") > DATE_TRUNC('minute',now() - interval '{{Trailing Num Days}} days')

GROUP BY 1
)

SELECT * FROM gas



"
82973,"Uniswap v3  Volume, Fees, TVL - Optimism - T30D",,table,"-- Eth Data
WITH dex_trades AS (
SELECT --pulled from eth dex_trades abstraction: https://github.com/duneanalytics/abstractions/blob/master/ethereum/dex/trades/insert_uniswap.sql
            t.evt_block_time AS block_time,
            'Uniswap' AS project,
            '3' AS version,
            'DEX' AS category,
            t.""recipient"" AS trader_a,
            NULL::bytea AS trader_b,
            abs(amount0) AS token_a_amount_raw,
            abs(amount1) AS token_b_amount_raw,
            NULL::numeric AS usd_amount,
            f.token0 AS token_a_address,
            f.token1 AS token_b_address,
            t.contract_address as exchange_contract_address,
            t.evt_tx_hash AS tx_hash,
            NULL::integer[] AS trace_address,
            t.evt_index
        FROM
            uniswap_v3.""Pair_evt_Swap"" t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" f ON f.pool = t.contract_address
)


,gs AS (
    SELECT generate_series('2021-07-08'::TIMESTAMP, date_trunc('hour', NOW()), '1 hour') AS hour
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
gs.hour,
token, symbol,
CASE WHEN symbol IN ('DAI','USDT','USDC') THEN 1
ELSE median_price
END AS median_price
FROM
(
SELECT *,
lead(hour, 1, now() ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour
FROM
(
SELECT
DATE_TRUNC('hour',block_time) AS hour,
token, symbol,
percentile_cont(0.5) WITHIN GROUP (ORDER BY token_price) AS median_price
FROM (
    SELECT *,
    usd_amount/token_amount AS token_price
    FROM
    (
        SELECT --tokena
        t.block_time, t.exchange_contract_address,
        ea.symbol,
        t.token_a_address AS token, --t.token_b_address,
        t.token_a_amount_raw/(10^ea.decimals) AS token_amount,
        --t.token_b_amount_raw/(10^eb.decimals) AS token_b_amount,
        CASE WHEN eb.symbol IN ('DAI','USDT','USDC') THEN --assume price = 1
            t.token_b_amount_raw/(10^eb.decimals) ELSE NULL
            END AS usd_amount
        /*t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_price--,
        --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_b_price*/
        FROM dex_trades t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
        t.""exchange_contract_address"" = p.pool
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea --both need to have known decimals, we're not going to assume anything.
        ON ea.""contract_address"" = t.token_a_address
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
        ON eb.""contract_address"" = t.token_b_address
        WHERE project = 'Uniswap' AND version = '3'
        AND t.block_time >= '2021-07-08'
        --AND 10^decimals > 0
        AND t.token_a_amount_raw > 100 --min to exclude weird stuff
        AND block_time > now() - interval '30 days'
    ) tokena
    
    UNION ALL
    
    SELECT *,
    usd_amount/token_amount AS token_price
    FROM
    (
        SELECT --tokenb
        t.block_time, t.exchange_contract_address,
        eb.symbol,
        --t.token_a_address,
        t.token_b_address AS token,
        --t.token_a_amount_raw/(10^ea.decimals) AS token_a_amount,
        t.token_b_amount_raw/(10^eb.decimals) AS token_amount,
        CASE WHEN ea.symbol IN ('DAI','USDT','USDC') THEN --assume price = 1
        t.token_a_amount_raw/(10^ea.decimals) ELSE NULL
        END AS usd_amount/*,
        --t.usd_amount/(t.token_a_amount_raw/(10^ea.decimals)) AS token_a_price,
        --t.usd_amount/(t.token_b_amount_raw/(10^eb.decimals)) AS token_price*/
        FROM dex_trades t
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p ON
        t.""exchange_contract_address"" = p.pool
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea --both need to have known decimals, we're not going to assume anything.
        ON ea.""contract_address"" = t.token_a_address
        INNER JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
        ON eb.""contract_address"" = t.token_b_address
        WHERE project = 'Uniswap' AND version = '3'
        AND t.block_time >= '2021-07-08'
        --AND 10^decimals > 0
        AND t.token_b_amount_raw > 100 --min to exclude weird stuff
        AND block_time > now() - interval '30 days'
    ) tokenb
) a
WHERE token_price > 0
GROUP BY 1,2,3

UNION ALL

SELECT
    '01-01-2000' AS dt, token::bytea, symbol, 1 AS median_price
    FROM ( values
            ('\x7f5c764cbc14f9669b88837ca1490cca17c31607','USDC')
            ,('\x94b008aa00579c1307b0ef2c499ad98a8ce58e58','USDT')
            ,('\xda10009cbd5d07dd0cecc66161fc93d7c9000da1','DAI')
        ) t (token, symbol)
) b
) c
INNER JOIN gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour
)

,volume_and_fees AS ( --might not be pulling every trade?
SELECT
DATE_TRUNC('hour',""block_time"") AS hour,
--t.""token_a_address"",t.""token_a_amount_raw"",ea.symbol AS ""token_a_symbol"",--t.""token_a_symbol"",
--t.""token_b_address"",t.""token_b_amount_raw"",eb.symbol AS ""token_b_symbol"",--t.""token_b_symbol"",
""exchange_contract_address"",
a.fee,
SUM(COALESCE(""usd_amount"",
    (t.""token_a_amount_raw""/10^(ea.decimals))*pa.median_price,
    (t.""token_b_amount_raw""/10^(eb.decimals))*pb.median_price
    )) AS usd_volume,
SUM(COALESCE(""usd_amount"",
    (t.""token_a_amount_raw""/10^(ea.decimals))*pa.median_price,
    (t.""token_b_amount_raw""/10^(eb.decimals))*pb.median_price
    ))
    *(a.""fee""/1e6) AS usd_fees,
COUNT(*) AS num_trades
FROM dex_trades t
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
ON a.pool = t.""exchange_contract_address""
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list ea
    ON t.""token_a_address"" = ea.""contract_address""
    AND ""usd_amount"" IS NULL
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list eb
    ON t.""token_b_address"" = eb.""contract_address""
    AND ea.""contract_address"" IS NULL
    AND ""usd_amount"" IS NULL
LEFT JOIN dex_price pa
    ON t.""token_a_address"" = pa.token
    AND ea.""contract_address"" = pa.token
    AND ""usd_amount"" IS NULL
    AND DATE_TRUNC('hour',""block_time"") = pa.hour
    AND pa.hour >= DATE_TRUNC('hour',now() - interval '30 days')
LEFT JOIN dex_price pb
    ON t.""token_b_address"" = pb.token
    AND ea.""contract_address"" IS NULL
    AND eb.""contract_address"" = pb.token
    AND ""usd_amount"" IS NULL
    AND DATE_TRUNC('hour',""block_time"") = pb.hour
    AND pb.hour >= DATE_TRUNC('hour',now() - interval '30 days')

WHERE ""project"" = 'Uniswap' AND ""version"" = '3'
AND DATE_TRUNC('hour',t.""block_time"") >= DATE_TRUNC('hour',now() - interval '30 days')

GROUP BY 1,2,3

HAVING COUNT(*) > 0

)



,lp_daily_token_balances AS(

SELECT 
gs.hour,pool,token,
running_balance,
(CASE WHEN gs.hour = e.hour THEN daily_change ELSE 0 END) AS daily_change
FROM
( SELECT *
    FROM
    (
    SELECT
    hour, pool, token, raw_value,
        lead(hour, 1, now() ) OVER (PARTITION BY pool, token
                            ORDER BY hour asc) AS next_hour,
        SUM(raw_value) --when there's a true change
            OVER (PARTITION BY pool, token ORDER BY hour ASC) AS running_balance,
        SUM(raw_value)
            OVER (PARTITION BY hour,pool, token) AS daily_change --did it this way to make group by's easier
    FROM
    (
    SELECT
    hour,
    exchange_contract_address AS pool, contract_address AS token,
    SUM(val) AS raw_value
    FROM (
         --get deposits into the lp pool
        SELECT 
        CASE WHEN DATE_TRUNC('hour',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '30 days'::interval)
            THEN DATE_TRUNC('hour',e.""evt_block_time"")
            ELSE DATE_TRUNC('hour',NOW() ) - '30 days'::interval - '1 day'::interval
            END AS hour,
        ""to"" AS exchange_contract_address,
        e.""contract_address"", SUM(value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""to"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens

        GROUP BY 1,2,3
        
        UNION ALL
        
        SELECT 
        CASE WHEN DATE_TRUNC('hour',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '30 days'::interval)
            THEN DATE_TRUNC('hour',e.""evt_block_time"")
            ELSE DATE_TRUNC('hour',NOW() ) - '30 days'::interval - '1 day'::interval
            END AS hour,
        ""from"" AS exchange_contract_address,
        e.""contract_address"", SUM(-value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""from"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens
        
        GROUP BY 1,2,3
        
        ) a
    GROUP BY 1,2,3
    ) b
    ) c
    WHERE c.next_hour >= DATE_TRUNC('hour',NOW()) - interval '30 days'

) e
INNER JOIN gs
ON e.hour <= gs.hour
AND gs.hour < e.next_hour

)


,lp_tvl AS( --calculate tvl
SELECT a.hour, pool,

SUM(COALESCE(pb.median_price)*a.daily_change_raw/(10^COALESCE(e.decimals))) AS total_daily_change,
SUM(COALESCE(pb.median_price)*a.running_balance_raw/(10^COALESCE(e.decimals))) AS total_running_balance --# of tokens are in the LP
    
FROM (
    SELECT
    d.hour,
    d.pool,
    d.token,
    SUM(daily_change) AS daily_change_raw,
    SUM(running_balance) AS running_balance_raw
    FROM lp_daily_token_balances d
    
    WHERE d.hour >= DATE_TRUNC('hour',now() - interval '30 days')
    GROUP BY 1,2,3
    
    ) a
    LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list e
    ON a.token = e.""contract_address""
    --AND p.price IS NULL
    LEFT JOIN dex_price pb
    ON a.token = pb.token
    AND e.""contract_address"" = pb.token
    --AND p.price IS NULL
    AND a.hour = pb.hour
    AND pb.hour >= DATE_TRUNC('hour',now() - interval '30 days')
    
    WHERE a.hour >= DATE_TRUNC('hour',now() - interval '30 days')

GROUP BY 1,2
)

, net_liq AS
(
SELECT
hour,exchange_contract_address,
SUM(added_value_usd) AS total_liq_added, --also calling this liquidity volume
SUM(removed_value_usd) AS total_liq_removed,
SUM(net_value_usd) AS total_liq_net
FROM (
SELECT
a.hour, a.token, a.exchange_contract_address,
SUM(CASE WHEN value > 0 THEN value/(10^COALESCE(e.decimals)) ELSE 0 END) AS added_value_tokens,
SUM(CASE WHEN value < 0 THEN value/(10^COALESCE(e.decimals)) ELSE 0 END) AS removed_value_tokens,
SUM(value/(10^COALESCE(e.decimals))) AS net_value_tokens,

SUM(CASE WHEN value > 0 THEN COALESCE(pb.median_price)*(
    value/(10^COALESCE(e.decimals))
    ) ELSE 0 END) AS added_value_usd,
SUM(CASE WHEN value < 0 THEN COALESCE(pb.median_price)*(
    value/(10^COALESCE(e.decimals))
    )  ELSE 0 END) AS removed_value_usd,
SUM( COALESCE(pb.median_price)*(
    value/(10^COALESCE(e.decimals))
    ) ) AS net_value_usd

FROM
(
    SELECT --adds
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value,
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN
    ( --get all liquidity event txs // couldn't find a way to connect tokenID to pool - data is missing...
          SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_IncreaseLiquidity""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '30 days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '30 days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_DecreaseLiquidity""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '30 days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '30 days')
    ) l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""to""
    WHERE DATE_TRUNC('hour',e.evt_block_time) >= DATE_TRUNC('hour',now() - interval '30 days')
    
    UNION
    
    SELECT --removes
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value*(-1),
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN
    ( --get all liquidity event txs // couldn't find a way to connect tokenID to pool - data is missing...
          SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_IncreaseLiquidity""
            WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '30 days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '30 days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungiblePositionManager_evt_DecreaseLiquidity""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '30 days')
    UNION SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE DATE_TRUNC('hour',evt_block_time) >= DATE_TRUNC('hour',now() - interval '30 days')
    ) l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""from""
    WHERE DATE_TRUNC('hour',e.evt_block_time) >= DATE_TRUNC('hour',now() - interval '30 days')
) a
LEFT JOIN dune_user_generated.msilb7_optimism_univ3_token_list e
    ON a.token = e.""contract_address""
    --AND p.price IS NULL
    LEFT JOIN dex_price pb
    ON a.token = pb.token
    AND e.""contract_address"" = pb.token
    --AND p.price IS NULL
    AND a.hour = pb.hour
    AND pb.hour >= DATE_TRUNC('hour',now() - interval '30 days')
GROUP BY 1,2,3
) d
GROUP BY 1,2

)

, counting_stats AS (
SELECT *,
DENSE_RANK() OVER (ORDER BY hour DESC) AS hrank
FROM (
    SELECT l.hour, --SUM(l.total_daily_change) AS daily_tvl_change,
    SUM(usd_volume) AS volume,
    SUM(usd_fees) AS fees,
   SUM(l.total_running_balance) AS tvl,
   SUM(nl.total_liq_net) AS net_liq,
    (
        SUM(usd_fees)::decimal/SUM(l.total_running_balance)::decimal
    )*(365) fees_tvl_yr,
    SUM(num_trades) AS trades
    
    FROM lp_tvl l
    LEFT JOIN volume_and_fees vf
    ON vf.hour = l.hour
    AND vf.""exchange_contract_address"" = l.pool
    LEFT JOIN net_liq nl
    ON nl.hour = l.hour
    AND nl.exchange_contract_address = l.pool
    
    GROUP BY 1
    ORDER BY hour DESC
) a
)
,
trade_users AS (
SELECT

COUNT(DISTINCT CASE WHEN drank <=1 THEN trader ELSE NULL END) AS traders_24h,
COUNT(CASE WHEN drank <=1 THEN trader ELSE NULL END)/1 AS traders_24h_dau,

COUNT(DISTINCT CASE WHEN drank <=7 THEN trader ELSE NULL END) AS traders_7d, --over the course of 7 days, the distinct list
COUNT(CASE WHEN drank <=7 THEN trader ELSE NULL END)/7 AS traders_7d_dau, --sum the distinct daily trader list over 7 days, then divide by 7

COUNT(DISTINCT CASE WHEN drank <=30 THEN trader ELSE NULL END) AS traders_30d,
COUNT(CASE WHEN drank <=30 THEN trader ELSE NULL END)/30 AS traders_30d_dau

FROM (
    SELECT DISTINCT -- gives me the distinct list of traders per day
    trader_a AS trader,
    --DENSE_RANK() OVER(ORDER BY DATE_TRUNC('hour',""block_time"") DESC) AS hrank,
    CEIL((DENSE_RANK() OVER(ORDER BY DATE_TRUNC('hour',""block_time"") DESC))::decimal/24) AS drank
    FROM dex_trades
    WHERE project = 'Uniswap' AND version = '3'
    AND DATE_TRUNC('hour',""block_time"") >= DATE_TRUNC('hour',now() - interval '30 days')
    ) a
)

SELECT
'Last 24 Hours' AS time_period,
SUM(CASE WHEN hrank < 24 THEN volume ELSE 0 END) AS volume,
SUM(CASE WHEN hrank < 24 THEN volume ELSE 0 END)/1 AS volume_per_day,

SUM(CASE WHEN hrank < 24 THEN fees ELSE 0 END) AS fees,
SUM(CASE WHEN hrank < 24 THEN fees ELSE 0 END)/1 AS fees_per_day,

SUM(CASE WHEN hrank < 24 THEN net_liq ELSE 0 END) AS net_liq,
SUM(CASE WHEN hrank < 24 THEN net_liq ELSE 0 END)/1 AS net_liq_day,

SUM(CASE WHEN hrank = 1 THEN tvl ELSE 0 END) AS tvl_current,
'Current' AS tvl_desc,

AVG(traders_24h) AS traders_24h, --just avoiding a weird group by, it's always the same #
AVG(traders_24h_dau) AS traders_24h_dau,

SUM(CASE WHEN hrank < 24 THEN trades ELSE 0 END) AS trades,
SUM(CASE WHEN hrank < 24 THEN trades ELSE 0 END)/1 AS trades_per_day,
'Last 24 Hours' AS time_period2

FROM
counting_stats c, trade_users t

UNION ALL
SELECT
NULL::text,NULL::decimal,NULL::decimal,
NULL::decimal,NULL::decimal,NULL::decimal,
NULL::decimal,NULL::decimal,NULL::text,NULL::decimal,NULL::decimal,NULL::decimal,
NULL::decimal,NULL::text
UNION ALL

SELECT
'Last 7 Days' AS time_period,
SUM(CASE WHEN hrank < 24*7 THEN volume ELSE 0 END) AS volume,
SUM(CASE WHEN hrank < 24*7 THEN volume ELSE 0 END)/7 AS volume_per_day,

SUM(CASE WHEN hrank < 24*7 THEN fees ELSE 0 END) AS fees,
SUM(CASE WHEN hrank < 24*7 THEN fees ELSE 0 END)/7 AS fees_per_day,

SUM(CASE WHEN hrank < 24*7 THEN net_liq ELSE 0 END) AS net_liq,
SUM(CASE WHEN hrank < 24*7 THEN net_liq ELSE 0 END)/7 AS net_liq_day,

SUM(CASE WHEN hrank = (24*7)-1 THEN tvl ELSE 0 END) AS tvl_7dago,
'7D Ago' AS tvl_desc,

AVG(traders_7d) AS traders_7d, --just avoiding a weird group by, it's always the same #
AVG(traders_7d_dau) AS traders_7d_dau,

SUM(CASE WHEN hrank < 24*7 THEN trades ELSE 0 END) AS trades,
SUM(CASE WHEN hrank < 24*7 THEN trades ELSE 0 END)/7 AS trades_per_day,
'Last 7 Days' AS time_period

FROM
counting_stats c, trade_users t

UNION ALL
SELECT
NULL::text,NULL::decimal,NULL::decimal,
NULL::decimal,NULL::decimal,NULL::decimal,
NULL::decimal,NULL::decimal,NULL::text,NULL::decimal,NULL::decimal,NULL::decimal,
NULL::decimal,NULL::text
UNION ALL

SELECT
'Last 30 Days' AS time_period,
SUM(CASE WHEN hrank < 24*30 THEN volume ELSE 0 END) AS volume,
SUM(CASE WHEN hrank < 24*30 THEN volume ELSE 0 END)/30 AS volume_per_day,

SUM(CASE WHEN hrank < 24*30 THEN fees ELSE 0 END) AS fees,
SUM(CASE WHEN hrank < 24*30 THEN fees ELSE 0 END)/30 AS fees_per_day,

SUM(CASE WHEN hrank < 24*30 THEN net_liq ELSE 0 END) AS net_liq,
SUM(CASE WHEN hrank < 24*30 THEN net_liq ELSE 0 END)/30 AS net_liq_day,

SUM(CASE WHEN hrank = (24*30)-1 THEN tvl ELSE 0 END) AS tvl_30dago,
'30D Ago' AS tvl_desc,

AVG(traders_30d) AS traders_30d, --just avoiding a weird group by, it's always the same #
AVG(traders_30d_dau) AS traders_30d_dau,

SUM(CASE WHEN hrank < 24*30 THEN trades ELSE 0 END) AS trades,
SUM(CASE WHEN hrank < 24*30 THEN trades ELSE 0 END)/30 AS trades_per_day,
'Last 30 Days' AS time_period

FROM
counting_stats c, trade_users t"
82950,"Uniswap v3  Volume, Fees, TVL - Ethereum - T30D",,counter,"-- Eth Data
WITH
gs AS (
    SELECT generate_series(
        DATE_TRUNC('hour',now() - interval '31 days')
    ::TIMESTAMP, date_trunc('hour', NOW()), '1 hour') AS hour
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount

SELECT
gs.hour,
token, median_price, symbol, decimals
FROM
(
SELECT *,
lead(hour, 1, now() ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour
FROM
(
SELECT
DATE_TRUNC('hour',hour) AS hour,
token, median_price, symbol, decimals
FROM (
    SELECT ""hour"",""contract_address"" AS token,""median_price"", symbol, decimals
    FROM prices.""prices_from_dex_data"" t
    WHERE
    hour >= DATE_TRUNC('hour',now()) - interval '30 days'
    --AND NOT IN (SELECT contract_address FROM prices.usd p)
    AND ""contract_address"" IN (SELECT ""token0"" FROM uniswap_v3.""Factory_evt_PoolCreated""
                                UNION ALL SELECT ""token1"" FROM uniswap_v3.""Factory_evt_PoolCreated"")
    AND sample_size >=5
) a
WHERE median_price > 0
GROUP BY 1,2,3,4,5
) b
) c
INNER JOIN gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour
)


,volume_and_fees AS (
SELECT
DATE_TRUNC('hour',""block_time"") AS hour,
--t.""token_a_address"",t.""token_a_amount_raw"",t.""token_a_symbol"",
--t.""token_b_address"",t.""token_b_amount_raw"",t.""token_b_symbol"",
""exchange_contract_address"",
a.fee,
SUM(""usd_amount"") AS usd_volume,
SUM(""usd_amount"")
    *(a.""fee""/1e6) AS usd_fees,
COUNT(*) AS num_trades
FROM dex.trades t
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
ON a.pool = t.""exchange_contract_address""

WHERE ""project"" = 'Uniswap' AND ""version"" = '3'
AND DATE_TRUNC('hour',t.""block_time"") > DATE_TRUNC('hour',now() - interval '30 days')
AND t.exchange_contract_address IN (SELECT pool FROM uniswap_v3.""Factory_evt_PoolCreated"")
AND usd_amount > 0
    
GROUP BY 1,2,3

HAVING SUM(""usd_amount"") > 0

)

,lp_daily_token_balances AS(

SELECT 
gs.hour,pool,token,
running_balance,
(CASE WHEN gs.hour = e.hour THEN daily_change ELSE 0 END) AS daily_change
FROM
( SELECT *
    FROM
    (
    SELECT
    hour, pool, token, raw_value,
        lead(hour, 1, now() ) OVER (PARTITION BY pool, token
                            ORDER BY hour asc) AS next_hour,
        SUM(raw_value) --when there's a true change
            OVER (PARTITION BY pool, token ORDER BY hour ASC) AS running_balance,
        SUM(raw_value)
            OVER (PARTITION BY hour,pool, token) AS daily_change --did it this way to make group by's easier
    FROM
    (
    SELECT
    hour,
    exchange_contract_address AS pool, contract_address AS token,
    SUM(val) AS raw_value
    FROM (
         --get deposits into the lp pool
        SELECT 
        CASE WHEN DATE_TRUNC('hour',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '30 days'::interval)
            THEN DATE_TRUNC('hour',e.""evt_block_time"")
            ELSE DATE_TRUNC('hour',NOW() ) - '30 days'::interval - '1 day'::interval
            END AS hour,
        ""to"" AS exchange_contract_address,
        e.""contract_address"", SUM(value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""to"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens
        
        WHERE e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens
        
        GROUP BY 1,2,3
        
        UNION ALL
        
        SELECT 
        CASE WHEN DATE_TRUNC('hour',e.""evt_block_time"") >= (DATE_TRUNC('day',NOW() ) - '30 days'::interval)
            THEN DATE_TRUNC('hour',e.""evt_block_time"")
            ELSE DATE_TRUNC('hour',NOW() ) - '30 days'::interval - '1 day'::interval
            END AS hour,
        ""from"" AS exchange_contract_address,
        e.""contract_address"", SUM(-value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" t
        ON ""from"" = t.pool
        AND e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens
        
        WHERE e.""contract_address"" IN (t.""token0"", t.""token1"") --only get tvl of the 2 tokens
        GROUP BY 1,2,3
        
        ) a
    GROUP BY 1,2,3
    ) b
    ) c
    WHERE c.next_hour >= DATE_TRUNC('hour',NOW()) - interval '30 days'

) e
INNER JOIN gs
ON e.hour <= gs.hour
AND gs.hour < e.next_hour

)


,lp_tvl AS( --calculate tvl
SELECT a.hour, pool,

SUM(COALESCE(p.price, pb.median_price)*a.daily_change_raw/(10^COALESCE(p.decimals,pb.decimals))) AS total_daily_change,
SUM(COALESCE(p.price, pb.median_price)*a.running_balance_raw/(10^COALESCE(p.decimals,pb.decimals))) AS total_running_balance --# of tokens are in the LP
    
    
FROM ( -- maybe chunk this out where prices come in later
    SELECT
    d.hour,
    d.pool,
    d.token,
    SUM(daily_change) AS daily_change_raw,
    SUM(running_balance) AS running_balance_raw
    FROM lp_daily_token_balances d
    
    WHERE d.hour > DATE_TRUNC('hour',now() - interval '30 days')
    GROUP BY 1,2,3
    
    ) a
    LEFT JOIN prices.""usd"" p
    ON a.token = p.""contract_address""
    AND
    p.""minute"" = a.hour
    AND p.""minute"" >
        DATE_TRUNC('hour',now() - interval '30 days')
        
    LEFT JOIN dex_price pb
    ON a.token = pb.token
        AND p.price IS NULL
        AND a.hour = pb.hour
        AND pb.hour > DATE_TRUNC('hour',now() - interval '30 days')

GROUP BY 1,2
)

,lp_events AS (
SELECT evt_tx_hash
    FROM (
          SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_IncreaseLiquidity""
          WHERE DATE_TRUNC('hour',evt_block_time) > DATE_TRUNC('hour',now() - interval '30 days')
    UNION ALL SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Mint""
        WHERE DATE_TRUNC('hour',evt_block_time) > DATE_TRUNC('hour',now() - interval '30 days')
     UNION ALL SELECT ""evt_tx_hash"" FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_DecreaseLiquidity""
        WHERE DATE_TRUNC('hour',evt_block_time) > DATE_TRUNC('hour',now() - interval '30 days')
     UNION ALL SELECT ""evt_tx_hash"" FROM uniswap_v3.""Pair_evt_Burn""
        WHERE DATE_TRUNC('hour',evt_block_time) > DATE_TRUNC('hour',now() - interval '30 days')
        ) a
        GROUP BY 1 --distinct txs
)

, net_liq AS
(
SELECT
hour,exchange_contract_address,
SUM(added_value_usd) AS total_liq_added, --also calling this liquidity volume
SUM(removed_value_usd) AS total_liq_removed,
SUM(net_value_usd) AS total_liq_net
FROM (
SELECT
a.hour, a.token, a.exchange_contract_address,
SUM(CASE WHEN value > 0 THEN value/(10^COALESCE(p.decimals,pb.decimals)) ELSE 0 END) AS added_value_tokens,
SUM(CASE WHEN value < 0 THEN value/(10^COALESCE(p.decimals,pb.decimals)) ELSE 0 END) AS removed_value_tokens,
SUM(value/(10^COALESCE(p.decimals,pb.decimals))) AS net_value_tokens,

SUM(CASE WHEN value > 0 THEN COALESCE(p.price,pb.median_price)*(
    value/(10^COALESCE(p.decimals,pb.decimals))
    ) ELSE 0 END) AS added_value_usd,
SUM(CASE WHEN value < 0 THEN COALESCE(p.price,pb.median_price)*(
    value/(10^COALESCE(p.decimals,pb.decimals))
    )  ELSE 0 END) AS removed_value_usd,
SUM( COALESCE(p.price,pb.median_price)*(
    value/(10^COALESCE(p.decimals,pb.decimals))
    ) ) AS net_value_usd

FROM
(
    SELECT --adds
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value,
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN lp_events l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""to""
    WHERE DATE_TRUNC('hour',e.evt_block_time) > DATE_TRUNC('hour',now() - interval '30 days')
    
    UNION ALL
    
    SELECT --removes
    e.contract_address as token, e.evt_tx_hash, e.evt_block_time, e.""from"",e.""to"",e.value*(-1),
    DATE_TRUNC('hour',e.evt_block_time) AS hour,
    a.""pool"" AS exchange_contract_address
    FROM erc20.""ERC20_evt_Transfer"" e
    INNER JOIN lp_events l
    ON e.evt_tx_hash = l.evt_tx_hash
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" a
    ON a.""pool"" = e.""from""
    WHERE DATE_TRUNC('hour',e.evt_block_time) > DATE_TRUNC('hour',now() - interval '30 days')
) a
LEFT JOIN prices.""usd"" p
    ON a.token = p.""contract_address""
    AND
    p.""minute"" =
        (CASE WHEN a.hour = DATE_TRUNC('hour',now()) THEN a.hour --if today, then start of day price
        ELSE a.hour + interval '1 hour' --else eod price of the day picked
        END)
    AND p.""minute"" >
        DATE_TRUNC('hour',now() - interval '30 days')

LEFT JOIN dex_price pb
    ON a.token = pb.token
    AND p.price IS NULL
    AND a.hour = pb.hour
    AND pb.hour > DATE_TRUNC('hour',now() - interval '30 days')
    
GROUP BY 1,2,3
) d
GROUP BY 1,2

)

, counting_stats AS (
SELECT *,
DENSE_RANK() OVER(ORDER BY hour DESC) AS hrank
FROM (
    SELECT l.hour, /*SUM(l.total_daily_change) AS daily_tvl_change,*/
    SUM(usd_volume) AS volume,
    SUM(usd_fees) AS fees,
    SUM(l.total_running_balance) AS tvl,
    SUM(total_liq_net) AS net_liq,
    (
        SUM(usd_fees)::decimal/SUM(l.total_running_balance)::decimal
    )*(365) fees_tvl_yr,
    SUM(num_trades) AS trades
    FROM lp_tvl l
    LEFT JOIN volume_and_fees vf
    ON vf.hour = l.hour
    AND vf.""exchange_contract_address"" = l.pool
    LEFT JOIN net_liq nl
    ON nl.hour = l.hour
    AND nl.exchange_contract_address = l.pool
    GROUP BY 1
    ) a
)
,
trade_users AS (
SELECT

COUNT(DISTINCT CASE WHEN drank <=1 THEN trader ELSE NULL END) AS traders_24h,
COUNT(CASE WHEN drank <=1 THEN trader ELSE NULL END)/1 AS traders_24h_dau,

COUNT(DISTINCT CASE WHEN drank <=7 THEN trader ELSE NULL END) AS traders_7d, --over the course of 7 days, the distinct list
COUNT(CASE WHEN drank <=7 THEN trader ELSE NULL END)/7 AS traders_7d_dau, --sum the distinct daily trader list over 7 days, then divide by 7

COUNT(DISTINCT CASE WHEN drank <=30 THEN trader ELSE NULL END) AS traders_30d,
COUNT(CASE WHEN drank <=30 THEN trader ELSE NULL END)/30 AS traders_30d_dau

FROM (
    SELECT DISTINCT -- gives me the distinct list of traders per day
    trader_a AS trader,
    --DENSE_RANK() OVER(ORDER BY DATE_TRUNC('hour',""block_time"") DESC) AS hrank,
    CEIL((DENSE_RANK() OVER(ORDER BY DATE_TRUNC('hour',""block_time"") DESC))::decimal/24) AS drank
    FROM dex.trades
    WHERE project = 'Uniswap' AND version = '3'
    AND DATE_TRUNC('hour',""block_time"") > DATE_TRUNC('hour',now() - interval '30 days')
    ) a
)

SELECT
'Last 24 Hours' AS time_period,
SUM(CASE WHEN hrank < 24 THEN volume ELSE 0 END) AS volume,
SUM(CASE WHEN hrank < 24 THEN volume ELSE 0 END)/1 AS volume_per_day,

SUM(CASE WHEN hrank < 24 THEN fees ELSE 0 END) AS fees,
SUM(CASE WHEN hrank < 24 THEN fees ELSE 0 END)/1 AS fees_per_day,

SUM(CASE WHEN hrank < 24 THEN net_liq ELSE 0 END) AS net_liq,
SUM(CASE WHEN hrank < 24 THEN net_liq ELSE 0 END)/1 AS net_liq_day,

SUM(CASE WHEN hrank = 1 THEN tvl ELSE 0 END) AS tvl,
'Current' AS tvl_desc,

AVG(traders_24h) AS traders_24h, --just avoiding a weird group by, it's always the same #
AVG(traders_24h_dau) AS traders_24h_dau,

SUM(CASE WHEN hrank < 24 THEN trades ELSE 0 END) AS trades,
SUM(CASE WHEN hrank < 24 THEN trades ELSE 0 END)/1 AS trades_per_day,
'Last 24 Hours' AS time_period2

FROM
counting_stats c, trade_users t

UNION ALL
SELECT
NULL::text,NULL::decimal,NULL::decimal,
NULL::decimal,NULL::decimal,NULL::decimal,
NULL::decimal,NULL::decimal,NULL::text,NULL::decimal,NULL::decimal,
NULL::decimal,NULL::decimal,NULL::text
UNION ALL

SELECT
'Last 7 Days' AS time_period,
SUM(CASE WHEN hrank < 24*7 THEN volume ELSE 0 END) AS volume,
SUM(CASE WHEN hrank < 24*7 THEN volume ELSE 0 END)/7 AS volume_per_day,

SUM(CASE WHEN hrank < 24*7 THEN fees ELSE 0 END) AS fees,
SUM(CASE WHEN hrank < 24*7 THEN fees ELSE 0 END)/7 AS fees_per_day,


SUM(CASE WHEN hrank < 24*7 THEN net_liq ELSE 0 END) AS net_liq,
SUM(CASE WHEN hrank < 24*7 THEN net_liq ELSE 0 END)/7 AS net_liq_day,

SUM(CASE WHEN hrank = (24*7)-1 THEN tvl ELSE 0 END) AS tvl,
'7D Ago' AS tvl_desc,

AVG(traders_7d) AS traders_7d, --just avoiding a weird group by, it's always the same #
AVG(traders_7d_dau) AS traders_7d_dau,

SUM(CASE WHEN hrank < 24*7 THEN trades ELSE 0 END) AS trades,
SUM(CASE WHEN hrank < 24*7 THEN trades ELSE 0 END)/7 AS trades_per_day,
'Last 7 Days' AS time_period2

FROM
counting_stats c, trade_users t

UNION ALL
SELECT
NULL::text,NULL::decimal,NULL::decimal,
NULL::decimal,NULL::decimal,NULL::decimal,
NULL::decimal,NULL::decimal,NULL::text,NULL::decimal,NULL::decimal,NULL::decimal,
NULL::decimal,NULL::text
UNION ALL

SELECT
'Last 30 Days' AS time_period,
SUM(CASE WHEN hrank < 24*30 THEN volume ELSE 0 END) AS volume,
SUM(CASE WHEN hrank < 24*30 THEN volume ELSE 0 END)/30 AS volume_per_day,

SUM(CASE WHEN hrank < 24*30 THEN fees ELSE 0 END) AS fees,
SUM(CASE WHEN hrank < 24*30 THEN fees ELSE 0 END)/30 AS fees_per_day,

SUM(CASE WHEN hrank < 24*30 THEN net_liq ELSE 0 END) AS net_liq,
SUM(CASE WHEN hrank < 24*30 THEN net_liq ELSE 0 END)/30 AS net_liq_day,

SUM(CASE WHEN hrank = (24*30)-1 THEN tvl ELSE 0 END) AS tvl_30dago,
'30D Ago' AS tvl_desc,

AVG(traders_30d) AS traders_30d, --just avoiding a weird group by, it's always the same #
AVG(traders_30d_dau) AS traders_30d_dau,

SUM(CASE WHEN hrank < 24*30 THEN trades ELSE 0 END) AS trades,
SUM(CASE WHEN hrank < 24*30 THEN trades ELSE 0 END)/30 AS trades_per_day,
'Last 30 Days' AS time_period2


FROM
counting_stats c, trade_users t

"
78325, Alpha Vaults (WETH-USDT) / Order Range,,chart,"/* get rebalance tx hash*/
WITH rebalancetxs AS(
    SELECT ""evt_tx_hash""
    FROM charm.""AlphaVault_evt_Snapshot""
    WHERE contract_address =  '\xE72f3E105e475D7Db3a003FfA377aFAe9c2c6c11'
)

/*  
    two mint events in one tx
    time, lowerTick, upperTick, range <- band order
    time, lowerTick, upperTick, range <- limit order
*/
,mint AS(
 SELECT
  position.""tickLower"" AS lowerTick,   
  position.""tickUpper"" AS UpperTick,  
  ABS(position.""tickLower"" - position.""tickUpper"") AS range,
  ""call_block_time"" AS Time 
 FROM uniswap_v3.""Pair_call_mint"" AS position, rebalancetxs
 WHERE call_tx_hash IN (rebalancetxs.evt_tx_hash)
),

/*
    wide range -> baseOrder
    time, baseLower, baseLower, limitLower, limitUpper
*/
range AS(
    SELECT 
        m1.Time,
        m1.lowerTick AS baseLower,
        m1.upperTick AS baseUpper,
        m2.lowerTick AS limitLower,
        m2.upperTick AS limitUpper
    FROM mint as m1 INNER JOIN mint M2 ON M1.Time = M2.Time AND M1.range > M2.range
),

/*
    tick to price
*/
rangePrice AS(
    SELECT 
        date_trunc('hour', range.time) AS Time,
        (1.0001^range.baseLower)*(10^12)*priceUSDT.price AS baseLower,
        (1.0001^range.baseUpper)*(10^12)*priceUSDT.price AS baseUpper,  
        (1.0001^range.limitLower)*(10^12)*priceUSDT.price AS limitLower,  
        (1.0001^range.limitUpper)*(10^12)*priceUSDT.price AS limitUpper
    FROM range, prices.usd AS priceUSDT
    WHERE priceUSDT.symbol = 'USDT' AND date_trunc('minute', range.time) = priceUSDT.minute
),

ethPriceEveryHour AS(
    SELECT 
        date_trunc('hour', d) AS Time,
        priceWETH.price AS ""Ethereum Price""
    FROM generate_series(date_trunc('day', NOW() - interval '{{Number of days}} days'), NOW(), '1 hour') AS d, prices.usd AS priceWETH
    WHERE priceWETH.symbol = 'WETH' AND date_trunc('minute', d) = priceWETH.minute 
),

rangePriceEveryHour AS(
    SELECT
        d.time,
        d.""Ethereum Price"",
        (SELECT baseLower FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS baseLower, 
        (SELECT baseUpper FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS baseUpper,
        (SELECT limitLower FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS limitLower,
        (SELECT limitUpper FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS limitUpper
    FROM ethPriceEveryHour AS d LEFT JOIN rangePrice AS r ON d.time = r.time
    ORDER By time
)

SELECT *,baseLower AS ""b1(for visualization)"" ,baseLower AS ""b2(for visualization)"" FROM rangePriceEveryHour -- additional two baseLower are for visualization (area chart)"
70354, Alpha Vault (Old WETH-USDT) / Performance,,table,"WITH Price AS(
    SELECT 
        (snapshot.""totalAmount0""*priceWETH.price + snapshot.""totalAmount1""*priceUSDT.price*10^12) / snapshot.""totalSupply"" AS PricePerShare, 
        priceWETH.price AS PriceWETH, 
        evt_block_time as Time
    FROM charm.""AlphaVault_evt_Snapshot"" AS snapshot, prices.usd AS priceWETH, prices.usd AS priceUSDT
    WHERE 
        snapshot.contract_address = '\x55535C4C56F6Bf373E06C43E44C0356aaFD0d21A' 
        AND priceWETH.symbol = 'WETH' AND date_trunc('minute', snapshot.evt_block_time) = priceWETH.minute 
        AND priceUSDT.symbol = 'USDT' AND date_trunc('minute', snapshot.evt_block_time) = priceUSDT.minute
        AND date_trunc('day', snapshot.evt_block_time) >= (date_trunc('day', NOW()) - interval '{{Number of days}} days')
),

basisPrice AS(
    SELECT *
    FROM Price
    ORDER BY time ASC LIMIT 1
)

SELECT
    Price.time AS Time,
    Price.PricePerShare / basisPrice.PricePerShare AS ""Vault Performance"",
    Price.PriceWETH / basisPrice.PriceWETH AS ""ETH HODL Performance"",
    sqrt(Price.PriceWETH) / sqrt(basisPrice.PriceWETH) AS ""V2 LP Performance Without Fee (sqrt_ETH)"",
    1 AS ""USDT HODL Performance""
FROM 
    Price, basisPrice"
71933,Hypervisor (Old WETH-USDT) / Performance,,table,"WITH Price AS(
    SELECT 
        evt_block_time as Time,
        (rebalance.""totalAmount0""*priceWETH.price + rebalance.""totalAmount1""*priceUSDT.price*10^12) / rebalance.""totalSupply"" AS PricePerShare, 
        priceWETH.price AS PriceWETH
    FROM visor.""Hypervisor_evt_Rebalance"" AS rebalance, prices.usd AS priceWETH, prices.usd AS priceUSDT
    WHERE 
        rebalance.contract_address =  '\x9a98bFfAbc0ABf291d6811C034E239e916bBceC0'
        AND priceWETH.symbol = 'WETH' AND date_trunc('minute', rebalance.evt_block_time) = priceWETH.minute 
        AND priceUSDT.symbol = 'USDT' AND date_trunc('minute', rebalance.evt_block_time) = priceUSDT.minute
        AND date_trunc('day', rebalance.evt_block_time) >= (date_trunc('day', NOW()) - interval '{{Number of days}} days')
),

basisPrice AS(
    SELECT *
    FROM Price
    ORDER BY time ASC LIMIT 1
)

SELECT
    Price.time AS Time,
    Price.PricePerShare / basisPrice.PricePerShare AS ""Vault Performance"",
    Price.PriceWETH / basisPrice.PriceWETH AS ""ETH HODL Performance"",
    sqrt(Price.PriceWETH) / sqrt(basisPrice.PriceWETH) AS ""V2 LP Performance Without Fee (sqrt_ETH)"",
    1 AS ""USDT HODL Performance""
FROM 
    Price, basisPrice"
70426,SorbettoFragola (Old WETH-USDT) / Performance,,table,"WITH hourTable AS(
    SELECT time FROM generate_series(date_trunc('day', NOW() - interval '{{Number of days}} days'), NOW(), '1 hour') AS time
),

TVL AS(
    SELECT 
        evt_block_time as Time,
        (snapshot.""totalAmount0""*priceWETH.price + snapshot.""totalAmount1""*priceUSDT.price*1e12) AS TVL,
        priceWETH.price AS PriceWETH
    FROM 
        popsicle_finance.""SorbettoFragola_evt_Snapshot"" AS snapshot, prices.usd AS priceWETH, prices.usd AS priceUSDT
    WHERE 
        snapshot.contract_address = '\xc4ff55a4329f84f9bf0f5619998ab570481ebb48' 
        AND priceWETH.symbol = 'WETH' AND date_trunc('minute', snapshot.evt_block_time) = priceWETH.minute 
        AND priceUSDT.symbol = 'USDT' AND date_trunc('minute', snapshot.evt_block_time) = priceUSDT.minute
),

TVLAfterSwap AS(
    SELECT DISTINCT
        date_trunc('hour', Time) as Time,
        last_value(TVL) OVER(PARTITION BY Time) AS TVL,
        PriceWETH
    FROM 
        TVL
),

PaidReward AS(
    SELECT 
        date_trunc('hour', reward.evt_block_time) as Time,
        (reward.""fees0""*priceWETH.price + reward.""fees1""*priceUSDT.price*1e12) AS paidReward
    FROM
        popsicle_finance.""SorbettoFragola_evt_RewardPaid"" AS reward, prices.usd AS priceWETH, prices.usd AS priceUSDT
    WHERE 
        reward.contract_address = '\xc4ff55a4329f84f9bf0f5619998ab570481ebb48' 
        AND priceWETH.symbol = 'WETH' AND date_trunc('minute', reward.evt_block_time) = priceWETH.minute 
        AND priceUSDT.symbol = 'USDT' AND date_trunc('minute', reward.evt_block_time) = priceUSDT.minute
),

PaidRewardHour AS(
    SELECT d.time AS time, paidReward FROM hourTable AS d LEFT JOIN PaidReward AS r ON d.time = r.time
),

-- 見たい期間より前のrewardは計算に入れない
SumPaidRewardHour AS(
    SELECT DISTINCT time, COALESCE(SUM(paidReward) OVER(ORDER BY time),0) AS SumPaidReward FROM PaidRewardHour
),


Share AS(
    -- Burn
    SELECT 
        date_trunc('hour', token.evt_block_time) AS time,
        token.value * -1 AS value
    FROM
        erc20.""ERC20_evt_Transfer"" AS token
    WHERE
        token.contract_address = '\xc4ff55a4329f84f9bf0f5619998ab570481ebb48'
        AND token.to = '\x0000000000000000000000000000000000000000' 
UNION ALL
    SELECT 
        date_trunc('hour', token.evt_block_time) AS time,
        token.value AS value
    FROM
        erc20.""ERC20_evt_Transfer"" AS token
    WHERE
        token.contract_address = '\xc4ff55a4329f84f9bf0f5619998ab570481ebb48'
        AND token.from = '\x0000000000000000000000000000000000000000' 
),

TotalShare AS (
    SELECT time, SUM(value) AS TotalShare FROM Share GROUP BY time 
),

-- 見たい期間より前のshareも計算に入れる
SumTotalShare AS(
    SELECT time, COALESCE(SUM(TotalShare) OVER(ORDER BY time),0) AS SumTotalShare FROM TotalShare
),

SumTotalShareHour AS(
    SELECT d.time AS time, (SELECT SumTotalShare FROM SumTotalShare WHERE SumTotalShare.time < d.time ORDER BY SumTotalShare.time DESC LIMIT 1) AS SumTotalShare FROM hourTable AS d LEFT JOIN SumTotalShare AS t ON d.time = t.time
),

Performance AS(
    SELECT S.time AS time, (TVL+SumPaidReward)/SumTotalShare AS Performance, PriceWETH
    FROM TVLAfterSwap AS T 
        LEFT JOIN SumTotalShareHour AS S ON T.time = S.time
        LEFT JOIN SumPaidRewardHour AS R ON T.time = R.time
    WHERE SumTotalShare>0
),

basisPerformance AS(
    SELECT *
    FROM Performance AS P
    WHERE P.Performance IS NOT NULL
    ORDER BY time ASC LIMIT 1
)


SELECT
    Performance.time,
    Performance.Performance / basisPerformance.Performance AS ""Vault Performance"",
    Performance.PriceWETH / basisPerformance.PriceWETH AS ""ETH HODL Performance"",
    sqrt(Performance.PriceWETH) / sqrt(basisPerformance.PriceWETH) AS ""V2 LP Performance Without Fee (sqrt_ETH)"",
    1 AS ""USDT HODL Performance""
FROM 
    Performance, basisPerformance
"
71863,Hypervisor (Old WETH-USDT) / Order Range,,table,"/* get rebalance tx hash*/
WITH rebalancetxs AS(
    SELECT ""evt_tx_hash""
    FROM visor.""Hypervisor_evt_Rebalance""
    WHERE contract_address =  '\x9a98bFfAbc0ABf291d6811C034E239e916bBceC0' -- https://etherscan.io/address/0x716bd8A7f8A44B010969A1825ae5658e7a18630D#code --https://etherscan.io/tx/0x977f4f1161db9039a00ed8e6d975720728cdaf030b1d7b66e1fb3aeb6eb4a14d
)

/*  
    two mint events in one tx
    time, lowerTick, upperTick, range <- band order
    time, lowerTick, upperTick, range <- limit order
*/
,mint AS(
 SELECT
  position.""tickLower"" AS lowerTick,   
  position.""tickUpper"" AS UpperTick,  
  ABS(position.""tickLower"" - position.""tickUpper"") AS range,
  ""call_block_time"" AS Time 
 FROM uniswap_v3.""Pair_call_mint"" AS position, rebalancetxs
 WHERE call_tx_hash IN (rebalancetxs.evt_tx_hash)
),

/*
    wide range -> baseOrder
    time, baseLower, baseLower, limitLower, limitUpper
*/
range AS(
    SELECT 
        m1.Time,
        m1.lowerTick AS baseLower,
        m1.upperTick AS baseUpper,
        m2.lowerTick AS limitLower,
        m2.upperTick AS limitUpper
    FROM mint as m1 INNER JOIN mint M2 ON M1.Time = M2.Time AND M1.range > M2.range
),

/*
    tick to price
*/
rangePrice AS(
    SELECT 
        date_trunc('hour', range.time) AS Time,
        (1.0001^range.baseLower)*(10^12)*priceUSDT.price AS baseLower,
        (1.0001^range.baseUpper)*(10^12)*priceUSDT.price AS baseUpper,  
        (1.0001^range.limitLower)*(10^12)*priceUSDT.price AS limitLower,  
        (1.0001^range.limitUpper)*(10^12)*priceUSDT.price AS limitUpper
    FROM range, prices.usd AS priceUSDT
    WHERE priceUSDT.symbol = 'USDT' AND date_trunc('minute', range.time) = priceUSDT.minute
),

ethPriceEveryHour AS(
    SELECT 
        date_trunc('hour', d) AS Time,
        priceWETH.price AS ""Ethereum Price""
    FROM generate_series(date_trunc('day', NOW() - interval '{{Number of days}} days'), NOW(), '1 hour') AS d, prices.usd AS priceWETH
    WHERE priceWETH.symbol = 'WETH' AND date_trunc('minute', d) = priceWETH.minute 
),

rangePriceEveryHour AS(
    SELECT
        d.time,
        d.""Ethereum Price"",
        (SELECT baseLower FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS baseLower, 
        (SELECT baseUpper FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS baseUpper,
        (SELECT limitLower FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS limitLower,
        (SELECT limitUpper FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS limitUpper
    FROM ethPriceEveryHour AS d LEFT JOIN rangePrice AS r ON d.time = r.time
    ORDER By time
)

SELECT *,baseLower AS ""b1(for visualization)"" ,baseLower AS ""b2(for visualization)"" FROM rangePriceEveryHour -- additional two baseLower are for visualization (area chart)"
70910,Sorbetto Fragola (Old WETH-USDT) Order Range,,chart,"WITH range AS(
    SELECT ""tickLower"" AS tickLower, ""tickUpper"" AS tickUpper, rerange.evt_block_time AS Time 
    FROM popsicle_finance.""SorbettoFragola_evt_Rerange"" AS rerange -- https://etherscan.io/address/0xc4ff55a4329f84f9bf0f5619998ab570481ebb48
    WHERE contract_address =  '\xc4ff55a4329f84f9bf0f5619998ab570481ebb48'
),

rangePrice AS(
    SELECT 
        date_trunc('minute', range.time) AS Time,
        (1.0001^range.tickLower)*(10^12)*priceUSDT.price AS LowerPrice,
        (1.0001^range.tickUpper)*(10^12)*priceUSDT.price AS UpperPrice
    FROM range, prices.usd AS priceUSDT
    WHERE priceUSDT.symbol = 'USDT' AND date_trunc('minute', range.time) = priceUSDT.minute
),

ethPriceEveryHour AS(
    SELECT 
        date_trunc('hour', d) AS Time,
        priceWETH.price AS ""Ethereum Price""
    FROM generate_series(date_trunc('day', NOW() - interval '{{Number of days}} days'), NOW(), '1 hour') AS d, prices.usd AS priceWETH
    WHERE priceWETH.symbol = 'WETH' AND date_trunc('minute', d) = priceWETH.minute 
),

rangePriceEveryHour AS(
    SELECT
        d.time,
        d.""Ethereum Price"",
        (SELECT LowerPrice FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS LowerPrice, 
        (SELECT UpperPrice FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS UpperPrice
    FROM ethPriceEveryHour AS d LEFT JOIN rangePrice AS r ON d.time = r.time
    ORDER By time
)

SELECT *,LowerPrice AS ""l1(for visualization)"" ,LowerPrice AS ""l2(for visualization)"" FROM rangePriceEveryHour -- additional two LowerPrice are for visualization (area chart)"
70434, Alpha Vaults (Old WETH-USDT) / Order Range,,table,"/* get rebalance tx hash*/
WITH rebalancetxs AS(
    SELECT ""evt_tx_hash""
    FROM charm.""AlphaVault_evt_Snapshot""
    WHERE contract_address =  '\x55535C4C56F6Bf373E06C43E44C0356aaFD0d21A'
)

/*  
    two mint events in one tx
    time, lowerTick, upperTick, range <- band order
    time, lowerTick, upperTick, range <- limit order
*/
,mint AS(
 SELECT
  position.""tickLower"" AS lowerTick,   
  position.""tickUpper"" AS UpperTick,  
  ABS(position.""tickLower"" - position.""tickUpper"") AS range,
  ""call_block_time"" AS Time 
 FROM uniswap_v3.""Pair_call_mint"" AS position, rebalancetxs
 WHERE call_tx_hash IN (rebalancetxs.evt_tx_hash)
),

/*
    wide range -> baseOrder
    time, baseLower, baseLower, limitLower, limitUpper
*/
range AS(
    SELECT 
        m1.Time,
        m1.lowerTick AS baseLower,
        m1.upperTick AS baseUpper,
        m2.lowerTick AS limitLower,
        m2.upperTick AS limitUpper
    FROM mint as m1 INNER JOIN mint M2 ON M1.Time = M2.Time AND M1.range > M2.range
),

/*
    tick to price
*/
rangePrice AS(
    SELECT 
        date_trunc('hour', range.time) AS Time,
        (1.0001^range.baseLower)*(10^12)*priceUSDT.price AS baseLower,
        (1.0001^range.baseUpper)*(10^12)*priceUSDT.price AS baseUpper,  
        (1.0001^range.limitLower)*(10^12)*priceUSDT.price AS limitLower,  
        (1.0001^range.limitUpper)*(10^12)*priceUSDT.price AS limitUpper
    FROM range, prices.usd AS priceUSDT
    WHERE priceUSDT.symbol = 'USDT' AND date_trunc('minute', range.time) = priceUSDT.minute
),

ethPriceEveryHour AS(
    SELECT 
        date_trunc('hour', d) AS Time,
        priceWETH.price AS ""Ethereum Price""
    FROM generate_series(date_trunc('day', NOW() - interval '{{Number of days}} days'), NOW(), '1 hour') AS d, prices.usd AS priceWETH
    WHERE priceWETH.symbol = 'WETH' AND date_trunc('minute', d) = priceWETH.minute 
),

rangePriceEveryHour AS(
    SELECT
        d.time,
        d.""Ethereum Price"",
        (SELECT baseLower FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS baseLower, 
        (SELECT baseUpper FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS baseUpper,
        (SELECT limitLower FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS limitLower,
        (SELECT limitUpper FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS limitUpper
    FROM ethPriceEveryHour AS d LEFT JOIN rangePrice AS r ON d.time = r.time
    ORDER By time
)

SELECT *,baseLower AS ""b1(for visualization)"" ,baseLower AS ""b2(for visualization)"" FROM rangePriceEveryHour -- additional two baseLower are for visualization (area chart)"
78305, Alpha Vault (USDC-WETH) / Performance,,table,"WITH Price AS(
    SELECT 
        (snapshot.""totalAmount0""*priceUSDC.price*10^12 + snapshot.""totalAmount1""*priceWETH.price) / snapshot.""totalSupply"" AS PricePerShare, 
        priceWETH.price AS PriceWETH, 
        evt_block_time as Time,
        snapshot.""totalAmount0""*priceUSDC.price*10^12 + snapshot.""totalAmount1""*priceWETH.price AS TVL
    FROM charm.""AlphaVault_evt_Snapshot"" AS snapshot, prices.usd AS priceWETH, prices.usd AS priceUSDC
    WHERE 
        snapshot.contract_address = '\x9bf7b46c7ad5ab62034e9349ab912c0345164322' 
        AND priceWETH.symbol = 'WETH' AND date_trunc('minute', snapshot.evt_block_time) = priceWETH.minute 
        AND priceUSDC.symbol = 'USDC' AND date_trunc('minute', snapshot.evt_block_time) = priceUSDC.minute
        AND date_trunc('day', snapshot.evt_block_time) >= (date_trunc('day', NOW()) - interval '{{Number of days}} days')
),

basisPrice AS(
    SELECT *
    FROM Price
    ORDER BY time ASC LIMIT 1
)

SELECT
    Price.time AS Time,
    Price.PricePerShare / basisPrice.PricePerShare AS ""Vault Performance"",
    Price.PriceWETH / basisPrice.PriceWETH AS ""ETH HODL Performance"",
    sqrt(Price.PriceWETH) / sqrt(basisPrice.PriceWETH) AS ""V2 LP Performance Without Fee (sqrt_ETH)"",
    1 AS ""USDC HODL Performance"",
    Price.TVL/1e18 AS TVL
FROM 
    Price, basisPrice"
78308, Alpha Vaults (USDC-WETH) / Order Range,,table,"/* get rebalance tx hash*/
WITH rebalancetxs AS(
    SELECT ""evt_tx_hash""
    FROM charm.""AlphaVault_evt_Snapshot""
    WHERE contract_address =  '\x9bf7b46c7ad5ab62034e9349ab912c0345164322'
)

/*  
    two mint events in one tx
    time, lowerTick, upperTick, range <- band order
    time, lowerTick, upperTick, range <- limit order
*/
,mint AS(
    SELECT
        position.""tickLower"" AS lowerTick,   
        position.""tickUpper"" AS UpperTick,  
        ABS(position.""tickLower"" - position.""tickUpper"") AS range,
        ""call_block_time"" AS Time 
    FROM uniswap_v3.""Pair_call_mint"" AS position, rebalancetxs
    WHERE call_tx_hash IN (rebalancetxs.evt_tx_hash)
),

/*
    wide range -> baseOrder
    time, baseLower, baseLower, limitLower, limitUpper
*/
range AS(
    SELECT 
        m1.Time,
        m1.lowerTick AS baseLower,
        m1.upperTick AS baseUpper,
        m2.lowerTick AS limitLower,
        m2.upperTick AS limitUpper
    FROM mint as m1 INNER JOIN mint M2 ON M1.Time = M2.Time AND M1.range > M2.range
),

/*
    tick to price
    token0 <- USDC
*/
rangePrice AS(
    SELECT 
        range.time AS Time,
        1e12/(1.0001^range.baseLower)*priceUSDC.price AS baseUpper, -- reverse
        1e12/(1.0001^range.baseUpper)*priceUSDC.price AS baseLower,  
        1e12/(1.0001^range.limitLower)*priceUSDC.price AS limitUpper,  
        1e12/(1.0001^range.limitUpper)*priceUSDC.price AS limitLower
    FROM range, prices.usd AS priceUSDC
    WHERE priceUSDC.symbol = 'USDC' AND date_trunc('minute', range.time) = priceUSDC.minute
),

ethPriceEveryHour AS(
    SELECT 
        date_trunc('hour', d) AS Time,
        priceWETH.price AS ""Ethereum Price""
    FROM generate_series(date_trunc('day', NOW() - interval '{{Number of days}} days'), NOW(), '1 hour') AS d, prices.usd AS priceWETH
    WHERE priceWETH.symbol = 'WETH' AND date_trunc('minute', d) = priceWETH.minute 
),

rangePriceEveryHour AS(
    SELECT
        d.time,
        d.""Ethereum Price"",
        (SELECT baseLower FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS baseLower, 
        (SELECT baseUpper FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS baseUpper,
        (SELECT limitLower FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS limitLower,
        (SELECT limitUpper FROM rangePrice WHERE rangePrice.time < d.time ORDER BY rangePrice.time DESC LIMIT 1) AS limitUpper
    FROM ethPriceEveryHour AS d LEFT JOIN rangePrice AS r ON d.time = r.time
    ORDER By time
)

SELECT *,baseLower AS ""b1(for visualization)"" ,baseLower AS ""b2(for visualization)"" FROM rangePriceEveryHour -- additional two baseLower are for visualization (area chart)"
78323, Alpha Vault (WETH-USDT) / Performance,,table,"WITH Price AS(
    SELECT 
        (snapshot.""totalAmount0""*priceWETH.price + snapshot.""totalAmount1""*priceUSDT.price*10^12) / snapshot.""totalSupply"" AS PricePerShare, 
        priceWETH.price AS PriceWETH, 
        evt_block_time as Time
    FROM charm.""AlphaVault_evt_Snapshot"" AS snapshot, prices.usd AS priceWETH, prices.usd AS priceUSDT
    WHERE 
        snapshot.contract_address = '\xE72f3E105e475D7Db3a003FfA377aFAe9c2c6c11' 
        AND priceWETH.symbol = 'WETH' AND date_trunc('minute', snapshot.evt_block_time) = priceWETH.minute 
        AND priceUSDT.symbol = 'USDT' AND date_trunc('minute', snapshot.evt_block_time) = priceUSDT.minute
        AND date_trunc('day', snapshot.evt_block_time) >= (date_trunc('day', NOW()) - interval '{{Number of days}} days')
),

basisPrice AS(
    SELECT *
    FROM Price
    ORDER BY time ASC LIMIT 1
)

SELECT
    Price.time AS Time,
    Price.PricePerShare / basisPrice.PricePerShare AS ""Vault Performance"",
    Price.PriceWETH / basisPrice.PriceWETH AS ""ETH HODL Performance"",
    sqrt(Price.PriceWETH) / sqrt(basisPrice.PriceWETH) AS ""V2 LP Performance Without Fee (sqrt_ETH)"",
    1 AS ""USDT HODL Performance""
FROM 
    Price, basisPrice"
95576,Uniswap v3 Pair Deep-Dive (all versions),,table,"WITH univ3 AS
(
    SELECT 
    DATE_TRUNC('{{Time-Series Granularity}}',t.""block_time"") AS dt,
    ""exchange_contract_address"",
    project, version,
    CASE WHEN version = '1' OR version IS NULL THEN project
    ELSE project || ' V' || version || ' - ' || ( ROUND(p.fee/1e4,2) )::text || '%'
    END as proj_v,
    t.category,
    t.""token_a_address"",
    t.""token_b_address"",
    t.""token_a_symbol"",
    t.""token_b_symbol"",
    t.""token_a_symbol"" || '/' || t.""token_b_symbol"" AS pair,
    t.""token_a_symbol"" || '/' || t.""token_b_symbol"" || ' - ' || ( ROUND(p.fee/1e4,2) )::text || '%' AS pool,
    SUM(t.token_a_amount) AS token_a_amount,
    SUM(t.token_b_amount) AS token_b_amount,
    --t.trader_a AS user,
    SUM(t.usd_amount) AS usd_traded,
    COUNT(t.usd_amount) AS num_trades,
    COUNT(DISTINCT t.trader_a) AS num_users
    
    FROM dex.trades t
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p
    ON t.exchange_contract_address = p.pool
    
    WHERE t.project = 'Uniswap'
    AND t.version = '3'
    AND t.""block_time"" > DATE_TRUNC('{{Time-Series Granularity}}',LEAST('{{Reference Date}}',NOW()) ) - '{{Trailing Num Days}} days'::interval - '{{UTC Offset}} hours'::interval
    AND t.""exchange_contract_address"" = REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
    
    GROUP BY 1,2,3,4,5,6,7,8,9,10,11,12

) --uni v3
, dex AS (

SELECT 
    DATE_TRUNC('{{Time-Series Granularity}}',o.""block_time"") AS dt,
    ""exchange_contract_address"",
    project, version,
    CASE WHEN version = '1' OR (version IS NULL) THEN project
    WHEN project = 'Uniswap' AND version = '3'
        THEN project || ' V' || version || ' - ' || ( ROUND(p.fee/1e4,2) )::text || '%'
    ELSE project || ' V' || version
    END as proj_v,
    o.category,
    uv.""token_a_address"",
    uv.""token_b_address"",
    uv.""token_a_symbol"",
    uv.""token_b_symbol"",
    uv.""token_a_symbol"" || '/' || uv.""token_b_symbol"" AS pair,
    uv.""token_a_symbol"" || '/' || uv.""token_b_symbol"" /*|| ' - ' || ( ROUND(p.fee/1e4,2) )::text || '%'*/ AS pool,
    SUM(o.token_a_amount) AS token_a_amount,
    SUM(o.token_b_amount) AS token_b_amount,
    --t.trader_a AS user,
    SUM(o.usd_amount) AS usd_traded,
    COUNT(o.usd_amount) AS num_trades,
    COUNT(DISTINCT o.trader_a) AS num_users
    
    FROM
    dex.trades o --others
    INNER JOIN (SELECT DISTINCT token_a_address, token_a_symbol, token_b_address, token_b_symbol FROM univ3) uv ON
        (
        (uv.token_a_address = o.token_a_address) AND (uv.token_b_address = o.token_b_address) --forwards
        OR
        (uv.token_a_address = o.token_b_address) AND (uv.token_b_address = o.token_a_address) --backwards
        )
    LEFT JOIN uniswap_v3.""Factory_evt_PoolCreated"" p
    ON o.project = 'Uniswap' AND o.version = '3'
    AND p.""pool"" = o.""exchange_contract_address""
    
    WHERE o.""exchange_contract_address"" != REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
    AND o.""block_time"" > DATE_TRUNC('{{Time-Series Granularity}}',LEAST('{{Reference Date}}',NOW()) ) - '{{Trailing Num Days}} days'::interval - '{{UTC Offset}} hours'::interval
    AND o.category = 'DEX'
    
    GROUP BY 1,2,3,4,5,6,7,8,9,10,11,12

)
/*, aggs AS (
SELECT 
    DATE_TRUNC('{{Time-Series Granularity}}',o.""block_time"") AS dt,
    ""exchange_contract_address"",
    project, version,
    CASE WHEN version = '1' OR version IS NULL THEN project
    ELSE project || ' V' || version
    END as proj_v,
    o.category,
    o.""token_a_address"",
    o.""token_b_address"",
    o.""token_a_symbol"",
    o.""token_b_symbol"",
    o.""token_a_symbol"" || '/' || o.""token_b_symbol"" AS pair,
    o.""token_a_symbol"" || '/' || o.""token_b_symbol"" AS pool,
    SUM(o.token_a_amount) AS token_a_amount,
    SUM(o.token_b_amount) AS token_b_amount,
    --t.trader_a AS user,
    SUM(o.usd_amount) AS usd_traded,
    COUNT(o.usd_amount) AS num_trades,
    COUNT(DISTINCT o.trader_a) AS num_users
    
    FROM
    dex.trades o --others
    INNER JOIN (SELECT DISTINCT token_a_symbol, token_b_symbol FROM univ3) uv ON
    (
    (uv.token_a_symbol = o.token_a_symbol) AND (uv.token_b_symbol = o.token_b_symbol) --forwards
    OR
    (uv.token_a_symbol = o.token_a_symbol) AND (uv.token_b_symbol = o.token_b_symbol) --backwards
    )
    WHERE o.""exchange_contract_address"" != REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
    AND o.""block_time"" > DATE_TRUNC('{{Time-Series Granularity}}',LEAST('{{Reference Date}}',NOW()) ) - '{{Trailing Num Days}} days'::interval - '{{UTC Offset}} hours'::interval
    AND o.category = 'Aggregator'
    AND NOT EXISTS
        (SELECT 1 FROM dex.trades d WHERE d.""category""='DEX' AND d.""tx_hash"" = o.""tx_hash"")
    
    GROUP BY 1,2,3,4,5,6,7,8,9,10,11,12

)*/

, trades
AS (
    SELECT * FROM univ3
    UNION
    SELECT * FROM dex
    --UNION
    --SELECT * FROM aggs
)

,projects AS --so I can pull in info even when there aren't any trades to match
(
    SELECT DISTINCT
    ""exchange_contract_address"", proj_v, pair, pool, category,
    token_a_address, token_b_address, token_a_symbol, token_b_symbol
    FROM trades
)

,prices AS
(
SELECT *,
DENSE_RANK() OVER (PARTITION BY ""contract_address"" ORDER BY minute DESC) AS p_rank
FROM prices.""usd"" p
WHERE p.minute > DATE_TRUNC('{{Time-Series Granularity}}',LEAST('{{Reference Date}}',NOW()) ) - '{{Trailing Num Days}} days'::interval - '{{UTC Offset}} hours'::interval
AND (
    ""contract_address"" IN (SELECT DISTINCT ""token_b_address"" FROM projects)
    OR ""contract_address"" IN (SELECT DISTINCT ""token_a_address"" FROM projects)
    )
)

,gs AS
(
SELECT generate_series(DATE_TRUNC('hour',NOW() ) - interval '{{Trailing Num Days}} day', date_trunc('hour', NOW() ), '1 hour') AS hour
)
/*
,gs AS
(
SELECT DISTINCT d.token_a_address AS token, gs.hour FROM trades d
INNER JOIN 
(SELECT generate_series(DATE_TRUNC('hour',LEAST(('{{Reference Date}}'::date - '{{UTC Offset}} hours'::interval),NOW()) ) - interval '{{Trailing Num Days}} day', date_trunc('hour', LEAST(('{{Reference Date}}'::date - '{{UTC Offset}} hours'::interval),NOW()) ), '1 hour') AS hour) gs -- Generate all days since the first contract
ON 1=1
UNION
SELECT DISTINCT d.token_b_address AS token, gs.hour FROM trades d
INNER JOIN 
(SELECT generate_series(DATE_TRUNC('hour',LEAST(('{{Reference Date}}'::date - '{{UTC Offset}} hours'::interval),NOW()) ) - interval '{{Trailing Num Days}} day', date_trunc('hour', LEAST(('{{Reference Date}}'::date - '{{UTC Offset}} hours'::interval),NOW()) ), '1 hour') AS hour) gs -- Generate all days since the first contract
ON 1=1
)*/

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
gs.hour, c.token, 
symbol, decimals, median_price
FROM
(
SELECT *,
lead(hour, 1, LEAST('{{Reference Date}}'::date - '{{UTC Offset}} hours'::interval,NOW())  ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour
FROM
(
SELECT

DATE_TRUNC('hour',hour) AS hour,
t.contract_address AS token, ea.symbol AS symbol, ea.decimals AS decimals,
percentile_cont(0.5) WITHIN GROUP (ORDER BY ""median_price"") AS median_price

FROM dex.""view_token_prices"" t

INNER JOIN (SELECT DISTINCT token_a_address AS token FROM projects UNION SELECT DISTINCT token_b_address AS token FROM projects) c
ON t.contract_address = c.token
INNER JOIN erc20.""tokens"" ea --both need to have known decimals, we're not going to assume anything.
ON ea.""contract_address"" = t.contract_address

WHERE
(ea.decimals IS NOT NULL)
AND median_price > 0

AND DATE_TRUNC('hour',hour) > 
(DATE_TRUNC('{{Time-Series Granularity}}',LEAST('{{Reference Date}}'::date,NOW()) ) - '{{Trailing Num Days}} days'::interval - '{{UTC Offset}} hours'::interval)
AND DATE_TRUNC('hour',hour) <= LEAST('{{Reference Date}}'::date - '{{UTC Offset}} hours'::interval,NOW()) + interval '1 day'

GROUP BY 1,2,3,4
) b
) c
INNER JOIN gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour
)

, tvl AS (

SELECT DISTINCT
dt, 
exchange_contract_address,
token_a_address,token_b_address,
SUM(delta_tvl) OVER (PARTITION BY dt, exchange_contract_address)
    AS delta_tvl,
SUM(add_tvl) OVER (PARTITION BY dt, exchange_contract_address)
    AS add_tvl,
LAST_VALUE(running_tvl) OVER (PARTITION BY dt, exchange_contract_address 
                            ORDER BY hour::timestamp ASC
                            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
    AS running_tvl

FROM
(
SELECT
hour,
DATE_TRUNC('{{Time-Series Granularity}}',hour) AS dt,
a.exchange_contract_address,
pr.token_a_address,pr.token_b_address,
COALESCE(SUM(val_usd),0) AS delta_tvl,
COALESCE(SUM(addval_usd),0) AS add_tvl,
COALESCE(SUM(sumval_usd),0) AS running_tvl

FROM
(
SELECT 
gs.hour, c.token, exchange_contract_address,
CASE WHEN gs.hour = c.hour THEN val ELSE 0 END AS val,
CASE WHEN gs.hour = c.hour THEN val/(10^COALESCE(p.decimals,dp.decimals)) ELSE 0 END AS val_tokens,
CASE WHEN gs.hour = c.hour THEN COALESCE(p.price,dp.median_price)*(val/(10^COALESCE(p.decimals,dp.decimals))) ELSE 0 END AS val_usd,

CASE WHEN gs.hour = c.hour THEN addval ELSE 0 END AS addval,
CASE WHEN gs.hour = c.hour THEN addval/(10^COALESCE(p.decimals,dp.decimals)) ELSE 0 END AS addval_tokens,
CASE WHEN gs.hour = c.hour THEN COALESCE(p.price,dp.median_price)*(addval/(10^COALESCE(p.decimals,dp.decimals))) ELSE 0 END AS addval_usd,

sumval,
sumval/(10^COALESCE(p.decimals,dp.decimals)) AS sumval_tokens,
COALESCE(p.price,dp.median_price)*(sumval/(10^COALESCE(p.decimals,dp.decimals))) AS sumval_usd

FROM
(
    SELECT
    *, contract_address AS token,
    lead(hour, 1, LEAST('{{Reference Date}}',NOW())  ) OVER (PARTITION BY contract_address, exchange_contract_address
                            ORDER BY hour asc) AS next_hour,
    SUM(val) OVER (PARTITION BY contract_address, exchange_contract_address ORDER BY hour ASC) AS sumval
    FROM
    (
    SELECT
    hour,
    contract_address,
    exchange_contract_address,
    SUM(val) AS val,
    SUM(CASE WHEN val >0 THEN val ELSE 0 END) AS addval
    --SUM(val) OVER (PARTITION BY contract_address, exchange_contract_address ORDER BY hour ASC) AS sumval
    --SUM( price*(val/(10^decimals)) ) AS usd_tvl
    
    FROM (
        SELECT 
        CASE WHEN DATE_TRUNC('{{Time-Series Granularity}}',e.""evt_block_time"") >= (DATE_TRUNC('{{Time-Series Granularity}}',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('{{Time-Series Granularity}}',e.""evt_block_time"")
            ELSE DATE_TRUNC('{{Time-Series Granularity}}',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 {{Time-Series Granularity}}'::interval
            END AS hour,
        ""to"" AS exchange_contract_address,
        e.""contract_address"", SUM(value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN (SELECT DISTINCT exchange_contract_address, token_a_address, token_b_address FROM projects) t --dex id causes duplication
        ON ""to"" = t.exchange_contract_address
        AND e.""contract_address"" IN (t.token_a_address, t.token_b_address) --only get tvl of the 2 tokens

        GROUP BY 1,2,3
        
        UNION ALL
        
        SELECT 
        CASE WHEN DATE_TRUNC('{{Time-Series Granularity}}',e.""evt_block_time"") >= (DATE_TRUNC('{{Time-Series Granularity}}',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('{{Time-Series Granularity}}',e.""evt_block_time"")
            ELSE DATE_TRUNC('{{Time-Series Granularity}}',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 {{Time-Series Granularity}}'::interval
            END AS hour,
        ""from"" AS exchange_contract_address,
        e.""contract_address"", SUM(-value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        INNER JOIN (SELECT DISTINCT exchange_contract_address, token_a_address, token_b_address FROM projects) t --dex id causes duplication
        ON ""from"" = t.exchange_contract_address
        AND e.""contract_address"" IN (t.token_a_address, t.token_b_address) --only get tvl of the 2 tokens
        
        GROUP BY 1,2,3

        UNION ALL --balancer v2 token a
        
        SELECT
        CASE WHEN DATE_TRUNC('{{Time-Series Granularity}}',ba.""evt_block_time"") >= (DATE_TRUNC('{{Time-Series Granularity}}',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('{{Time-Series Granularity}}',ba.""evt_block_time"")
            ELSE DATE_TRUNC('{{Time-Series Granularity}}',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 {{Time-Series Granularity}}'::interval
            END AS hour,
        ba.""poolId"" AS exchange_contract_address,
        ba.tokens[1] AS ""contract_address"", SUM(deltas[1]) AS val
        FROM balancer_v2.""Vault_evt_PoolBalanceChanged"" ba
        
        INNER JOIN projects t
        ON ba.""poolId"" = t.exchange_contract_address
        AND ba.tokens[1] IN (t.token_a_address, t.token_b_address) --only get tvl of the 2 tokens
        
        GROUP BY 1,2,3
        
        UNION ALL --balancer v2 token b
        
        SELECT
        CASE WHEN DATE_TRUNC('{{Time-Series Granularity}}',ba.""evt_block_time"") >= (DATE_TRUNC('{{Time-Series Granularity}}',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('{{Time-Series Granularity}}',ba.""evt_block_time"")
            ELSE DATE_TRUNC('{{Time-Series Granularity}}',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 {{Time-Series Granularity}}'::interval
            END AS hour,
        ba.""poolId"" AS exchange_contract_address,
        ba.tokens[2] AS ""contract_address"", SUM(deltas[2]) AS val
        FROM balancer_v2.""Vault_evt_PoolBalanceChanged"" ba
        
        INNER JOIN projects t
        ON ba.""poolId"" = t.exchange_contract_address
        AND ba.tokens[2] IN (t.token_a_address, t.token_b_address) --only get tvl of the 2 tokens
        
        GROUP BY 1,2,3
        
        UNION ALL --balancer v2 swaps token out
        
        SELECT
        CASE WHEN DATE_TRUNC('{{Time-Series Granularity}}',bas.""evt_block_time"") >= (DATE_TRUNC('{{Time-Series Granularity}}',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('{{Time-Series Granularity}}',bas.""evt_block_time"")
            ELSE DATE_TRUNC('{{Time-Series Granularity}}',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 {{Time-Series Granularity}}'::interval
            END AS hour,
        bas.""poolId"" AS ""contract_address"",
        bas.""tokenOut"" AS ""contract_address"", SUM(-bas.""amountOut"") AS val
        FROM balancer_v2.""Vault_evt_Swap"" bas
        INNER JOIN projects t
        ON bas.""poolId"" = t.exchange_contract_address
        AND bas.""tokenOut"" IN (t.token_a_address, t.token_b_address) --only get tvl of the 2 tokens
        
        GROUP BY 1,2,3
        
        UNION ALL --balancer v2 swaps token in
        
        SELECT
        CASE WHEN DATE_TRUNC('{{Time-Series Granularity}}',bas2.""evt_block_time"") >= (DATE_TRUNC('{{Time-Series Granularity}}',NOW() ) - '{{Trailing Num Days}} days'::interval)
            THEN DATE_TRUNC('{{Time-Series Granularity}}',bas2.""evt_block_time"")
            ELSE DATE_TRUNC('{{Time-Series Granularity}}',NOW() ) - '{{Trailing Num Days}} days'::interval - '1 {{Time-Series Granularity}}'::interval
            END AS hour,
        bas2.""poolId"" AS ""contract_address"",
        bas2.""tokenIn"" AS ""contract_address"", SUM(bas2.""amountIn"") AS val
        FROM balancer_v2.""Vault_evt_Swap"" bas2
        INNER JOIN projects t
        ON bas2.""poolId"" = t.exchange_contract_address
        AND bas2.""tokenIn"" IN (t.token_a_address, t.token_b_address) --only get tvl of the 2 tokens
        
        GROUP BY 1,2,3
        
        ) tr
        GROUP BY 1,2,3
    ) mod

) c
INNER JOIN gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour

LEFT JOIN prices p
        ON p.""contract_address"" = c.token
        AND
        CASE WHEN DATE_TRUNC('hour',gs.hour) = DATE_TRUNC('hour',LEAST('{{Reference Date}}',NOW()) )
        THEN p.p_rank = 1 --p.""minute"" = DATE_TRUNC('hour',LEAST('{{Reference Date}}',NOW()) - interval '15 minutes')
        ELSE p.""minute"" = DATE_TRUNC('hour',gs.hour) + interval '59 minutes'
        END
    LEFT JOIN dex_price dp
        ON c.token = dp.token
        AND dp.hour = gs.hour     
        AND p.price IS NULL
        
WHERE gs.hour > DATE_TRUNC('{{Time-Series Granularity}}',LEAST('{{Reference Date}}',NOW()) ) - '{{Trailing Num Days}} days'::interval - '{{UTC Offset}} hours'::interval
    
) a
INNER JOIN projects pr
ON a.""exchange_contract_address"" = pr.""exchange_contract_address""

GROUP BY 1,2,3, 4, 5
) b

)
SELECT *,
SUM(usd_traded) OVER (ORDER BY dt ASC) AS running_usd, --no partition all dexs
SUM(num_trades) OVER (ORDER BY dt ASC) AS running_trades,
SUM(CASE WHEN running_tvl <0 THEN NULL WHEN category = 'DEX' THEN running_tvl ELSE NULL END) OVER (PARTITION BY dt) AS running_tvl_all

FROM (
    SELECT
    tvl.dt + '{{UTC Offset}} hours'::interval AS dt, 
    --tvl.exchange_contract_address, --DEXs like balancer have many pools per pair
    pr.proj_v, pr.pair, pr.pool, pr.category,
    pr.token_a_address, pr.token_b_address, pr.token_a_symbol, pr.token_b_symbol,
    SUM(CASE WHEN pr.category = 'DEX' THEN tvl.delta_tvl ELSE NULL END) AS delta_tvl,
    SUM(CASE WHEN pr.category = 'DEX' THEN tvl.add_tvl ELSE NULL END) AS add_tvl,
    SUM(CASE WHEN tvl.running_tvl <0 THEN NULL WHEN pr.category = 'DEX' THEN tvl.running_tvl ELSE NULL END) AS running_tvl,
    COALESCE(SUM(tr.usd_traded),0) AS usd_traded, COALESCE(SUM(tr.num_trades),0) AS num_trades
    FROM tvl
    INNER JOIN projects pr
    ON pr.exchange_contract_address = tvl.exchange_contract_address
    LEFT JOIN trades tr
    ON tr.""exchange_contract_address"" = tvl.exchange_contract_address
    AND tr.dt = tvl.dt
    GROUP BY 1,2,3,4,5,6,7,8,9
) a

    
ORDER BY dt DESC --this is important for counters
"
98815,Uniswap v3 Pair Deep-Dive (Depth Table),,chart,"WITH get_liquidity AS ( --this is to find the liquidity of each position at trade time
SELECT *
FROM
(
SELECT *,
    LAST_VALUE(a.next_lp_amount) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS last_lp_amount
    FROM
    (
    SELECT *,
    lead(running_amount, 1, running_amount) OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS next_lp_amount
    FROM
    (
        SELECT amount, amount0, amount1, contract_address,call_block_time, call_tx_hash,
        ""tickLower"",""tickUpper"", /*liquidity,*/ ""tokenId"", tr_type,
        lead(call_block_time, 1, now()) OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS next_lp, --to help key in on the right lp when joining - for preformance
        lag(call_block_time, 1, '01-01-2000') OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS previous_lp,
        SUM(amount) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount,
        SUM(amount0) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount0,
        SUM(amount1) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount1,
        MIN(call_block_time) OVER(PARTITION BY ""tokenId"") AS liq_start
        
        FROM ( --this is a mess. We union new mints + adds to liquidity + new burns + removals from liquidity. eesh
            -- NEW MINTS
            SELECT
            m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
            m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
            /*l.liquidity,*/ l.""output_tokenId""::text AS ""tokenId"", 'Mint' AS tr_type
            FROM uniswap_v3.""Pair_call_mint"" m
           
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_mint"" l
            ON m.call_tx_hash = l.call_tx_hash
            AND m.call_block_time = l.call_block_time
            
            WHERE l.""output_tokenId""::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (m.amount != 0) --only events that do something
            AND m.contract_address = REPLACE('{{Pool Address}}','0x','\x')::bytea
            AND m.call_success = 'true' AND l.call_success = 'true'
            AND m.""call_block_time"" <= LEAST('{{Reference Date}}',NOW())
    
            
            UNION
            --ADDITIONS TO LIQUIDITY INCREASE
            SELECT
            m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
            m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
            /*l.liquidity,*/ (l.params->'tokenId')::text AS ""tokenId"", 'Mint' AS tr_type
            FROM uniswap_v3.""Pair_call_mint"" m
           
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_increaseLiquidity"" l
            ON m.call_tx_hash = l.call_tx_hash
            AND m.call_block_time = l.call_block_time
            
            WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (m.amount != 0) --only events that do something
            AND m.contract_address = REPLACE('{{Pool Address}}','0x','\x')::bytea
            AND m.call_success = 'true' AND l.call_success = 'true'
            AND m.""call_block_time"" < LEAST('{{Reference Date}}',NOW())
            
            UNION
            -- NEW BURNS // uniswap_v3.""NonfungibleTokenPositionManager_call_burn"" doesn't do anything so jsut decrease liq
            SELECT --negate because these are burns
            (-1)*b.amount AS amount, (-1)*b.output_amount0 AS amount0, (-1)*b.output_amount1 AS amount1, b.contract_address,
            b.call_block_time, b.call_tx_hash, b.""tickLower"", b.""tickUpper"",
            /*l.liquidity,*/ (l.params->'tokenId')::text AS tokenId, 'Burn' AS tr_type
            FROM uniswap_v3.""Pair_call_burn"" b
            
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_decreaseLiquidity"" l
            ON b.call_tx_hash = l.call_tx_hash
            AND b.call_block_time = l.call_block_time
            
            WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (b.amount != 0) --only events that do something
            AND b.contract_address = REPLACE('{{Pool Address}}','0x','\x')::bytea
            AND b.call_success = 'true'
            AND l.call_success = 'true'
            AND l.""call_block_time"" < LEAST('{{Reference Date}}',NOW())
            
            ) lq
        ) la
    --Since we already calc'd running amounts, we can ditch all LP events besides the last one before the 2 day / stuff within the 2 day.
    -- We'll use 'next LP' to do this
    WHERE next_lp = NOW() -- to make sure we're grabbing the latest LP
        -->= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
) a
WHERE running_amount >0 --check this later, but we should be able to ditch these too since matching is on block time and next lp

) b
WHERE last_lp_amount >0
),


trades
AS (
    SELECT pool, ""token0"" AS ""token_a_address"", ""token1"" AS ""token_b_address""
    FROM uniswap_v3.""Factory_evt_PoolCreated"" p
        WHERE p.pool = REPLACE('{{Pool Address}}','0x','\x')::bytea
)

,prices AS
(
SELECT *
FROM
(
    SELECT *,
    DENSE_RANK() OVER(PARTITION BY ""contract_address"" ORDER BY minute DESC) as trank
    FROM prices.""usd"" p
    WHERE p.minute > DATE_TRUNC('{{Time-Series Granularity}}',LEAST('{{Reference Date}}',NOW()) ) - '2 days'::interval
    AND (
        ""contract_address"" = (SELECT DISTINCT ""token_b_address"" FROM trades)
        OR ""contract_address"" = (SELECT DISTINCT ""token_a_address"" FROM trades)
        )
) a
WHERE trank = 1
)

,gs AS
(
SELECT DISTINCT d.token_a_address AS token, gs.hour FROM trades d
INNER JOIN 
(SELECT generate_series(DATE_TRUNC('hour',LEAST('{{Reference Date}}',NOW()) ) - interval '3 days', date_trunc('hour', LEAST('{{Reference Date}}',NOW()) ), '1 hour') AS hour) gs -- Generate all days since the first contract
ON 1=1

UNION

SELECT DISTINCT d.token_b_address AS token, gs.hour FROM trades d
INNER JOIN 
(SELECT generate_series(DATE_TRUNC('hour',LEAST('{{Reference Date}}',NOW()) ) - interval '3 days', date_trunc('hour', LEAST('{{Reference Date}}',NOW()) ), '1 hour') AS hour) gs -- Generate all days since the first contract
ON 1=1
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
hour, token, 
symbol, decimals, median_price
FROM
(
SELECT *,
lead(hour, 1, LEAST('{{Reference Date}}',NOW())  ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour,
    DENSE_RANK() OVER (PARTITION BY token ORDER BY hour DESC) AS trank
FROM
(
SELECT

DATE_TRUNC('hour',hour) AS hour,
t.contract_address AS token, ea.symbol AS symbol, ea.decimals AS decimals,
percentile_cont(0.5) WITHIN GROUP (ORDER BY ""median_price"") AS median_price

FROM dex.""view_token_prices"" t

INNER JOIN (SELECT DISTINCT token FROM gs) c
ON t.contract_address = c.token
INNER JOIN erc20.""tokens"" ea --both need to have known decimals, we're not going to assume anything.
ON ea.""contract_address"" = t.contract_address

WHERE
(ea.decimals IS NOT NULL)
AND median_price > 0

AND DATE_TRUNC('hour',hour) > 
(DATE_TRUNC('{{Time-Series Granularity}}',LEAST('{{Reference Date}}',NOW()) ) - '2 days'::interval)
AND DATE_TRUNC('hour',hour) <= LEAST('{{Reference Date}}',NOW()) + interval '1 day'

GROUP BY 1,2,3,4
) b
) c
WHERE trank = 1

),


last_trade AS
(
SELECT tick, ""contract_address"" FROM
uniswap_v3.""Pair_evt_Swap""
WHERE ""contract_address"" = REPLACE('{{Pool Address}}','0x','\x')::bytea
AND ""evt_block_time"" > 
(DATE_TRUNC('{{Time-Series Granularity}}',LEAST('{{Reference Date}}',NOW()) ) - '90 days'::interval)
ORDER BY ""evt_block_time"" DESC
LIMIT 1
)

,liq_gs_minmax AS
(
SELECT 
ticks,
ticks - ptick AS tickdiff,
100 * ( ( (1.0001)^(ticks - ptick) ) - 1 ) AS tickdiff_pct
/* Formula based on section 4 governance 

"".... The initial fee tiers and tick spacings supported
are 0.05% (with a tick spacing of 10, approximately 0.10% between
initializable ticks), 0.30% (with a tick spacing of 60, approximately
0.60% between initializable ticks), and 1% (with a tick spacing of
200, approximately 2.02% between ticks.""

link: https://uniswap.org/whitepaper-v3.pdf */
FROM
    (
    SELECT
    generate_series(lq.minl, lq.max1, ""tickSpacing"") AS ticks
    , ""tickSpacing"" AS space
    , tick AS ptick
    FROM
    (SELECT tick, ""contract_address"" FROM last_trade) l
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p
        ON p.""pool"" = l.contract_address
    INNER JOIN (SELECT
            contract_address,
            MIN(""tickLower"") AS minl,
            MAX(""tickUpper"") AS max1 FROM get_liquidity GROUP BY 1) lq
        ON p.""pool"" = lq.contract_address
    
    ) lg
)



, stats AS (
SELECT ticks,
price,
sum_usd_per_tick,
CASE WHEN '{{Price Shown}}' = 'B / A' AND price > 0 THEN
1.0/(price::decimal)
WHEN '{{Price Shown}}' = 'A / B' THEN price
ELSE NULL
END AS price,
CASE WHEN '{{Price Shown}}' = 'B / A' THEN
tickdiff_pct*(-1) ELSE tickdiff_pct
END AS tickdiff_pct


FROM
(
SELECT
ticks,
price,
tickdiff_pct,
--price_flip,
SUM(total_usd_per_tick) AS sum_usd_per_tick,

NULL AS current_price
FROM
(

SELECT 
lg.ticks,
lg.tickdiff_pct,
--1.0001^lg.ticks AS price,
 CASE  --assuming 18 for decimals if null
        WHEN lg.ticks < 0 THEN (1.0001^(lg.ticks)) * (10^(ABS(COALESCE(pa.decimals, dpa.decimals,18)-COALESCE(pb.decimals, dpb.decimals,18))))
        ELSE (1.0001^(lg.ticks)) / (10^(ABS(COALESCE(pa.decimals, dpa.decimals,18)-COALESCE(pb.decimals, dpb.decimals,18))))
    END AS price,
--1/(1.0001^(lg.ticks)) AS price_flip,
--""tokenId"",
amount_per_tick,
token_a_usd,
token_b_usd,
( COALESCE(pa.price, dpa.median_price)*(""amount0""/10^(COALESCE(pa.decimals, dpa.decimals))) )
    /tick_breaks AS a_usd_per_tick,
    
( COALESCE(pb.price, dpb.median_price)*(""amount1""/10^(COALESCE(pb.decimals, dpb.decimals))) )
    /tick_breaks AS b_usd_per_tick,

( -- a per tick
( COALESCE(pa.price, dpa.median_price)*(""amount0""/10^(COALESCE(pa.decimals, dpa.decimals))) )
    /tick_breaks
)
+
( -- a per tick
( COALESCE(pb.price, dpb.median_price)*(""amount1""/10^(COALESCE(pb.decimals, dpb.decimals))) )
    /tick_breaks
)
AS total_usd_per_tick

,NULL AS current_price

FROM
(
    
    SELECT l.*, p.""tickSpacing"", ((l.""tickUpper"" - l.""tickLower"")/p.""tickSpacing"")+1 AS tick_breaks, --we add 1 because the LP is initialized on a tick (i.e. 0-20 with a 10 space supports 0, 10, and 20 ticks)
    l.amount / ( (l.""tickUpper"" - l.""tickLower"")/p.""tickSpacing"" ) AS amount_per_tick,
    l.""amount0""/10^(COALESCE(pa.decimals, dpa.decimals)) AS token_a_num,
    COALESCE(pa.price, dpa.median_price)*(l.""amount0""/10^(COALESCE(pa.decimals, dpa.decimals))) AS token_a_usd,
    l.""amount1""/10^(COALESCE(pb.decimals, dpb.decimals)) AS token_b_num,
    COALESCE(pb.price, dpb.median_price)*(l.""amount1""/10^(COALESCE(pb.decimals, dpb.decimals))) AS token_b_usd
    ,p.""token0"",p.""token1""
    FROM get_liquidity l
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p
    ON p.""pool"" = l.contract_address

    -- idk a better way to do this join
    LEFT JOIN prices pa
    ON pa.contract_address = p.""token0""
    LEFT JOIN prices pb
    ON pb.contract_address = p.""token1""
    LEFT JOIN dex_price dpa
    ON dpa.token = p.""token0""
    LEFT JOIN dex_price dpb
    ON dpb.token = p.""token1""
    
    WHERE p.""tickSpacing"" > 0

) ta
INNER JOIN liq_gs_minmax lg
ON lg.ticks <= ta.""tickUpper""
AND lg.ticks >= ta.""tickLower""

    -- idk a better way to do this join
    LEFT JOIN prices pa
    ON pa.contract_address = ta.""token0""
    LEFT JOIN prices pb
    ON pb.contract_address = ta.""token1""
    LEFT JOIN dex_price dpa
    ON dpa.token = ta.""token0""
    LEFT JOIN dex_price dpb
    ON dpb.token = ta.""token1""

) ap

GROUP BY 1,2,3

UNION ALL

SELECT
lt.tick /*1.0001^(lt.tick),*/
, CASE  --assuming 18 for decimals if null
        WHEN lt.tick < 0 THEN (1.0001^(lt.tick)) * (10^(ABS(COALESCE(pa.decimals, dpa.decimals,18)-COALESCE(pb.decimals, dpb.decimals,18))))
        ELSE (1.0001^(lt.tick)) / (10^(ABS(COALESCE(pa.decimals, dpa.decimals,18)-COALESCE(pb.decimals, dpb.decimals,18))))
    END AS price
,NULL, NULL
, CASE  --assuming 18 for decimals if null
        WHEN lt.tick < 0 THEN (1.0001^(lt.tick)) * (10^(ABS(COALESCE(pa.decimals, dpa.decimals,18)-COALESCE(pb.decimals, dpb.decimals,18))))
        ELSE (1.0001^(lt.tick)) / (10^(ABS(COALESCE(pa.decimals, dpa.decimals,18)-COALESCE(pb.decimals, dpb.decimals,18))))
    END AS price
FROM last_trade lt
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p
    ON p.""pool"" = lt.contract_address
    LEFT JOIN prices pa
    ON pa.contract_address = p.""token0""
    LEFT JOIN prices pb
    ON pb.contract_address = p.""token1""
    LEFT JOIN dex_price dpa
    ON dpa.token = p.""token0""
    LEFT JOIN dex_price dpb
    ON dpb.token = p.""token1""
) eh
)


SELECT 

range,
sum_usd_per_tick_p,
sum_usd_per_tick_p/sum_all AS p_pct,

sum_usd_per_tick_n,
sum_usd_per_tick_n/sum_all AS n_pct,

sum_usd_per_tick_abs,
sum_usd_per_tick_abs/sum_all AS a_pct,
100*(sum_usd_per_tick_abs/sum_all) AS a_pct_100

FROM
(
    SELECT
    '0.5%' AS range,
    SUM(CASE WHEN tickdiff_pct BETWEEN 0 AND 0.5 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_p,
    SUM(CASE WHEN tickdiff_pct BETWEEN -0.5 AND 0 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_n,
    SUM(CASE WHEN tickdiff_pct BETWEEN -0.5 AND 0.5 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_abs,
    SUM(sum_usd_per_tick) AS sum_all
    FROM stats
    
    UNION ALL
    
    SELECT
    '1%' AS range,
    SUM(CASE WHEN tickdiff_pct BETWEEN 0 AND 1 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_p,
    SUM(CASE WHEN tickdiff_pct BETWEEN -1 AND 0 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_n,
    SUM(CASE WHEN tickdiff_pct BETWEEN -1 AND 1 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_abs,
    SUM(sum_usd_per_tick) AS sum_all
    FROM stats
    
    UNION ALL
    
    SELECT
    '2%' AS range,
    SUM(CASE WHEN tickdiff_pct BETWEEN 0 AND 2 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_p,
    SUM(CASE WHEN tickdiff_pct BETWEEN -2 AND 0 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_n,
    SUM(CASE WHEN tickdiff_pct BETWEEN -2 AND 2 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_abs,
    SUM(sum_usd_per_tick) AS sum_all
    FROM stats
    
    UNION ALL
    
    SELECT
    '3%' AS range,
    SUM(CASE WHEN tickdiff_pct BETWEEN 0 AND 3 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_p,
    SUM(CASE WHEN tickdiff_pct BETWEEN -3 AND 0 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_n,
    SUM(CASE WHEN tickdiff_pct BETWEEN -3 AND 3 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_abs,
    SUM(sum_usd_per_tick) AS sum_all
    FROM stats
    
    UNION ALL
    
    SELECT
    '4%' AS range,
    SUM(CASE WHEN tickdiff_pct BETWEEN 0 AND 4 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_p,
    SUM(CASE WHEN tickdiff_pct BETWEEN -4 AND 0 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_n,
    SUM(CASE WHEN tickdiff_pct BETWEEN -4 AND 4 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_abs,
    SUM(sum_usd_per_tick) AS sum_all
    FROM stats
    
    UNION ALL
    
    SELECT 
    '5%' AS range,
    SUM(CASE WHEN tickdiff_pct BETWEEN 0 AND 5 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_p,
    SUM(CASE WHEN tickdiff_pct BETWEEN -5 AND 0 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_n,
    SUM(CASE WHEN tickdiff_pct BETWEEN -5 AND 5 THEN sum_usd_per_tick ELSE 0 END) AS sum_usd_per_tick_abs,
    SUM(sum_usd_per_tick) AS sum_all
    FROM stats
) form_table"
95555,Uniswap v3 Pair Deep-Dive,,counter,"WITH trades
AS (
    SELECT 
    DATE_TRUNC('{{Time-Series Granularity}}',t.""block_time"") AS dt,
    project, version,
    CASE WHEN version = '1' THEN project
    ELSE project || ' V' || version || ' - ' || ( ROUND(p.fee/1e4,2) )::text || '%'
    END as proj_v,
    ""exchange_contract_address"",
    t.""token_a_address"",
    t.""token_b_address"",
    t.""token_a_symbol"",
    t.""token_b_symbol"",
    t.""token_a_symbol"" || '/' || t.""token_b_symbol"" AS pair,
    t.""token_a_symbol"" || '/' || t.""token_b_symbol"" || ' - ' || ( ROUND(p.fee/1e4,2) )::text || '%' AS pool,
    SUM(t.token_a_amount) AS token_a_amount,
    SUM(t.token_b_amount) AS token_b_amount,
    --t.trader_a AS user,
    SUM(t.usd_amount) AS usd_traded,
    COUNT(t.usd_amount) AS num_trades,
    COUNT(DISTINCT t.trader_a) AS num_users
    
    FROM dex.trades t
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p
    ON t.exchange_contract_address = p.pool
    
    WHERE t.project = 'Uniswap'
    AND t.version = '3'
    AND t.""block_time"" > LEAST('{{Reference Date}}',NOW()) - '{{Trailing Num Days}} days'::interval  - '{{UTC Offset}} hours'::interval
    AND t.""exchange_contract_address"" = REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
    
    GROUP BY 1,2,3,4,5,6,7,8,9,10,11
)
,prices AS
(
SELECT * FROM prices.""usd"" p
WHERE p.minute > LEAST('{{Reference Date}}',NOW()) - '{{Trailing Num Days}} days'::interval  - '{{UTC Offset}} hours'::interval
AND (
    ""contract_address"" IN (SELECT ""token_b_address"" FROM trades GROUP BY 1)
    OR ""contract_address"" IN (SELECT ""token_a_address"" FROM trades GROUP BY 1)
    )
)

,projects AS
(
    SELECT DISTINCT
    ""exchange_contract_address"", proj_v, pair, pool,
    token_a_address, token_b_address, token_a_symbol, token_b_symbol
    FROM trades
)

,gs AS
(
SELECT DISTINCT d.token_a_address AS token, gs.hour FROM trades d
INNER JOIN 
(SELECT generate_series(DATE_TRUNC('hour',LEAST(('{{Reference Date}}'::date - '{{UTC Offset}} hours'::interval),NOW()) ) - interval '{{Trailing Num Days}} day', date_trunc('hour', LEAST(('{{Reference Date}}'::date - '{{UTC Offset}} hours'::interval),NOW()) ), '1 hour') AS hour) gs -- Generate all days since the first contract
ON 1=1

UNION

SELECT DISTINCT d.token_b_address AS token, gs.hour FROM trades d
INNER JOIN 
(SELECT generate_series(DATE_TRUNC('hour',LEAST(('{{Reference Date}}'::date - '{{UTC Offset}} hours'::interval),NOW()) ) - interval '{{Trailing Num Days}} day', date_trunc('hour', LEAST(('{{Reference Date}}'::date - '{{UTC Offset}} hours'::interval),NOW()) ), '1 hour') AS hour) gs -- Generate all days since the first contract
ON 1=1
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
gs.hour, gs.token, 
symbol, decimals, median_price
FROM
(
SELECT *,
lead(hour, 1, LEAST('{{Reference Date}}'::date - '{{UTC Offset}} hours'::interval,NOW())  ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour
FROM
(
SELECT

DATE_TRUNC('hour',hour) AS hour,
t.contract_address AS token, ea.symbol AS symbol, ea.decimals AS decimals,
percentile_cont(0.5) WITHIN GROUP (ORDER BY ""median_price"") AS median_price

FROM dex.""view_token_prices"" t

INNER JOIN (SELECT token FROM gs GROUP BY 1) c
ON t.contract_address = c.token
INNER JOIN erc20.""tokens"" ea --both need to have known decimals, we're not going to assume anything.
ON ea.""contract_address"" = t.contract_address

WHERE
(ea.decimals IS NOT NULL)
AND median_price > 0

AND DATE_TRUNC('hour',hour) > 
(DATE_TRUNC('{{Time-Series Granularity}}',LEAST('{{Reference Date}}'::date,NOW()) ) - '{{Trailing Num Days}} days'::interval - '{{UTC Offset}} hours'::interval)
AND DATE_TRUNC('hour',hour) <= LEAST('{{Reference Date}}'::date - '{{UTC Offset}} hours'::interval,NOW()) + interval '1 day'

GROUP BY 1,2,3,4
) b
) c
INNER JOIN gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour
AND gs.token = c.token
)

, tvl AS (

SELECT DISTINCT
dt, 
exchange_contract_address,
SUM(delta_tvl) OVER (PARTITION BY dt, exchange_contract_address)
    AS delta_tvl,
SUM(add_tvl) OVER (PARTITION BY dt, exchange_contract_address)
    AS add_tvl,
LAST_VALUE(running_tvl) OVER (PARTITION BY dt, exchange_contract_address 
                            ORDER BY hour::timestamp ASC
                            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
    AS running_tvl

FROM
(
SELECT
hour,
DATE_TRUNC('{{Time-Series Granularity}}',hour) AS dt,
exchange_contract_address,
COALESCE(SUM(val_usd),0) AS delta_tvl,
COALESCE(SUM(addval_usd),0) AS add_tvl,
COALESCE(SUM(sumval_usd),0) AS running_tvl

FROM
(
SELECT 
gs.hour + '{{UTC Offset}} hours'::interval AS hour, gs.token, exchange_contract_address,
CASE WHEN gs.hour = c.hour THEN val ELSE 0 END AS val,
CASE WHEN gs.hour = c.hour THEN val/(10^COALESCE(p.decimals,dp.decimals)) ELSE 0 END AS val_tokens,
CASE WHEN gs.hour = c.hour THEN COALESCE(p.price,dp.median_price)*(val/(10^COALESCE(p.decimals,dp.decimals))) ELSE 0 END AS val_usd,

CASE WHEN gs.hour = c.hour THEN addval ELSE 0 END AS addval,
CASE WHEN gs.hour = c.hour THEN addval/(10^COALESCE(p.decimals,dp.decimals)) ELSE 0 END AS addval_tokens,
CASE WHEN gs.hour = c.hour THEN COALESCE(p.price,dp.median_price)*(addval/(10^COALESCE(p.decimals,dp.decimals))) ELSE 0 END AS addval_usd,

sumval,
sumval/(10^COALESCE(p.decimals,dp.decimals)) AS sumval_tokens,
COALESCE(p.price,dp.median_price)*(sumval/(10^COALESCE(p.decimals,dp.decimals))) AS sumval_usd


FROM
(
    SELECT
    *,
    lead(hour, 1, LEAST('{{Reference Date}}',NOW())  ) OVER (PARTITION BY contract_address, exchange_contract_address
                            ORDER BY hour asc) AS next_hour,
    SUM(val) OVER (PARTITION BY contract_address, exchange_contract_address ORDER BY hour ASC) AS sumval
    FROM
    (
    SELECT
    hour,
    contract_address,
    exchange_contract_address,
    SUM(val) AS val,
    SUM(CASE WHEN val >0 THEN val ELSE 0 END) AS addval
    --SUM(val) OVER (PARTITION BY contract_address, exchange_contract_address ORDER BY hour ASC) AS sumval
    --SUM( price*(val/(10^decimals)) ) AS usd_tvl
    
    FROM (
        SELECT 
        DATE_TRUNC('hour',e.""evt_block_time"") AS hour, ""to"" AS exchange_contract_address,
        e.""contract_address"", SUM(value) AS val
        FROM erc20.""ERC20_evt_Transfer"" e
        
        WHERE ""to"" IN (SELECT exchange_contract_address FROM trades GROUP BY 1)

        GROUP BY 1,2,3
        
        UNION ALL
        
        SELECT 
        DATE_TRUNC('hour',eb.""evt_block_time"") AS hour, ""from"" AS exchange_contract_address,
        eb.""contract_address"", SUM(-value) AS val
        FROM erc20.""ERC20_evt_Transfer"" eb
        
        WHERE ""from"" IN (SELECT exchange_contract_address FROM trades GROUP BY 1)
        
        GROUP BY 1,2,3
        
        ) tr
        GROUP BY 1,2,3
        ) mod

) c
INNER JOIN gs
ON c.hour <= gs.hour
AND gs.hour < c.next_hour
AND gs.token = c.contract_address
LEFT JOIN prices p
        ON p.""contract_address"" = gs.token
        AND
        CASE WHEN DATE_TRUNC('hour',gs.hour) = DATE_TRUNC('hour',LEAST('{{Reference Date}}',NOW()) )
        THEN p.""minute"" = DATE_TRUNC('hour',LEAST('{{Reference Date}}',NOW()) )
        ELSE p.""minute"" = DATE_TRUNC('minute',gs.hour) + interval '59 minutes'
        END
    LEFT JOIN dex_price dp
        ON gs.token = dp.token
        AND dp.hour = gs.hour     
        AND p.price IS NULL
        
WHERE gs.hour > DATE_TRUNC('{{Time-Series Granularity}}',LEAST('{{Reference Date}}',NOW()) ) - '{{Trailing Num Days}} days'::interval  - '{{UTC Offset}} hours'::interval
    
) a

GROUP BY 1,2,3
) b

)

SELECT
tvl.dt,
--pr.proj_v, 
COALESCE(tr.usd_traded,0) AS usd_traded, 
tvl.running_tvl,
COALESCE(tr.num_trades,0) AS num_trades,
tvl.delta_tvl, tvl.add_tvl, 

'<a href=""https://info.uniswap.org/#/pools/' || REPLACE(tvl.exchange_contract_address::text,'\','0') || '"">' || REPLACE(tvl.exchange_contract_address::text,'\','0') || '</a>' AS pool_url,

 tvl.exchange_contract_address,
SUM(usd_traded) OVER (PARTITION BY tvl.exchange_contract_address ORDER BY tvl.dt ASC) AS running_usd,
SUM(num_trades) OVER (PARTITION BY tvl.exchange_contract_address ORDER BY tvl.dt ASC) AS running_trades,
pr.pair, pr.pool,
 pr.token_a_address, pr.token_b_address, pr.token_a_symbol, pr.token_b_symbol

FROM tvl
INNER JOIN projects pr
ON pr.exchange_contract_address = tvl.exchange_contract_address
LEFT JOIN trades tr
ON tr.""exchange_contract_address"" = tvl.exchange_contract_address
AND tr.dt = tvl.dt
    
ORDER BY dt DESC --this is important for counters"
95789,Uniswap v3 Pair Deep-Dive (Depth by LP),Top 100 LP Positions by TVL: Zoomed in on the 'Tick Range' set from the current price.,table,"WITH get_liquidity AS ( --this is to find the liquidity of each position at trade time
SELECT *
FROM
(
SELECT *,
    LAST_VALUE(a.next_lp_amount) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS last_lp_amount
    FROM
    (
    SELECT *,
    lead(running_amount, 1, running_amount) OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS next_lp_amount
    FROM
    (
        SELECT amount, amount0, amount1, contract_address,call_block_time, call_tx_hash,
        ""tickLower"",""tickUpper"", /*liquidity,*/ ""tokenId"", tr_type,
        lead(call_block_time, 1, now()) OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS next_lp, --to help key in on the right lp when joining - for preformance
        lag(call_block_time, 1, '01-01-2000') OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS previous_lp,
        SUM(amount) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount,
        SUM(amount0) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount0,
        SUM(amount1) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount1,
        MIN(call_block_time) OVER(PARTITION BY ""tokenId"") AS liq_start
        
        FROM ( --this is a mess. We union new mints + adds to liquidity + new burns + removals from liquidity. eesh
            -- NEW MINTS
            SELECT
            m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
            m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
            /*l.liquidity,*/ l.""output_tokenId""::text AS ""tokenId"", 'Mint' AS tr_type
            FROM uniswap_v3.""Pair_call_mint"" m
           
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_mint"" l
            ON m.call_tx_hash = l.call_tx_hash
            AND m.call_block_time = l.call_block_time
            
            WHERE l.""output_tokenId""::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (m.amount != 0) --only events that do something
            AND m.contract_address = REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
            AND m.call_success = 'true' AND l.call_success = 'true'
            AND m.""call_block_time"" <= LEAST('{{Reference Date}}',NOW())
    
            
            UNION
            --ADDITIONS TO LIQUIDITY INCREASE
            SELECT
            m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
            m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
            /*l.liquidity,*/ (l.params->'tokenId')::text AS ""tokenId"", 'Mint' AS tr_type
            FROM uniswap_v3.""Pair_call_mint"" m
           
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_increaseLiquidity"" l
            ON m.call_tx_hash = l.call_tx_hash
            AND m.call_block_time = l.call_block_time
            
            WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (m.amount != 0) --only events that do something
            AND m.contract_address = REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
            AND m.call_success = 'true' AND l.call_success = 'true'
            AND m.""call_block_time"" < LEAST('{{Reference Date}}',NOW())
            
            UNION
            -- NEW BURNS // uniswap_v3.""NonfungibleTokenPositionManager_call_burn"" doesn't do anything so jsut decrease liq
            SELECT --negate because these are burns
            (-1)*b.amount AS amount, (-1)*b.output_amount0 AS amount0, (-1)*b.output_amount1 AS amount1, b.contract_address,
            b.call_block_time, b.call_tx_hash, b.""tickLower"", b.""tickUpper"",
            /*l.liquidity,*/ (l.params->'tokenId')::text AS tokenId, 'Burn' AS tr_type
            FROM uniswap_v3.""Pair_call_burn"" b
            
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_decreaseLiquidity"" l
            ON b.call_tx_hash = l.call_tx_hash
            AND b.call_block_time = l.call_block_time
            
            WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (b.amount != 0) --only events that do something
            AND b.contract_address = REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
            AND b.call_success = 'true'
            AND l.call_success = 'true'
            AND l.""call_block_time"" < LEAST('{{Reference Date}}',NOW())
            
            ) lq
        ) la
    --Since we already calc'd running amounts, we can ditch all LP events besides the last one before the 2 day / stuff within the 2 day.
    -- We'll use 'next LP' to do this
    WHERE next_lp = NOW() -- to make sure we're grabbing the latest LP
        -->= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
) a
WHERE running_amount >0 --check this later, but we should be able to ditch these too since matching is on block time and next lp

) b
WHERE last_lp_amount >0 -- only get what's currently active
),



trades
AS (
    SELECT pool, ""token0"" AS ""token_a_address"", ""token1"" AS ""token_b_address""
    FROM uniswap_v3.""Factory_evt_PoolCreated"" p
        WHERE p.pool = REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
)
,prices AS
(
SELECT *
FROM
(
    SELECT *,
    DENSE_RANK() OVER(PARTITION BY ""contract_address"" ORDER BY minute DESC) as trank
    FROM prices.""usd"" p
    WHERE p.minute > DATE_TRUNC('minute',LEAST('{{Reference Date}}',NOW()) ) - '2 days'::interval
    AND (
        ""contract_address"" = (SELECT DISTINCT ""token_b_address"" FROM trades)
        OR ""contract_address"" = (SELECT DISTINCT ""token_a_address"" FROM trades)
        )
) a
WHERE trank = 1
)
,gs AS
(
SELECT DISTINCT d.token_a_address AS token, gs.hour FROM trades d
INNER JOIN 
(SELECT generate_series(DATE_TRUNC('hour',LEAST('{{Reference Date}}',NOW()) ) - interval '3 days', date_trunc('hour', LEAST('{{Reference Date}}',NOW()) ), '1 hour') AS hour) gs -- Generate all days since the first contract
ON 1=1

UNION

SELECT DISTINCT d.token_b_address AS token, gs.hour FROM trades d
INNER JOIN 
(SELECT generate_series(DATE_TRUNC('hour',LEAST('{{Reference Date}}',NOW()) ) - interval '3 days', date_trunc('hour', LEAST('{{Reference Date}}',NOW()) ), '1 hour') AS hour) gs -- Generate all days since the first contract
ON 1=1
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
hour, token, 
symbol, decimals, median_price
FROM
(
SELECT *,
lead(hour, 1, LEAST('{{Reference Date}}',NOW())  ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour,
    DENSE_RANK() OVER (PARTITION BY token ORDER BY hour DESC) AS trank
FROM
(
SELECT

DATE_TRUNC('hour',hour) AS hour,
t.contract_address AS token, ea.symbol AS symbol, ea.decimals AS decimals,
percentile_cont(0.5) WITHIN GROUP (ORDER BY ""median_price"") AS median_price

FROM dex.""view_token_prices"" t

INNER JOIN (SELECT DISTINCT token FROM gs) c
ON t.contract_address = c.token
INNER JOIN erc20.""tokens"" ea --both need to have known decimals, we're not going to assume anything.
ON ea.""contract_address"" = t.contract_address

WHERE
(ea.decimals IS NOT NULL)
AND median_price > 0

AND DATE_TRUNC('hour',hour) > 
(DATE_TRUNC('minute',LEAST('{{Reference Date}}',NOW()) ) - '2 days'::interval)
AND DATE_TRUNC('hour',hour) <= LEAST('{{Reference Date}}',NOW()) + interval '1 day'

GROUP BY 1,2,3,4
) b
) c
WHERE trank = 1

),

last_trade AS
(
SELECT tick, ""contract_address"" FROM
uniswap_v3.""Pair_evt_Swap""
WHERE ""contract_address"" = REPLACE('{{Pool Address}}','0x','\x')::bytea
AND ""evt_block_time"" > 
(DATE_TRUNC('minute',LEAST('{{Reference Date}}',NOW()) ) - '365 days'::interval)
ORDER BY ""evt_block_time"" DESC
LIMIT 1
)

-- alt idea is take the current price +/- 50%
,liq_gs_old AS
(
SELECT
generate_series(minl, maxl, space) AS ticks

FROM
    (
    SELECT
    p.""tickSpacing"" AS space,
    MIN(""tickLower"") AS minl,
    MAX(""tickUpper"") AS maxl
    FROM get_liquidity l
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p
    ON p.""pool"" = l.contract_address
    
    GROUP BY 1
    
    ) lil
)

,liq_gs AS
(
SELECT 
ticks,
ticks - ptick AS tickdiff,
100 * ( ( (1.0001)^(ticks - ptick) ) - 1 ) AS tickdiff_pct
/* Formula based on section 4 governance 

"".... The initial fee tiers and tick spacings supported
are 0.05% (with a tick spacing of 10, approximately 0.10% between
initializable ticks), 0.30% (with a tick spacing of 60, approximately
0.60% between initializable ticks), and 1% (with a tick spacing of
200, approximately 2.02% between ticks.""

link: https://uniswap.org/whitepaper-v3.pdf */
FROM
    (
    SELECT
    generate_series(tick - ('{{Tick Range}}'*""tickSpacing""), tick + ('{{Tick Range}}'*""tickSpacing""), ""tickSpacing"") AS ticks
    , ""tickSpacing"" AS space
    , tick AS ptick
    FROM
    (SELECT tick, ""contract_address"" FROM last_trade) l
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p
        ON p.""pool"" = l.contract_address
    
    ) lg
)

SELECT
lp_map,
ticks,
price,price_flip,

CASE WHEN '{{Price Shown}}' = 'B / A' THEN
price_flip ELSE price
END AS selected_price,

SUM(amount_per_tick) AS amount_per_tick,
SUM(total_usd_per_tick) AS total_usd_per_tick

FROM
(

SELECT *,
CASE WHEN price > 0 THEN
1.0/price ELSE NULL
END AS price_flip,
CASE WHEN lp_rank <= 100 AND total_usd_per_tick >= 10 THEN ""tokenId""
ELSE 'Other' END AS lp_map

FROM
(
SELECT 
lg.ticks,
--1.0001^lg.ticks AS price,
 CASE  --assuming 18 for decimals if null
        WHEN lg.ticks < 0 THEN (1.0001^(lg.ticks)) * (10^(ABS(COALESCE(pa.decimals, dpa.decimals,18)-COALESCE(pb.decimals, dpb.decimals,18))))
        ELSE (1.0001^(lg.ticks)) / (10^(ABS(COALESCE(pa.decimals, dpa.decimals,18)-COALESCE(pb.decimals, dpb.decimals,18))))
    END AS price,
--1/(1.0001^(lg.ticks)) AS price_flip,
""tokenId"",
amount_per_tick,
token_a_usd,
token_b_usd,
DENSE_RANK() OVER (ORDER BY token_a_usd + token_b_usd DESC) AS lp_rank,
( COALESCE(pa.price, dpa.median_price)*(""running_amount0""/10^(COALESCE(pa.decimals, dpa.decimals))) )
    /tick_breaks AS a_usd_per_tick,
    
( COALESCE(pb.price, dpb.median_price)*(""running_amount1""/10^(COALESCE(pb.decimals, dpb.decimals))) )
    /tick_breaks AS b_usd_per_tick,

( -- a per tick
( COALESCE(pa.price, dpa.median_price)*(""running_amount0""/10^(COALESCE(pa.decimals, dpa.decimals))) )
    /tick_breaks
)
+
( -- a per tick
( COALESCE(pb.price, dpb.median_price)*(""running_amount1""/10^(COALESCE(pb.decimals, dpb.decimals))) )
    /tick_breaks
)
AS total_usd_per_tick

,NULL AS current_price

FROM
(
    
    SELECT l.*, p.""tickSpacing"", ((l.""tickUpper"" - l.""tickLower"")/p.""tickSpacing"")+1 AS tick_breaks, --we add 1 because the LP is initialized on a tick (i.e. 0-20 with a 10 space supports 0, 10, and 20 ticks)
    l.running_amount / ( (l.""tickUpper"" - l.""tickLower"")/p.""tickSpacing"" ) AS amount_per_tick,
    l.""running_amount0""/10^(COALESCE(pa.decimals, dpa.decimals)) AS token_a_num,
    COALESCE(pa.price, dpa.median_price)*(l.""running_amount0""/10^(COALESCE(pa.decimals, dpa.decimals))) AS token_a_usd,
    l.""running_amount1""/10^(COALESCE(pb.decimals, dpb.decimals)) AS token_b_num,
    COALESCE(pb.price, dpb.median_price)*(l.""running_amount1""/10^(COALESCE(pb.decimals, dpb.decimals))) AS token_b_usd
    ,p.""token0"",p.""token1""
    FROM get_liquidity l
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p
    ON p.""pool"" = l.contract_address

    -- idk a better way to do this join
    LEFT JOIN prices pa
    ON pa.contract_address = p.""token0""
    LEFT JOIN prices pb
    ON pb.contract_address = p.""token1""
    LEFT JOIN dex_price dpa
    ON dpa.token = p.""token0""
    LEFT JOIN dex_price dpb
    ON dpb.token = p.""token1""

) ta
RIGHT JOIN liq_gs lg
ON lg.ticks <= ta.""tickUpper""
AND lg.ticks >= ta.""tickLower""

    -- idk a better way to do this join
    LEFT JOIN prices pa
    ON pa.contract_address = ta.""token0""
    LEFT JOIN prices pb
    ON pb.contract_address = ta.""token1""
    LEFT JOIN dex_price dpa
    ON dpa.token = ta.""token0""
    LEFT JOIN dex_price dpb
    ON dpb.token = ta.""token1""

WHERE lg.ticks IS NOT NULL
/*UNION ALL

SELECT
lt.tick, 1.0001^(lt.tick),1/(1.0001^(lt.tick)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,
1/(1.0001^(lt.tick))
FROM last_trade lt*/
) eh

--WHERE lp_rank <= 1000 --top 1000 liquidity positions
) e
GROUP BY 1,2,3,4

ORDER BY SUM(total_usd_per_tick) ASC
"
95752,Uniswap v3 Pair Deep-Dive (Depth),,table,"WITH get_liquidity AS ( --this is to find the liquidity of each position at trade time
SELECT *
FROM
(
SELECT *,
    LAST_VALUE(a.next_lp_amount) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS last_lp_amount
    FROM
    (
    SELECT *,
    lead(running_amount, 1, running_amount) OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS next_lp_amount
    FROM
    (
        SELECT amount, amount0, amount1, contract_address,call_block_time, call_tx_hash,
        ""tickLower"",""tickUpper"", /*liquidity,*/ ""tokenId"", tr_type,
        lead(call_block_time, 1, now()) OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS next_lp, --to help key in on the right lp when joining - for preformance
        lag(call_block_time, 1, '01-01-2000') OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS previous_lp,
        SUM(amount) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount,
        SUM(amount0) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount0,
        SUM(amount1) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount1,
        MIN(call_block_time) OVER(PARTITION BY ""tokenId"") AS liq_start
        
        FROM ( --this is a mess. We union new mints + adds to liquidity + new burns + removals from liquidity. eesh
            -- NEW MINTS
            SELECT
            m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
            m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
            /*l.liquidity,*/ l.""output_tokenId""::text AS ""tokenId"", 'Mint' AS tr_type
            FROM uniswap_v3.""Pair_call_mint"" m
           
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_mint"" l
            ON m.call_tx_hash = l.call_tx_hash
            AND m.call_block_time = l.call_block_time
            
            WHERE l.""output_tokenId""::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (m.amount != 0) --only events that do something
            AND m.contract_address = REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
            AND m.call_success = 'true' AND l.call_success = 'true'
            AND m.""call_block_time"" <= LEAST('{{Reference Date}}',NOW())
    
            
            UNION
            --ADDITIONS TO LIQUIDITY INCREASE
            SELECT
            m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
            m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
            /*l.liquidity,*/ (l.params->'tokenId')::text AS ""tokenId"", 'Mint' AS tr_type
            FROM uniswap_v3.""Pair_call_mint"" m
           
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_increaseLiquidity"" l
            ON m.call_tx_hash = l.call_tx_hash
            AND m.call_block_time = l.call_block_time
            
            WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (m.amount != 0) --only events that do something
            AND m.contract_address = REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
            AND m.call_success = 'true' AND l.call_success = 'true'
            AND m.""call_block_time"" < LEAST('{{Reference Date}}',NOW())
            
            UNION
            -- NEW BURNS // uniswap_v3.""NonfungibleTokenPositionManager_call_burn"" doesn't do anything so jsut decrease liq
            SELECT --negate because these are burns
            (-1)*b.amount AS amount, (-1)*b.output_amount0 AS amount0, (-1)*b.output_amount1 AS amount1, b.contract_address,
            b.call_block_time, b.call_tx_hash, b.""tickLower"", b.""tickUpper"",
            /*l.liquidity,*/ (l.params->'tokenId')::text AS tokenId, 'Burn' AS tr_type
            FROM uniswap_v3.""Pair_call_burn"" b
            
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_decreaseLiquidity"" l
            ON b.call_tx_hash = l.call_tx_hash
            AND b.call_block_time = l.call_block_time
            
            WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (b.amount != 0) --only events that do something
            AND b.contract_address = REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
            AND b.call_success = 'true'
            AND l.call_success = 'true'
            AND l.""call_block_time"" < LEAST('{{Reference Date}}',NOW())
            
            ) lq
        ) la
    --Since we already calc'd running amounts, we can ditch all LP events besides the last one before the 2 day / stuff within the 2 day.
    -- We'll use 'next LP' to do this
    WHERE next_lp = NOW() -- to make sure we're grabbing the latest LP
        -->= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
) a
WHERE running_amount >0 --check this later, but we should be able to ditch these too since matching is on block time and next lp

) b
WHERE last_lp_amount >0
)

,trades
AS (
    SELECT pool, ""token0"" AS ""token_a_address"", ""token1"" AS ""token_b_address""
    FROM uniswap_v3.""Factory_evt_PoolCreated"" p
        WHERE p.pool = REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
)

,prices AS
(
SELECT *
FROM
(
    SELECT *,
    DENSE_RANK() OVER(PARTITION BY ""contract_address"" ORDER BY minute DESC) as trank
    FROM prices.""usd"" p
    WHERE p.minute > DATE_TRUNC('minute',LEAST('{{Reference Date}}',NOW()) ) - '2 days'::interval
    AND (
        ""contract_address"" = (SELECT DISTINCT ""token_b_address"" FROM trades)
        OR ""contract_address"" = (SELECT DISTINCT ""token_a_address"" FROM trades)
        )
) a
WHERE trank = 1
)

,gs AS
(
SELECT DISTINCT d.token_a_address AS token, gs.hour FROM trades d
INNER JOIN 
(SELECT generate_series(DATE_TRUNC('hour',LEAST('{{Reference Date}}',NOW()) ) - interval '3 days', date_trunc('hour', LEAST('{{Reference Date}}',NOW()) ), '1 hour') AS hour) gs -- Generate all days since the first contract
ON 1=1

UNION

SELECT DISTINCT d.token_b_address AS token, gs.hour FROM trades d
INNER JOIN 
(SELECT generate_series(DATE_TRUNC('hour',LEAST('{{Reference Date}}',NOW()) ) - interval '3 days', date_trunc('hour', LEAST('{{Reference Date}}',NOW()) ), '1 hour') AS hour) gs -- Generate all days since the first contract
ON 1=1
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
hour, token, 
symbol, decimals, median_price
FROM
(
SELECT *,
lead(hour, 1, LEAST('{{Reference Date}}',NOW())  ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour,
    DENSE_RANK() OVER (PARTITION BY token ORDER BY hour DESC) AS trank
FROM
(
SELECT

DATE_TRUNC('hour',hour) AS hour,
t.contract_address AS token, ea.symbol AS symbol, ea.decimals AS decimals,
percentile_cont(0.5) WITHIN GROUP (ORDER BY ""median_price"") AS median_price

FROM dex.""view_token_prices"" t

INNER JOIN (SELECT DISTINCT token FROM gs) c
ON t.contract_address = c.token
INNER JOIN erc20.""tokens"" ea --both need to have known decimals, we're not going to assume anything.
ON ea.""contract_address"" = t.contract_address

WHERE
(ea.decimals IS NOT NULL)
AND median_price > 0

AND DATE_TRUNC('hour',hour) > 
(DATE_TRUNC('minute',LEAST('{{Reference Date}}',NOW()) ) - '2 days'::interval)
AND DATE_TRUNC('hour',hour) <= LEAST('{{Reference Date}}',NOW()) + interval '1 day'

GROUP BY 1,2,3,4
) b
) c
WHERE trank = 1

),


last_trade AS
(
SELECT tick, ""contract_address"" FROM
uniswap_v3.""Pair_evt_Swap""
WHERE ""contract_address"" = REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
AND ""evt_block_time"" > 
(DATE_TRUNC('minute',LEAST('{{Reference Date}}',NOW()) ) - '365 days'::interval)
ORDER BY ""evt_block_time"" DESC
LIMIT 1
)

-- alt idea is take the current price +/- 50%
,liq_gs_old AS
(
SELECT
generate_series(minl, maxl, space) AS ticks

FROM
    (
    SELECT
    p.""tickSpacing"" AS space,
    MIN(""tickLower"") AS minl,
    MAX(""tickUpper"") AS maxl
    FROM get_liquidity l
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p
    ON p.""pool"" = l.contract_address
    
    GROUP BY 1
    
    ) lil
)

,liq_gs AS
(
SELECT 
ticks,
ticks - ptick AS tickdiff,
100 * ( ( (1.0001)^(ticks - ptick) ) - 1 ) AS tickdiff_pct
/* Formula based on section 4 governance 

"".... The initial fee tiers and tick spacings supported
are 0.05% (with a tick spacing of 10, approximately 0.10% between
initializable ticks), 0.30% (with a tick spacing of 60, approximately
0.60% between initializable ticks), and 1% (with a tick spacing of
200, approximately 2.02% between ticks.""

link: https://uniswap.org/whitepaper-v3.pdf */
FROM
    (
    SELECT
    generate_series(tick - ('{{Tick Range}}'*""tickSpacing""), tick + ('{{Tick Range}}'*""tickSpacing""), ""tickSpacing"") AS ticks
    , ""tickSpacing"" AS space
    , tick AS ptick
    FROM
    (SELECT tick, ""contract_address"" FROM last_trade) l
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p
        ON p.""pool"" = l.contract_address
    
    ) lg
)


SELECT *,

CASE WHEN '{{Price Shown}}' = 'B / A' THEN
price_flip ELSE price
END AS selected_price,

CASE WHEN current_price IS NULL THEN NULL
WHEN '{{Price Shown}}' = 'B / A' THEN
price_flip ELSE price
END AS selected_price_two -- for charts so we can use it twice

FROM
(

SELECT *,
CASE WHEN price > 0 THEN
1.0/(price::decimal) ELSE NULL
END AS price_flip

FROM
(
SELECT
ticks,
price,
tickdiff_pct,
--price_flip,
SUM(total_usd_per_tick) AS sum_usd_per_tick,

NULL AS current_price
FROM
(

SELECT 
lg.ticks,
lg.tickdiff_pct,
--1.0001^lg.ticks AS price,
 CASE  --assuming 18 for decimals if null
        WHEN lg.ticks < 0 THEN (1.0001^(lg.ticks)) * (10^(ABS(COALESCE(pa.decimals, dpa.decimals,18)-COALESCE(pb.decimals, dpb.decimals,18))))
        ELSE (1.0001^(lg.ticks)) / (10^(ABS(COALESCE(pa.decimals, dpa.decimals,18)-COALESCE(pb.decimals, dpb.decimals,18))))
    END AS price,
--1/(1.0001^(lg.ticks)) AS price_flip,
--""tokenId"",
amount_per_tick,
token_a_usd,
token_b_usd,
( COALESCE(pa.price, dpa.median_price)*(""running_amount0""/10^(COALESCE(pa.decimals, dpa.decimals))) )
    /tick_breaks AS a_usd_per_tick,
    
( COALESCE(pb.price, dpb.median_price)*(""running_amount1""/10^(COALESCE(pb.decimals, dpb.decimals))) )
    /tick_breaks AS b_usd_per_tick,

( -- a per tick
( COALESCE(pa.price, dpa.median_price)*(""running_amount0""/10^(COALESCE(pa.decimals, dpa.decimals))) )
    /tick_breaks
)
+
( -- a per tick
( COALESCE(pb.price, dpb.median_price)*(""running_amount1""/10^(COALESCE(pb.decimals, dpb.decimals))) )
    /tick_breaks
)
AS total_usd_per_tick

,NULL AS current_price

FROM
(
    
    SELECT l.*, p.""tickSpacing"", ((l.""tickUpper"" - l.""tickLower"")/p.""tickSpacing"")+1 AS tick_breaks, --we add 1 because the LP is initialized on a tick (i.e. 0-20 with a 10 space supports 0, 10, and 20 ticks)
    l.running_amount / ( (l.""tickUpper"" - l.""tickLower"")/p.""tickSpacing"" ) AS amount_per_tick,
    l.""running_amount0""/10^(COALESCE(pa.decimals, dpa.decimals)) AS token_a_num,
    COALESCE(pa.price, dpa.median_price)*(l.""running_amount0""/10^(COALESCE(pa.decimals, dpa.decimals))) AS token_a_usd,
    l.""running_amount1""/10^(COALESCE(pb.decimals, dpb.decimals)) AS token_b_num,
    COALESCE(pb.price, dpb.median_price)*(l.""running_amount1""/10^(COALESCE(pb.decimals, dpb.decimals))) AS token_b_usd
    ,p.""token0"",p.""token1""
    FROM get_liquidity l
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p
    ON p.""pool"" = l.contract_address

    -- idk a better way to do this join
    LEFT JOIN prices pa
    ON pa.contract_address = p.""token0""
    LEFT JOIN prices pb
    ON pb.contract_address = p.""token1""
    LEFT JOIN dex_price dpa
    ON dpa.token = p.""token0""
    LEFT JOIN dex_price dpb
    ON dpb.token = p.""token1""
    
    WHERE p.""tickSpacing"" > 0

) ta
RIGHT JOIN liq_gs lg
ON lg.ticks <= ta.""tickUpper""
AND lg.ticks >= ta.""tickLower""

    -- idk a better way to do this join
    LEFT JOIN prices pa
    ON pa.contract_address = ta.""token0""
    LEFT JOIN prices pb
    ON pb.contract_address = ta.""token1""
    LEFT JOIN dex_price dpa
    ON dpa.token = ta.""token0""
    LEFT JOIN dex_price dpb
    ON dpb.token = ta.""token1""

WHERE lg.ticks IS NOT NULL

) ap

GROUP BY 1,2,3

UNION ALL

SELECT
lt.tick /*1.0001^(lt.tick),*/
, CASE  --assuming 18 for decimals if null
        WHEN lt.tick < 0 THEN (1.0001^(lt.tick)) * (10^(ABS(COALESCE(pa.decimals, dpa.decimals,18)-COALESCE(pb.decimals, dpb.decimals,18))))
        ELSE (1.0001^(lt.tick)) / (10^(ABS(COALESCE(pa.decimals, dpa.decimals,18)-COALESCE(pb.decimals, dpb.decimals,18))))
    END AS price
,NULL, NULL
, CASE  --assuming 18 for decimals if null
        WHEN lt.tick < 0 THEN (1.0001^(lt.tick)) * (10^(ABS(COALESCE(pa.decimals, dpa.decimals,18)-COALESCE(pb.decimals, dpb.decimals,18))))
        ELSE (1.0001^(lt.tick)) / (10^(ABS(COALESCE(pa.decimals, dpa.decimals,18)-COALESCE(pb.decimals, dpb.decimals,18))))
    END AS price
FROM last_trade lt
INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p
    ON p.""pool"" = lt.contract_address
    LEFT JOIN prices pa
    ON pa.contract_address = p.""token0""
    LEFT JOIN prices pb
    ON pb.contract_address = p.""token1""
    LEFT JOIN dex_price dpa
    ON dpa.token = p.""token0""
    LEFT JOIN dex_price dpb
    ON dpb.token = p.""token1""
) eh

) ehb

ORDER BY current_price DESC NULLS LAST"
416961,Uniswap v3 Pair Deep-Dive (All LPs),,table,"WITH get_liquidity AS ( --this is to find the liquidity of each position at trade time
SELECT *
FROM
(
SELECT *,
    LAST_VALUE(a.next_lp_amount) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS last_lp_amount
    FROM
    (
    SELECT *,
    lead(running_amount, 1, running_amount) OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS next_lp_amount
    FROM
    (
        SELECT amount, amount0, amount1, contract_address,call_block_time, call_tx_hash,
        ""tickLower"",""tickUpper"", /*liquidity,*/ ""tokenId"", tr_type,
        lead(call_block_time, 1, now()) OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS next_lp, --to help key in on the right lp when joining - for preformance
        lag(call_block_time, 1, '01-01-2000') OVER (PARTITION BY ""tokenId"" ORDER BY call_block_time asc) AS previous_lp,
        SUM(amount) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount,
        SUM(amount0) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount0,
        SUM(amount1) OVER(PARTITION BY ""tokenId"" ORDER BY call_block_time ASC) AS running_amount1,
        MIN(call_block_time) OVER(PARTITION BY ""tokenId"") AS liq_start
        
        FROM ( --this is a mess. We union new mints + adds to liquidity + new burns + removals from liquidity. eesh
            -- NEW MINTS
            SELECT
            m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
            m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
            /*l.liquidity,*/ l.""output_tokenId""::text AS ""tokenId"", 'Mint' AS tr_type
            FROM uniswap_v3.""Pair_call_mint"" m
           
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_mint"" l
            ON m.call_tx_hash = l.call_tx_hash
            AND m.call_block_time = l.call_block_time
            
            WHERE l.""output_tokenId""::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (m.amount != 0) --only events that do something
            AND m.contract_address = REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
            AND m.call_success = 'true' AND l.call_success = 'true'
            AND m.""call_block_time"" <= LEAST('{{Reference Date}}',NOW())
    
            
            UNION
            --ADDITIONS TO LIQUIDITY INCREASE
            SELECT
            m.amount, m.output_amount0 AS amount0, m.output_amount1 AS amount1, m.contract_address,
            m.call_block_time, m.call_tx_hash, m.""tickLower"", m.""tickUpper"",
            /*l.liquidity,*/ (l.params->'tokenId')::text AS ""tokenId"", 'Mint' AS tr_type
            FROM uniswap_v3.""Pair_call_mint"" m
           
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_increaseLiquidity"" l
            ON m.call_tx_hash = l.call_tx_hash
            AND m.call_block_time = l.call_block_time
            
            WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (m.amount != 0) --only events that do something
            AND m.contract_address = REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
            AND m.call_success = 'true' AND l.call_success = 'true'
            AND m.""call_block_time"" < LEAST('{{Reference Date}}',NOW())
            
            UNION
            -- NEW BURNS // uniswap_v3.""NonfungibleTokenPositionManager_call_burn"" doesn't do anything so jsut decrease liq
            SELECT --negate because these are burns
            (-1)*b.amount AS amount, (-1)*b.output_amount0 AS amount0, (-1)*b.output_amount1 AS amount1, b.contract_address,
            b.call_block_time, b.call_tx_hash, b.""tickLower"", b.""tickUpper"",
            /*l.liquidity,*/ (l.params->'tokenId')::text AS tokenId, 'Burn' AS tr_type
            FROM uniswap_v3.""Pair_call_burn"" b
            
            INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_decreaseLiquidity"" l
            ON b.call_tx_hash = l.call_tx_hash
            AND b.call_block_time = l.call_block_time
            
            WHERE (l.params->'tokenId')::text IS NOT NULL --Some of these are blank, but the transactions are batched/kind of weird or have 0 amount. Maybe revisit, but these seem like duplicates/multiples within a larger transaction that we catch
            AND (b.amount != 0) --only events that do something
            AND b.contract_address = REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
            AND b.call_success = 'true'
            AND l.call_success = 'true'
            AND l.""call_block_time"" < LEAST('{{Reference Date}}',NOW())
            
            ) lq
        ) la
    --Since we already calc'd running amounts, we can ditch all LP events besides the last one before the 2 day / stuff within the 2 day.
    -- We'll use 'next LP' to do this
    WHERE next_lp = NOW() -- to make sure we're grabbing the latest LP
        -->= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '2 days'::INTERVAL)
) a
WHERE running_amount >0 --check this later, but we should be able to ditch these too since matching is on block time and next lp

) b
WHERE last_lp_amount >0 -- only get what's currently active
)


,trades
AS (
    SELECT pool, ""token0"" AS ""token_a_address"", ""token1"" AS ""token_b_address""
    FROM uniswap_v3.""Factory_evt_PoolCreated"" p
        WHERE p.pool = REPLACE(LOWER('{{Pool Address}}'),'0x','\x')::bytea
)
,prices AS
(
SELECT *
FROM
(
    SELECT *,
    DENSE_RANK() OVER(PARTITION BY ""contract_address"" ORDER BY minute DESC) as trank
    FROM prices.""usd"" p
    WHERE p.minute > DATE_TRUNC('minute',LEAST('{{Reference Date}}',NOW()) ) - '2 days'::interval
    AND (
        ""contract_address"" = (SELECT DISTINCT ""token_b_address"" FROM trades)
        OR ""contract_address"" = (SELECT DISTINCT ""token_a_address"" FROM trades)
        )
) a
WHERE trank = 1
)
,gs AS
(
SELECT DISTINCT d.token_a_address AS token, gs.hour FROM trades d
INNER JOIN 
(SELECT generate_series(DATE_TRUNC('hour',LEAST('{{Reference Date}}',NOW()) ) - interval '3 days', date_trunc('hour', LEAST('{{Reference Date}}',NOW()) ), '1 hour') AS hour) gs -- Generate all days since the first contract
ON 1=1

UNION

SELECT DISTINCT d.token_b_address AS token, gs.hour FROM trades d
INNER JOIN 
(SELECT generate_series(DATE_TRUNC('hour',LEAST('{{Reference Date}}',NOW()) ) - interval '3 days', date_trunc('hour', LEAST('{{Reference Date}}',NOW()) ), '1 hour') AS hour) gs -- Generate all days since the first contract
ON 1=1
)

,dex_price AS(
--for tokens where dune doesn't have the price, calculate the avg price in it's last hour of swaps (6 hr if no swaps in the last hour)
--since we don't have an amount field for unmapped tokens, I'll calc it based on... raw amount
-- through a few queries, this gets the unit price of each token (assuming 18 decimals)
-- DO NOT USE THIS FOR KNOWN TOKENS - only for the ones we don't have, we'll assume 18 decimals
SELECT
hour, token, 
symbol, decimals, median_price
FROM
(
SELECT *,
lead(hour, 1, LEAST('{{Reference Date}}',NOW())  ) OVER (PARTITION BY token
                            ORDER BY hour asc) AS next_hour,
    DENSE_RANK() OVER (PARTITION BY token ORDER BY hour DESC) AS trank
FROM
(
SELECT

DATE_TRUNC('hour',hour) AS hour,
t.contract_address AS token, ea.symbol AS symbol, ea.decimals AS decimals,
percentile_cont(0.5) WITHIN GROUP (ORDER BY ""median_price"") AS median_price

FROM dex.""view_token_prices"" t

INNER JOIN (SELECT DISTINCT token FROM gs) c
ON t.contract_address = c.token
INNER JOIN erc20.""tokens"" ea --both need to have known decimals, we're not going to assume anything.
ON ea.""contract_address"" = t.contract_address

WHERE
(ea.decimals IS NOT NULL)
AND median_price > 0

AND DATE_TRUNC('hour',hour) > 
(DATE_TRUNC('minute',LEAST('{{Reference Date}}',NOW()) ) - '2 days'::interval)
AND DATE_TRUNC('hour',hour) <= LEAST('{{Reference Date}}',NOW()) + interval '1 day'

GROUP BY 1,2,3,4
) b
) c
WHERE trank = 1

)

SELECT *, SUM(num_lp) OVER () AS total_num_lps

FROM (

SELECT 
CASE WHEN rnk <= 500 THEN REPLACE(address::text,'\x','0x') ELSE 'LPs # 500+' END AS afddress,
-- REPLACE(address::text,'\x','0x') AS afddress, 
SUM(estimated_usd) AS estimated_usd,
SUM(num_lp) AS num_lp--(*) OVER () AS total_num_lps
,AVG(rnk) AS avg_rnk
FROM (
SELECT *, 1 as num_lp, DENSE_RANK() OVER (ORDER BY estimated_usd DESC) AS rnk
FROM (
SELECT
t.""from"" AS address, 
SUM(token_a_usd+token_b_usd) AS estimated_usd

FROM (
    SELECT l.*, p.""tickSpacing"", ((l.""tickUpper"" - l.""tickLower"")/p.""tickSpacing"")+1 AS tick_breaks, --we add 1 because the LP is initialized on a tick (i.e. 0-20 with a 10 space supports 0, 10, and 20 ticks)
    l.running_amount / ( (l.""tickUpper"" - l.""tickLower"")/p.""tickSpacing"" ) AS amount_per_tick,
    l.""running_amount0""/10^(COALESCE(pa.decimals, dpa.decimals)) AS token_a_num,
    COALESCE(pa.price, dpa.median_price)*(l.""running_amount0""/10^(COALESCE(pa.decimals, dpa.decimals))) AS token_a_usd,
    l.""running_amount1""/10^(COALESCE(pb.decimals, dpb.decimals)) AS token_b_num,
    COALESCE(pb.price, dpb.median_price)*(l.""running_amount1""/10^(COALESCE(pb.decimals, dpb.decimals))) AS token_b_usd
    ,p.""token0"",p.""token1""
    FROM get_liquidity l
    INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" p
    ON p.""pool"" = l.contract_address

    -- idk a better way to do this join
    LEFT JOIN prices pa
    ON pa.contract_address = p.""token0""
    LEFT JOIN prices pb
    ON pb.contract_address = p.""token1""
    LEFT JOIN dex_price dpa
    ON dpa.token = p.""token0""
    LEFT JOIN dex_price dpb
    ON dpb.token = p.""token1""
    ) a

INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_mint"" m
ON m.""output_tokenId""::text = a.""tokenId""::text
INNER JOIN ethereum.transactions t
    ON t.hash = m.""call_tx_hash""
    AND t.block_time =m.""call_block_time""

WHERE m.""call_success""

GROUP BY 1

-- ORDER BY 2 DESC
) aa
) b
GROUP BY 1
) c

ORDER BY avg_rnk ASC"
10413,Delegate Votes ΔT,,table,"with individual_votes as (
        select 
            delegate,
            evt_block_time,
            (sum(""newBalance"") - sum(""previousBalance"")) / 10^18 as votes
        from uniswap.""UNI_evt_DelegateVotesChanged""
        group by delegate, evt_block_time
    ), cumsum_votes as (
        select 
            delegate,
            evt_block_time,
            sum(votes) OVER (PARTITION BY delegate ORDER BY evt_block_time asc ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as votes
        from individual_votes
    ),aggregate_votes as (
        select 
            delegate,
            sum(votes) as votes
        from individual_votes
        group by delegate
    )
select
    CONCAT(SUBSTRING(a.delegate, 0, 5), '...') as delegate, c.votes, c.evt_block_time
from aggregate_votes a
join cumsum_votes c on a.delegate = c.delegate
where a.votes > 100000
order by c.votes desc;"
11762,Proposal Results,,table,"SELECT p.*,
    to_char(p.for_votes / p.total_votes * 100,'999D%') as percentage_for
FROM (
    SELECT 
        ""proposalId"",
        TRUNC(sum(votes) / 10^18) as total_votes,
        TRUNC(SUM(CASE WHEN support = true THEN 1 ELSE 0 END)) as for_count,
        TRUNC(SUM(CASE WHEN support = false THEN 1 ELSE 0 END)) as neg_count,
        TRUNC(SUM(CASE WHEN support = true THEN votes ELSE 0 END) / 10^18) as for_votes,
        TRUNC(SUM(CASE WHEN support = false THEN votes ELSE 0 END) / 10^18) as neg_votes
    FROM uniswap_v2.""GovernorAlpha_evt_VoteCast""
    group by ""proposalId""
)  as p
order by ""proposalId"" desc"
12670,Cumulative Sum of Votes Casted,,table,"SELECT 
    cr.id,
    v.votes / 10^18 as votes,
    v.evt_block_time,
    v.support,
    sum(v.votes) OVER (
        PARTITION BY v.""proposalId""
        ORDER BY v.evt_block_number
        ASC ROWS BETWEEN unbounded preceding AND CURRENT ROW
    )  / 10^18 as total_votes,
    EXTRACT(EPOCH FROM  v.evt_block_time - cr.evt_block_time)/3600 as hours_past
FROM uniswap_v2.""GovernorAlpha_evt_ProposalCreated"" cr
JOIN uniswap_v2.""GovernorAlpha_evt_VoteCast"" v on v.""proposalId"" = cr.id"
10121,Top $UNI Delegates,,table,"with last_delegate as (
        select
            evt_block_time,
            row_number() over (partition by delegator order by evt_block_time desc) as row,
            delegator,
            ""toDelegate""
        from uniswap.""UNI_evt_DelegateChanged""
    ), current_delegation as (
        select
            *
        from last_delegate
        where row = 1
        order by 3 desc
    ), currrent_votes as (
        select 
            delegate,
            (sum(""newBalance"") - sum(""previousBalance"")) / 10^18 as votes
        from uniswap.""UNI_evt_DelegateVotesChanged""
        group by delegate
    ), temp as (
        select
            ""toDelegate"" as delegate,
            count(distinct delegator) as delegators
        from current_delegation
        group by delegate
    ), total_votes as (
        select voter, count(""proposalId"") as total_votes from uniswap_v2.""GovernorAlpha_evt_VoteCast"" group by voter
    ), current_proposal as (
        select voter, support
        FROM uniswap_v2.""GovernorAlpha_evt_VoteCast""
        where ""proposalId"" in (select max(id) from uniswap_v2.""GovernorAlpha_evt_ProposalCreated"")
    )
select
    rank() OVER (order by c.votes desc) as rank,
    t.*, c.votes, --If only to_char didn't right align...
    to_char(c.votes / sum(c.votes) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) * 100, '999D99%') as ""percent"",
    tv.total_votes,
    support as current_vote
from temp t
join currrent_votes c on t.delegate = c.delegate
left join total_votes tv on t.delegate = tv.voter
left join current_proposal p on p.voter = t.delegate
order by c.votes desc;"
10201,Voteable / Delegated $UNI,,table,"SELECT (sum(""newBalance"") - sum(""previousBalance"")) / 1e18 as delegated_uni
FROM uniswap.""UNI_evt_DelegateVotesChanged""

--Could calculate estimated value from ""uniswap.Exchange_evt_TokenPurchase"""
10272,Delegate's Delegator Distribution,,table,"with last_delegate as (
    select
        evt_block_time,
        row_number() over (partition by delegator order by evt_block_time desc) as row,
        delegator,
        ""toDelegate""
    from uniswap.""UNI_evt_DelegateChanged""
), current_delegation as (
    select
        *
    from last_delegate
    where row = 1
    order by 3 desc
), balance as (
    select ""to"", (to_amt - coalesce(from_amt, 0)) / 1e18 as current_balance
    from (select ""to"", sum(amount) as to_amt from uniswap.""UNI_evt_Transfer"" group by ""to"") t
    left join (select ""from"", sum(amount) as from_amt from uniswap.""UNI_evt_Transfer"" group by ""from"") f on f.""from"" = t.""to""
), currrent_votes as (
    select *, rank() OVER (order by votes desc) as rank
    from (
        select 
            delegate,
            (sum(""newBalance"") - sum(""previousBalance"")) / 10^18 as votes
        from uniswap.""UNI_evt_DelegateVotesChanged""
        group by delegate
    ) as foo
)

select
    -- cd.""toDelegate"", cd.""delegator"",
    -- b.current_balance as value,
    CONCAT(SUBSTRING(""toDelegate"", 0, 5), '...'),
    pow(10, floor(ln(b.current_balance) / ln(10))) as bin,
    count(pow(10, floor(ln(b.current_balance) / ln(10)))) as qty
from current_delegation cd
left join balance b on b.""to"" = cd.""delegator""
where ""toDelegate"" in (select delegate from currrent_votes where rank < 10)
    and b.current_balance > 0 --note there is a nontrivial number of addresses delegating 0
group by ""toDelegate"", pow(10, floor(ln(b.current_balance) / ln(10)));"
10261,Token Balances,,table,"select ""to"", (to_amt - coalesce(from_amt, 0)) / 1e18 as current_balance
from (select ""to"", sum(amount) as to_amt from uniswap.""UNI_evt_Transfer"" group by ""to"") t
left join (select ""from"", sum(amount) as from_amt from uniswap.""UNI_evt_Transfer"" group by ""from"") f on f.""from"" = t.""to""
where (to_amt - coalesce(from_amt, 0)) / 1e18 > 0;"
10209,Uniswap Delegated Over Time,,table,"select
    (""newBalance"" - ""previousBalance"") / 1e18 as change,
    sum((""newBalance"" - ""previousBalance"") / 1e18) over (ORDER BY evt_block_number asc rows between unbounded preceding and current row) as cumsum,
    evt_block_time
from uniswap.""UNI_evt_DelegateVotesChanged""
order by evt_block_time asc"
12553,Voting ends at,,table,"--Fork of (#12364) Voting Ends At

WITH
    block_stats AS (
        SELECT
            MAX(time) AS current_block_time
            , MAX(number) AS current_block_number
        FROM ethereum.blocks b
    )
SELECT
    TO_CHAR(
        COALESCE(b.time, bs.current_block_time + (((p.""endBlock"" - bs.current_block_number)*13.1)::VARCHAR || ' seconds')::INTERVAL)
        , 'Month DD, YYYY hh12:mi:ss AM') AS evt_block_time,
        
    CASE
        WHEN p.""endBlock"" > bs.current_block_number 
        THEN FLOOR(((p.""endBlock"" - bs.current_block_number)*13.1) / (60 * 60 * 24)) || 'd ' || to_char(CAST((((p.""endBlock"" - bs.current_block_number)*13.1)::VARCHAR || ' seconds')::INTERVAL as Time), 'HH24:MI')
        ELSE 'No Active Proposal'
        END
    as end_time
FROM uniswap_v2.""GovernorAlpha_evt_ProposalCreated"" p
LEFT JOIN ethereum.blocks b ON b.number = p.""endBlock""
CROSS JOIN block_stats bs
WHERE id in (select max(id) from uniswap_v2.""GovernorAlpha_evt_ProposalCreated"");"
10128,Distribution of Current Delegators,,table,"with last_delegate as (
    select
        evt_block_time,
        row_number() over (partition by delegator order by evt_block_time desc) as row,
        delegator,
        ""toDelegate""
    from uniswap.""UNI_evt_DelegateChanged""
), current_delegation as (
    select
        *
    from last_delegate
    where row = 1
    order by 3 desc
), balance as (
    select ""to"", (to_amt - coalesce(from_amt, 0)) / 1e18 as current_balance
    from (select ""to"", sum(amount) as to_amt from uniswap.""UNI_evt_Transfer"" group by ""to"") t
    left join (select ""from"", sum(amount) as from_amt from uniswap.""UNI_evt_Transfer"" group by ""from"") f on f.""from"" = t.""to""
)

--Numbers don't add up correctly...
select
    CONCAT(SUBSTRING(cd.""toDelegate"", 0, 8), '...') as e1,
    CONCAT(SUBSTRING(cd.""delegator"", 0, 8), '...') as e2,
    b.current_balance as value
from current_delegation cd
left join balance b on b.""to"" = cd.""delegator""
where b.current_balance > 0;"
51487,Uni v3 - UXCA - Volume Share (Uni v3 wins),,table,"WITH all_trades_raw AS
(
SELECT

DATE_TRUNC('day',t.block_time) AS day_time,
CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version)
ELSE t.project
END AS proj_v,
---
-- Token Mapping --
---
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,

CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b,

t.exchange_contract_address -- exchange_contract_address is the LP Position
,SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t
/*The LP mint transaction has the fee rate as a parameter
1. Join on the LP (contract address) to get the mint transaction
2. Use the mint transaction to join to the Position Manager and get the fee rate
(I hope there's an easier way to do this eventually)
*/
WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL)
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2,3,4,5
),
token_mapping AS(
SELECT t.token,
CASE
WHEN t.token IN ('WETH','ETH') THEN 'ETH'
WHEN t.token IN ('sETH','stETH','ankrETH','rETH','cETH') THEN 'ETH Token'
WHEN t.token IN ('sUSD','sEUR','sAUD') THEN 'Synth Stable'
WHEN (t.token LIKE '%USD%') OR (t.token IN ('DAI','cDAI', 'FEI','FRAX','UST')) THEN 'USD'
WHEN (t.token IN ('EURS')) THEN 'EUR'
WHEN t.token IN ('WBTC','renBTC','hBTC','sBTC','oBTC','pBTC','tBTC','bBTC','cWBTC','0xBTC') THEN 'BTC Token'
WHEN t.token = 'UNI' THEN 'UNI'
WHEN t.token IN ('SUSHI', 'BNT', 'BAL','ZRX','KNC','1INCH','xSUSHI','WOO') THEN 'DEX Token'
WHEN t.token IN ('MKR','COMP','AAVE','YFI','SNX','LINK','CRV','ALCX','RAI','TRIBE',
    'VISR','UMA','REN','CREAM','FARM','MTA','TRU','RGT','LQTY','CONV')
    Then 'DeFi Token'
WHEN t.token IN ('VERA','ENJ','MANA','SAND','WAXE','AUDIO','RFOX','WHALE',
    'RARI','DG','TVK','REV','MEME','MUSE','AXS', 'SLP')
    Then 'Metaverse Token'    
WHEN t.token IN ('CEL','NEXO','eRSDL','GERO') Then 'CeDeFi Token'
WHEN t.token IN ('DPI','MVI') Then 'Index Token'
WHEN t.token IN ('MATIC','LRC','CTSI','OMG','QUICK') Then 'L2-Sidechain'
WHEN t.token IN ('RUNE','LUNA','FTM','CARDS','KYL','SRM','PSWAP','OCC','GLCH','DFYN') Then 'Alt/Cross-Chain'
WHEN (t.token LIKE '%DOGE%') OR (t.token IN ('SHIB','LEASH','ELON','AKITA','SHIH','WOOFY','KISHU')) THEN 'Meme' --WOOFY is debatable, but I think #1 use case is meme
WHEN (t.token LIKE '%2x-FLI%') OR (t.token = 'ETH2x ADL') THEN 'Leverage Token'
WHEN t.token IN ('sYFI','sXTZ','sXRP','sXMR','sXAU','sXAG','sUNI',
                'sTRX','sRUNE','sLTC','sLINK','sETH','sETC','sEOS','sDOT','sDEFI'
                'sDASH','sCRV','sCOMP','sADA','sAAVE') THEN 'Synth Token'
WHEN t.token IN ('sOIL') THEN 'Synth Commodity'
WHEN t.token IN ('sTSLA','sNFLX','sMSFT','sGOOG','sFTSE','sFB','sCOIN','sAMZN','sAAPL') THEN 'Synth Stock'
WHEN t.token IN ('GTC') THEN 'Cause Token'
WHEN t.token IN ('Burn Addr') THEN 'Burn Addr'
ELSE 'Unmapped'
END AS token_map
FROM (
    SELECT DISTINCT token_a AS token FROM all_trades_raw
    UNION
    SELECT DISTINCT token_b AS token FROM all_trades_raw
    ) t
),

all_trades AS(
SELECT
day_time, proj_v,
token_a, token_b,
exchange_contract_address,
usd_traded,
--pair type mapping--
m1.token_map as token_a_map,
m2.token_map as token_b_map
FROM
all_trades_raw r

LEFT JOIN token_mapping m1
ON r.token_a = m1.token
LEFT JOIN token_mapping m2
ON r.token_b = m2.token
),

/*
most_recent_price AS
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute,
    contract_address,
    symbol,
    decimals,
    price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this
    ) last_price
WHERE last_price.recency_rank = 1 --To get the most recent price for liquidity joining
),*/
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd
FROM all_trades
GROUP BY 1,2,3,4
),
sum_pairs_map AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
--CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
--,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd_map
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS(
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd AS suma ,b.sum_usd AS sumb,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair
FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
final_trading_pairs_map AS(
SELECT
--a.forward_pair,
--a.backward_pair,
a.forward_pair_map, a.backward_pair_map,
a.sum_usd_map AS suma ,b.sum_usd_map AS sumb,
CASE
WHEN RIGHT(a.backward_pair_map,3)='ETH' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,3)='ETH' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='ETH Token' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,9)='ETH Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='BTC Token' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,9)='BTC Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='USD Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='USD Stable' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='EUR Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='EUR Stable' THEN a.backward_pair_map
WHEN (a.sum_usd_map >= b.sum_usd_map) -- when a > b
OR b.sum_usd_map IS NULL -- or if backward usd is null
THEN a.forward_pair_map -- select forward
ELSE a.backward_pair_map --else select backward in every other circumstance
END AS trading_pair_map
FROM sum_pairs_map a
LEFT JOIN sum_pairs_map b
ON a.forward_pair_map = b.backward_pair_map
),


v_trades AS (
SELECT
atx.day_time,
atx.proj_v AS project_version,
--atx.*,  f1.*, f2.*,
--f1.trading_pair,
--f2.trading_pair,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
COALESCE(f1m.trading_pair_map,f2m.trading_pair_map) AS trading_pair_map,
atx.usd_traded,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair,
--SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map,
--atx.fee_tier,
--atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
LEFT JOIN final_trading_pairs_map f1m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f1m.forward_pair_map
LEFT JOIN final_trading_pairs_map f2m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f2m.backward_pair_map
)
/*lp_withdraws AS(
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws
FROM (SELECT DISTINCT exchange_contract_address
FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_deposits AS(
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_tvl AS(
SELECT
net.lp_pos,
SUM(net.net_usd) AS tvl_usd
FROM (
    SELECT
    d.lp_pos,
    d.token,
    --d.project_version,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --how many tokens are in the LP
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) AS net_tokens_erc20, --tokens in the LP with appropriate decimals (only Dune logged erc20's)
    ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price AS net_usd --USD value of each token in the LP (Dune logged erc 20s only)
    FROM lp_deposits d
    INNER JOIN lp_withdraws w
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    --AND d.project_version = w.project_version
    LEFT JOIN most_recent_price p
    ON d.token = p.""contract_address""
    ) net
GROUP BY net.lp_pos
)*/
,trade_stats AS (
SELECT
--v.day_time,
v.trading_pair,
v.trading_pair_map,
v.project_version,
--,v.fee_tier
--,COUNT(v.trading_pair) AS num_trades
total_usd_by_pair,
SUM(v.usd_traded) AS total_usd,
SUM(v.usd_traded) / 
(CASE
WHEN total_usd_by_pair = 0 THEN 1 --handling for divide by zero errors that came up.
WHEN total_usd_by_pair IS NULL THEN 1
ELSE total_usd_by_pair
END) AS share_of_pair_usd,
RANK() OVER(PARTITION BY v.trading_pair ORDER BY SUM(v.usd_traded) DESC) AS pair_rank

--,SUM(v.fees_collected_usd) AS total_fees_usd
--,lp.tvl_usd AS total_value_locked
--,SUM(v.fees_collected_usd) / lp.tvl_usd AS fee_to_tvl_ratio
FROM v_trades v
--LEFT JOIN lp_tvl lp
--ON v.exchange_contract_address = lp.lp_pos
--AND v.project_version = lp.project_version
WHERE /*v.day_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '364 days'::INTERVAL)
AND*/ v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3,4--v.exchange_contract_address, v.trading_pair--, lp.tvl_usd, v.project_version--, v.fee_tier
--ORDER BY v.day_time, total_usd_by_pair DESC, SUM(v.usd_traded) DESC
--HAVING
--SUM(v.usd_traded) >100000 --Filter to remove outlier/small pairs
--AND lp.tvl_usd >1000 --remove more outliers / pairs with no prices
--ORDER BY SUM(v.fees_collected_usd) DESC
), starting_stats AS(
SELECT DISTINCT
trading_pair,
trading_pair_map,
total_usd_by_pair
FROM
trade_stats
)
SELECT
a.trading_pair, a.total_usd_by_pair, au.total_usd AS univ3_usd, au.share_of_pair_usd AS univ3_dominance,
--b.project_version AS dominant_dex, b.total_usd AS best_usd, b.share_of_pair_usd AS best_pair_dominance,

/*CASE WHEN b.project_version = 'Uniswap v3' THEN 'Uniswap v3 winning the pair'
WHEN b.project_version = 'Uniswap v2' THEN 'Uniswap v2 winning the pair'
WHEN b.project_version = 'Uniswap v1' THEN 'Uniswap v1 winning the pair'
ELSE 'Uniswap losing the pair'
END AS pair_winner,*/
/*CASE WHEN b.project_version = 'Uniswap v3' THEN NULL
ELSE a.total_usd - b.total_usd
END AS univ3_delta,*/
a.total_usd_by_pair *(1-au.share_of_pair_usd) AS uncaptured_volume -- total volume for each pair not going through v3
,a.trading_pair_map
FROM starting_stats a
INNER JOIN (SELECT * FROM trade_stats WHERE pair_rank = 1) b
ON a.trading_pair = b.trading_pair
LEFT JOIN (SELECT * FROM trade_stats WHERE project_version = 'Uniswap v3') au --uni v3 pairs
ON a.trading_pair = au.trading_pair
WHERE /*a.project_version = 'Uniswap v3'
AND*/ b.project_version = 'Uniswap v3' --To pull Univ3 Wins
ORDER BY a.total_usd_by_pair DESC
"
52145,Uni v3 - UXCA - Pair Type Dominance,,table,"WITH all_trades_raw AS
(
SELECT

DATE_TRUNC('day',t.block_time) AS day_time,
CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version)
ELSE t.project
END AS proj_v,
---
-- Token Mapping --
---
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'

ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'

ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b,

t.exchange_contract_address,
CASE WHEN t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL) THEN 'current period'
ELSE 'previous period'
END AS period

-- exchange_contract_address is the LP Position
,SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t
/*The LP mint transaction has the fee rate as a parameter
1. Join on the LP (contract address) to get the mint transaction
2. Use the mint transaction to join to the Position Manager and get the fee rate
(I hope there's an easier way to do this eventually)
*/
WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL - '{{Time Period}}'::INTERVAL) --Minus Interval x2 so that we can measure PoP change
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2,3,4,5,6
),

token_mapping AS(
SELECT t.token,
CASE
WHEN t.token IN ('WETH','ETH') THEN 'ETH'
WHEN t.token IN ('sETH','stETH','ankrETH','rETH','cETH') THEN 'ETH Token'
WHEN t.token IN ('sUSD','sEUR','sAUD') THEN 'Synth Stable'
WHEN (t.token LIKE '%USD%') OR (t.token IN ('DAI','cDAI', 'FEI','FRAX','UST')) THEN 'USD'
WHEN (t.token IN ('EURS')) THEN 'EUR'
WHEN t.token IN ('WBTC','renBTC','hBTC','sBTC','oBTC','pBTC','tBTC','bBTC','cWBTC','0xBTC') THEN 'BTC Token'
WHEN t.token = 'UNI' THEN 'UNI'
WHEN t.token IN ('SUSHI', 'BNT', 'BAL','ZRX','KNC','1INCH','xSUSHI','WOO') THEN 'DEX Token'
WHEN t.token IN ('MKR','COMP','AAVE','YFI','SNX','LINK','CRV','ALCX','RAI','TRIBE',
    'VISR','UMA','REN','CREAM','FARM','MTA','TRU','RGT','LQTY','CONV')
    Then 'DeFi Token'
WHEN t.token IN ('VERA','ENJ','MANA','SAND','WAXE','AUDIO','RFOX','WHALE',
    'RARI','DG','TVK','REV','MEME','MUSE','AXS', 'SLP')
    Then 'Metaverse Token'    
WHEN t.token IN ('CEL','NEXO','eRSDL','GERO') Then 'CeDeFi Token'
WHEN t.token IN ('DPI','MVI') Then 'Index Token'
WHEN t.token IN ('MATIC','LRC','CTSI','OMG','QUICK') Then 'L2-Sidechain'
WHEN t.token IN ('RUNE','LUNA','FTM','CARDS','KYL','SRM','PSWAP','OCC','GLCH','DFYN') Then 'Alt/Cross-Chain'
WHEN (t.token LIKE '%DOGE%') OR (t.token IN ('SHIB','LEASH','ELON','AKITA','SHIH','WOOFY','KISHU')) THEN 'Meme' --WOOFY is debatable, but I think #1 use case is meme
WHEN (t.token LIKE '%2x-FLI%') OR (t.token = 'ETH2x ADL') THEN 'Leverage Token'
WHEN t.token IN ('sYFI','sXTZ','sXRP','sXMR','sXAU','sXAG','sUNI',
                'sTRX','sRUNE','sLTC','sLINK','sETH','sETC','sEOS','sDOT','sDEFI'
                'sDASH','sCRV','sCOMP','sADA','sAAVE') THEN 'Synth Token'
WHEN t.token IN ('sOIL') THEN 'Synth Commodity'
WHEN t.token IN ('sTSLA','sNFLX','sMSFT','sGOOG','sFTSE','sFB','sCOIN','sAMZN','sAAPL') THEN 'Synth Stock'
WHEN t.token IN ('GTC') THEN 'Cause Token'
WHEN t.token IN ('Burn Addr') THEN 'Burn Addr'
ELSE 'Unmapped'
END AS token_map
FROM (
    SELECT DISTINCT token_a AS token FROM all_trades_raw
    UNION
    SELECT DISTINCT token_b AS token FROM all_trades_raw
    ) t
),

all_trades AS(
SELECT
period,
day_time, proj_v,
token_a, token_b,
exchange_contract_address,
usd_traded,
--pair type mapping--
m1.token_map as token_a_map,
m2.token_map as token_b_map
FROM
all_trades_raw r

LEFT JOIN token_mapping m1
ON r.token_a = m1.token
LEFT JOIN token_mapping m2
ON r.token_b = m2.token
),
/*
most_recent_price AS
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute,
    contract_address,
    symbol,
    decimals,
    price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this
    ) last_price
WHERE last_price.recency_rank = 1 --To get the most recent price for liquidity joining
),*/
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd
FROM all_trades
GROUP BY 1,2,3,4
),
sum_pairs_map AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
--CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
--,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd_map
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS(
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd AS suma ,b.sum_usd AS sumb,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair
FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
final_trading_pairs_map AS(
SELECT
--a.forward_pair,
--a.backward_pair,
a.forward_pair_map, a.backward_pair_map,
a.sum_usd_map AS suma ,b.sum_usd_map AS sumb,
CASE
WHEN RIGHT(a.backward_pair_map,3)='ETH' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,3)='ETH' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='ETH Token' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,9)='ETH Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='BTC Token' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,9)='BTC Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='USD Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='USD Stable' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='EUR Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='EUR Stable' THEN a.backward_pair_map
WHEN (a.sum_usd_map >= b.sum_usd_map) -- when a > b
OR b.sum_usd_map IS NULL -- or if backward usd is null
THEN a.forward_pair_map -- select forward
ELSE a.backward_pair_map --else select backward in every other circumstance
END AS trading_pair_map
FROM sum_pairs_map a
LEFT JOIN sum_pairs_map b
ON a.forward_pair_map = b.backward_pair_map
),


v_trades AS (
SELECT
atx.day_time,
atx.proj_v AS project_version,
--atx.*,  f1.*, f2.*,
--f1.trading_pair,
--f2.trading_pair,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
COALESCE(f1m.trading_pair_map,f2m.trading_pair_map) AS trading_pair_map,
atx.usd_traded,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map,
SUM(atx.usd_traded) OVER(PARTITION BY proj_v) AS total_usd_by_dex,
--atx.fee_tier,
--atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
LEFT JOIN final_trading_pairs_map f1m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f1m.forward_pair_map
LEFT JOIN final_trading_pairs_map f2m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f2m.backward_pair_map

WHERE atx.period = 'current period'
),

v_trades_prev AS ( --for pop calc
SELECT
atx.day_time,
atx.proj_v AS project_version,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
COALESCE(f1m.trading_pair_map,f2m.trading_pair_map) AS trading_pair_map,
atx.usd_traded,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map,
SUM(atx.usd_traded) OVER(PARTITION BY proj_v) AS total_usd_by_dex,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
LEFT JOIN final_trading_pairs_map f1m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f1m.forward_pair_map
LEFT JOIN final_trading_pairs_map f2m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f2m.backward_pair_map

WHERE atx.period = 'previous period'
)


,trade_stats AS (
SELECT

v.trading_pair_map,
v.project_version,

total_usd_by_pair_map,
SUM(v.usd_traded) AS total_usd,

DENSE_RANK() OVER(ORDER BY total_usd_by_pair_map DESC) AS pair_map_rank,
RANK() OVER(PARTITION BY v.trading_pair_map ORDER BY SUM(v.usd_traded) DESC) AS map_rank

FROM v_trades v

WHERE v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3
)
,trade_stats_prev AS (
SELECT

v.trading_pair_map,
v.project_version,

total_usd_by_pair_map,
SUM(v.usd_traded) AS total_usd,

DENSE_RANK() OVER(ORDER BY total_usd_by_pair_map DESC) AS pair_map_rank,
RANK() OVER(PARTITION BY v.trading_pair_map ORDER BY SUM(v.usd_traded) DESC) AS map_rank

FROM v_trades_prev v

WHERE v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3
),
starting_stats AS(
SELECT DISTINCT
trading_pair_map,
total_usd_by_pair_map
FROM
trade_stats
),
starting_stats_prev AS(
SELECT DISTINCT
trading_pair_map,
total_usd_by_pair_map
FROM
trade_stats_prev
)
--SELECT * FROM trade_stats_prev
--WHERE trading_pair_map LIKE '%L2%'
--LIMIT 1000

--SELECT * FROM trade_stats
SELECT
RANK() OVER(ORDER BY a.total_usd_by_pair_map DESC) AS pair_map_rank,
a.trading_pair_map,
--a.project_version,
a.total_usd_by_pair_map,
---
(a.total_usd_by_pair_map - ap.total_usd_by_pair_map) /
ap.total_usd_by_pair_map AS total_usd_map_change,
--a.total_usd_by_dex,
--a.pair_map_rank,
COALESCE(au.total_usd,0) AS total_usd_map_v3,
COALESCE(au.total_usd/a.total_usd_by_pair_map,0) AS pct_of_map_v3,
---
((au.total_usd/au.total_usd_by_pair_map) - (aup.total_usd/aup.total_usd_by_pair_map))*100 AS v3_share_change,
---
CASE WHEN b.project_version = 'Uniswap v3' THEN '*Uniswap v3*'
ELSE b.project_version
END AS dom_dex,
---
CASE WHEN b.project_version = 'Uniswap v3' THEN NULL
ELSE b.total_usd
END AS total_usd_map_dom,
---
CASE WHEN b.project_version = 'Uniswap v3' THEN NULL
ELSE b.total_usd/b.total_usd_by_pair_map
END AS pct_of_map_dom,

CASE WHEN b.project_version = 'Uniswap v3' THEN NULL
ELSE b.total_usd - au.total_usd
END AS uni_v3_defecit_usd,

CASE WHEN b.project_version = 'Uniswap v3' THEN NULL
ELSE (b.total_usd/b.total_usd_by_pair_map) - (au.total_usd/au.total_usd_by_pair_map)
END AS uni_v3_defecit_pct

FROM starting_stats a --all pairs, regardless of dex

LEFT JOIN (SELECT * FROM trade_stats WHERE project_version = 'Uniswap v3') au --uni v3 pairs
ON a.trading_pair_map = au.trading_pair_map
--AND a.project_version = au.project_version
LEFT JOIN (SELECT * FROM trade_stats_prev WHERE project_version = 'Uniswap v3') aup --uni v3 previous pairs
ON a.trading_pair_map = aup.trading_pair_map
--AND a.project_version = aup.project_version
LEFT JOIN starting_stats_prev ap --all prev pairs
ON a.trading_pair_map = ap.trading_pair_map
--AND a.project_version = ap.project_version
LEFT JOIN (SELECT * FROM trade_stats WHERE map_rank = 1) b --top pair
ON a.trading_pair_map = b.trading_pair_map
---
--WHERE au.project_version = 'Uniswap v3'
--AND aup.project_version = 'Uniswap v3'
/*WHERE
pair_map_rank <= 15*/
--GROUP BY
--a.trading_pair_map,
--a.total_usd_by_pair_map,
--b.project_version,
--b.total_usd_by_pair_map,b.total_usd

--HAVING SUM(total_usd)/total_usd_by_pair_map > .0045 --Greater than 0.5% rounded up

ORDER BY a.total_usd_by_pair_map DESC"
52162,Uni v3 - UXCA - DEX Time Series (Can start before Uni v3 launch),,table,"WITH all_trades--_raw
AS
(
SELECT

CASE
WHEN '{{Time Period}}' IN ('1 hour') THEN DATE_TRUNC('minute',t.block_time)
WHEN ('{{Time Period}}' = '7 days') OR ('{{Time Period}}' LIKE '%hour%') THEN DATE_TRUNC('hour',t.block_time)
ELSE DATE_TRUNC('day',t.block_time)
END AS day_time,
CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version)
ELSE t.project
END AS proj_v,

SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t

WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
/*t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr --only commenting out for this chart
AND*/
(CASE WHEN '{{Time Period}}' LIKE '%hour%' THEN t.block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL)
ELSE t.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL)
END)
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2
),
/*
all_trades AS(
SELECT
day_time, proj_v,
--token_a, token_b,
--exchange_contract_address,
usd_traded--,
--pair type mapping--
--m1.token_map as token_a_map,
--m2.token_map as token_b_map
FROM
all_trades_raw r

--LEFT JOIN token_mapping m1
--ON r.token_a = m1.token
--LEFT JOIN token_mapping m2
--ON r.token_b = m2.token
),*/

/*
most_recent_price AS
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute,
    contract_address,
    symbol,
    decimals,
    price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this
    ) last_price
WHERE last_price.recency_rank = 1 --To get the most recent price for liquidity joining
),*/
/*
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd
FROM all_trades
GROUP BY 1,2,3,4
),
sum_pairs_map AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
--CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
--,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd_map
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS(
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd AS suma ,b.sum_usd AS sumb,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair
FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
final_trading_pairs_map AS(
SELECT
--a.forward_pair,
--a.backward_pair,
a.forward_pair_map, a.backward_pair_map,
a.sum_usd_map AS suma ,b.sum_usd_map AS sumb,
CASE
WHEN RIGHT(a.backward_pair_map,3)='ETH' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,3)='ETH' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='ETH Token' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,9)='ETH Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='BTC Token' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,9)='BTC Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='USD Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='USD Stable' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='EUR Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='EUR Stable' THEN a.backward_pair_map
WHEN (a.sum_usd_map >= b.sum_usd_map) -- when a > b
OR b.sum_usd_map IS NULL -- or if backward usd is null
THEN a.forward_pair_map -- select forward
ELSE a.backward_pair_map --else select backward in every other circumstance
END AS trading_pair_map
FROM sum_pairs_map a
LEFT JOIN sum_pairs_map b
ON a.forward_pair_map = b.backward_pair_map
),
*/

v_trades AS (
SELECT
atx.day_time,
atx.proj_v AS project_version,
--atx.*,  f1.*, f2.*,
--f1.trading_pair,
--f2.trading_pair,
--COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
--COALESCE(f1m.trading_pair_map,f2m.trading_pair_map) AS trading_pair_map,
atx.usd_traded,
--SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair,
--SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map,
SUM(atx.usd_traded) OVER(PARTITION BY proj_v) AS total_usd_by_dex--,
--atx.fee_tier,
--atx.fees_collected_usd,
--atx.exchange_contract_address
FROM all_trades atx

/*LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
LEFT JOIN final_trading_pairs_map f1m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f1m.forward_pair_map
LEFT JOIN final_trading_pairs_map f2m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f2m.backward_pair_map*/

)
/*lp_withdraws AS(
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws
FROM (SELECT DISTINCT exchange_contract_address
FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_deposits AS(
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_tvl AS(
SELECT
net.lp_pos,
SUM(net.net_usd) AS tvl_usd
FROM (
    SELECT
    d.lp_pos,
    d.token,
    --d.project_version,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --how many tokens are in the LP
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) AS net_tokens_erc20, --tokens in the LP with appropriate decimals (only Dune logged erc20's)
    ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price AS net_usd --USD value of each token in the LP (Dune logged erc 20s only)
    FROM lp_deposits d
    INNER JOIN lp_withdraws w
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    --AND d.project_version = w.project_version
    LEFT JOIN most_recent_price p
    ON d.token = p.""contract_address""
    ) net
GROUP BY net.lp_pos
)*/
,trade_stats AS (
SELECT
v.day_time,
--v.trading_pair,
--v.trading_pair_map,
v.project_version,
--,v.fee_tier
--,COUNT(v.trading_pair) AS num_trades
--total_usd_by_pair,
--total_usd_by_pair_map,
total_usd_by_dex,
SUM(v.usd_traded) AS total_usd,
/*SUM(v.usd_traded) / 
(CASE
WHEN total_usd_by_pair = 0 THEN 1 --handling for divide by zero errors that came up.
WHEN total_usd_by_pair IS NULL THEN 1
ELSE total_usd_by_pair
END) AS share_of_pair_usd,*/
--RANK() OVER(PARTITION BY v.trading_pair ORDER BY SUM(v.usd_traded) DESC) AS pair_rank,
DENSE_RANK() OVER(ORDER BY total_usd_by_dex DESC) AS dex_rank

--,SUM(v.fees_collected_usd) AS total_fees_usd
--,lp.tvl_usd AS total_value_locked
--,SUM(v.fees_collected_usd) / lp.tvl_usd AS fee_to_tvl_ratio
FROM v_trades v
--LEFT JOIN lp_tvl lp
--ON v.exchange_contract_address = lp.lp_pos
--AND v.project_version = lp.project_version
WHERE /*v.day_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '364 days'::INTERVAL)
AND*/ v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3--,4--,5,6,7--v.exchange_contract_address, v.trading_pair--, lp.tvl_usd, v.project_version--, v.fee_tier
--ORDER BY v.day_time, total_usd_by_pair DESC, SUM(v.usd_traded) DESC
--HAVING
--SUM(v.usd_traded) >100000 --Filter to remove outlier/small pairs
--AND lp.tvl_usd >1000 --remove more outliers / pairs with no prices
--ORDER BY SUM(v.fees_collected_usd) DESC
),
proj_map AS(
SELECT DISTINCT project_version, dex_rank
FROM trade_stats
),

num_users AS
( --this whole part seems weird because I combine the proj_v and project_version steps in to one
-- This is because I want to count distinct users across all 'other' DEXs.
--I don't want to SUM the distinct user for each 'other' DEX becuase they might use multiple (summing would overstate this)
SELECT
CASE
WHEN '{{Time Period}}' IN ('1 hour') THEN DATE_TRUNC('minute',t.block_time)
WHEN ('{{Time Period}}' = '7 days') OR ('{{Time Period}}' LIKE '%hour%') THEN DATE_TRUNC('hour',t.block_time)
ELSE DATE_TRUNC('day',t.block_time)
END AS day_time,

CASE WHEN (CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version) ELSE t.project END) = 'Uniswap v3' THEN '*Uniswap v3*' --projv
WHEN s.dex_rank <=15 THEN (CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version) ELSE t.project END) --projv
ELSE 'Other'
END AS project_version,

COUNT(DISTINCT t.tx_from) AS distinct_users-- 'tx_from' is user address for dex.trades
FROM dex.""trades"" t

INNER JOIN proj_map s
ON s.project_version = (CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version) ELSE t.project END)

WHERE
/*t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND*/ (CASE WHEN '{{Time Period}}' IN ('1 hour') THEN t.block_time >= (DATE_TRUNC('minute',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL)
ELSE t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL)
END) --greater than only because the parameter is last X days
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)

GROUP BY 1,2

),

almost AS(
SELECT
t.day_time,
--trading_pair_map,
CASE
WHEN t.project_version = 'Uniswap v3' THEN '*Uniswap v3*'
WHEN t.dex_rank <=15 THEN t.project_version
ELSE 'Other'
END AS project_version,
--t.total_usd_by_dex,
SUM(total_usd) AS total_usd_map/*,
SUM(total_usd)/total_usd_by_dex AS pct_of_dex*/
FROM trade_stats t
 -- exclude most recent time period from users b/c it looks like tanks when a day or hour isn't completed
--total_usd_by_dex > 1000000000*/
GROUP BY 1,2--,3
--HAVING SUM(total_usd)/total_usd_by_dex > .0045 --Greater than 0.5% rounded up
) --need to join distinct users here so that the consolidation into other is accurate, not double counting people
SELECT
a.day_time,
a.project_version,
a.total_usd_map,
n.distinct_users/*,
n.time_rank*/
FROM almost a
LEFT JOIN num_users n
ON n.day_time = a.day_time
AND n.project_version = a.project_version
WHERE 
a.day_time != (SELECT day_time FROM trade_stats ORDER BY day_time DESC LIMIT 1)
--n.time_rank>1 --filter out the most recent day/hour since it's not complete and line charts look like they have a huge fall-off for no reason."
51502,Uni v3 - UCXA - DEX Share by Type,,table,"WITH all_trades_raw AS
(
SELECT

DATE_TRUNC('day',t.block_time) AS day_time,
CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version)
ELSE t.project
END AS proj_v,
---
-- Token Mapping --
---
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,

CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b,

t.exchange_contract_address -- exchange_contract_address is the LP Position
,SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t
/*The LP mint transaction has the fee rate as a parameter
1. Join on the LP (contract address) to get the mint transaction
2. Use the mint transaction to join to the Position Manager and get the fee rate
(I hope there's an easier way to do this eventually)
*/
WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL)
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2,3,4,5
),
token_mapping AS(
SELECT t.token,
CASE
WHEN t.token IN ('WETH','ETH') THEN 'ETH'
WHEN t.token IN ('sETH','stETH','ankrETH','rETH','cETH') THEN 'ETH Token'
WHEN t.token IN ('sUSD','sEUR','sAUD') THEN 'Synth Stable'
WHEN (t.token LIKE '%USD%') OR (t.token IN ('DAI','cDAI', 'FEI','FRAX','UST')) THEN 'USD'
WHEN (t.token IN ('EURS')) THEN 'EUR'
WHEN t.token IN ('WBTC','renBTC','hBTC','sBTC','oBTC','pBTC','tBTC','bBTC','cWBTC','0xBTC') THEN 'BTC Token'
WHEN t.token = 'UNI' THEN 'UNI'
WHEN t.token IN ('SUSHI', 'BNT', 'BAL','ZRX','KNC','1INCH','xSUSHI','WOO') THEN 'DEX Token'
WHEN t.token IN ('MKR','COMP','AAVE','YFI','SNX','LINK','CRV','ALCX','RAI','TRIBE',
    'VISR','UMA','REN','CREAM','FARM','MTA','TRU','RGT','LQTY','CONV')
    Then 'DeFi Token'
WHEN t.token IN ('VERA','ENJ','MANA','SAND','WAXE','AUDIO','RFOX','WHALE',
    'RARI','DG','TVK','REV','MEME','MUSE','AXS')
    Then 'Metaverse Token'    
WHEN t.token IN ('CEL','NEXO','eRSDL','GERO') Then 'CeDeFi Token'
WHEN t.token IN ('DPI','MVI') Then 'Index Token'
WHEN t.token IN ('MATIC','LRC','CTSI','OMG','QUICK') Then 'L2-Sidechain'
WHEN t.token IN ('RUNE','LUNA','FTM','CARDS','KYL','SRM','PSWAP','OCC','GLCH','DFYN') Then 'Alt/Cross-Chain'
WHEN (t.token LIKE '%DOGE%') OR (t.token IN ('SHIB','LEASH','ELON','AKITA','SHIH','WOOFY','KISHU')) THEN 'Meme' --WOOFY is debatable, but I think #1 use case is meme
WHEN (t.token LIKE '%2x-FLI%') OR (t.token = 'ETH2x ADL') THEN 'Leverage Token'
WHEN t.token IN ('sYFI','sXTZ','sXRP','sXMR','sXAU','sXAG','sUNI',
                'sTRX','sRUNE','sLTC','sLINK','sETH','sETC','sEOS','sDOT','sDEFI'
                'sDASH','sCRV','sCOMP','sADA','sAAVE') THEN 'Synth Token'
WHEN t.token IN ('sOIL') THEN 'Synth Commodity'
WHEN t.token IN ('sTSLA','sNFLX','sMSFT','sGOOG','sFTSE','sFB','sCOIN','sAMZN','sAAPL') THEN 'Synth Stock'
WHEN t.token IN ('GTC') THEN 'Cause Token'
WHEN t.token IN ('Burn Addr') THEN 'Burn Addr'
ELSE 'Unmapped'
END AS token_map
FROM (
    SELECT DISTINCT token_a AS token FROM all_trades_raw
    UNION
    SELECT DISTINCT token_b AS token FROM all_trades_raw
    ) t
),

all_trades AS(
SELECT
day_time, proj_v,
token_a, token_b,
exchange_contract_address,
usd_traded,
--pair type mapping--
m1.token_map as token_a_map,
m2.token_map as token_b_map
FROM
all_trades_raw r

LEFT JOIN token_mapping m1
ON r.token_a = m1.token
LEFT JOIN token_mapping m2
ON r.token_b = m2.token
),

/*
most_recent_price AS
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute,
    contract_address,
    symbol,
    decimals,
    price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this
    ) last_price
WHERE last_price.recency_rank = 1 --To get the most recent price for liquidity joining
),*/
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd
FROM all_trades
GROUP BY 1,2,3,4
),
sum_pairs_map AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
--CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
--,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd_map
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS(
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd AS suma ,b.sum_usd AS sumb,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair
FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
final_trading_pairs_map AS(
SELECT
--a.forward_pair,
--a.backward_pair,
a.forward_pair_map, a.backward_pair_map,
a.sum_usd_map AS suma ,b.sum_usd_map AS sumb,
CASE
WHEN RIGHT(a.backward_pair_map,3)='ETH' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,3)='ETH' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='ETH Token' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,9)='ETH Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='BTC Token' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,9)='BTC Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='USD Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='USD Stable' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='EUR Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='EUR Stable' THEN a.backward_pair_map
WHEN (a.sum_usd_map >= b.sum_usd_map) -- when a > b
OR b.sum_usd_map IS NULL -- or if backward usd is null
THEN a.forward_pair_map -- select forward
ELSE a.backward_pair_map --else select backward in every other circumstance
END AS trading_pair_map
FROM sum_pairs_map a
LEFT JOIN sum_pairs_map b
ON a.forward_pair_map = b.backward_pair_map
),


v_trades AS (
SELECT
atx.day_time,
atx.proj_v AS project_version,
--atx.*,  f1.*, f2.*,
--f1.trading_pair,
--f2.trading_pair,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
COALESCE(f1m.trading_pair_map,f2m.trading_pair_map) AS trading_pair_map,
atx.usd_traded,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map,
SUM(atx.usd_traded) OVER(PARTITION BY proj_v) AS total_usd_by_dex,
SUM(atx.usd_traded) OVER (PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map),atx.proj_v) AS total_usd_by_pair_map_dex,
--atx.fee_tier,
--atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
LEFT JOIN final_trading_pairs_map f1m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f1m.forward_pair_map
LEFT JOIN final_trading_pairs_map f2m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f2m.backward_pair_map
)
/*lp_withdraws AS(
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws
FROM (SELECT DISTINCT exchange_contract_address
FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_deposits AS(
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_tvl AS(
SELECT
net.lp_pos,
SUM(net.net_usd) AS tvl_usd
FROM (
    SELECT
    d.lp_pos,
    d.token,
    --d.project_version,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --how many tokens are in the LP
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) AS net_tokens_erc20, --tokens in the LP with appropriate decimals (only Dune logged erc20's)
    ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price AS net_usd --USD value of each token in the LP (Dune logged erc 20s only)
    FROM lp_deposits d
    INNER JOIN lp_withdraws w
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    --AND d.project_version = w.project_version
    LEFT JOIN most_recent_price p
    ON d.token = p.""contract_address""
    ) net
GROUP BY net.lp_pos
)*/
,trade_stats AS (
SELECT
--v.day_time,
v.trading_pair,
v.trading_pair_map,
v.project_version,
--,v.fee_tier
--,COUNT(v.trading_pair) AS num_trades
total_usd_by_pair,
total_usd_by_pair_map,
total_usd_by_dex,
total_usd_by_pair_map_dex,
SUM(v.usd_traded) AS total_usd,
SUM(v.usd_traded) / 
(CASE
WHEN total_usd_by_pair = 0 THEN 1 --handling for divide by zero errors that came up.
WHEN total_usd_by_pair IS NULL THEN 1
ELSE total_usd_by_pair
END) AS share_of_pair_usd,
RANK() OVER(PARTITION BY v.trading_pair ORDER BY SUM(v.usd_traded) DESC) AS pair_rank,
DENSE_RANK() OVER(ORDER BY total_usd_by_pair_map DESC) AS pair_map_rank,
DENSE_RANK() OVER (PARTITION BY v.trading_pair_map
    ORDER BY (total_usd_by_pair_map_dex) DESC) AS dex_rank_by_pair_map

--,SUM(v.fees_collected_usd) AS total_fees_usd
--,lp.tvl_usd AS total_value_locked
--,SUM(v.fees_collected_usd) / lp.tvl_usd AS fee_to_tvl_ratio
FROM v_trades v
--LEFT JOIN lp_tvl lp
--ON v.exchange_contract_address = lp.lp_pos
--AND v.project_version = lp.project_version
WHERE /*v.day_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '364 days'::INTERVAL)
AND*/ v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3,4,5,6,7--v.exchange_contract_address, v.trading_pair--, lp.tvl_usd, v.project_version--, v.fee_tier
--ORDER BY v.day_time, total_usd_by_pair DESC, SUM(v.usd_traded) DESC
--HAVING
--SUM(v.usd_traded) >100000 --Filter to remove outlier/small pairs
--AND lp.tvl_usd >1000 --remove more outliers / pairs with no prices
--ORDER BY SUM(v.fees_collected_usd) DESC
)
SELECT
trading_pair_map,
CASE WHEN
project_version = 'Uniswap v3' THEN '*Uniswap v3*'
WHEN dex_rank_by_pair_map <= 10 THEN project_version
ELSE 'Other'
END AS project_version,
total_usd_by_pair_map,
total_usd_by_dex,
pair_map_rank,
SUM(total_usd) AS total_usd_map,
SUM(total_usd)/total_usd_by_dex AS pct_of_dex

FROM trade_stats
WHERE
pair_map_rank <= 15
GROUP BY 1,2,3,4,5

--HAVING SUM(total_usd)/total_usd_by_pair_map > .0045 --Greater than 0.5% rounded up

ORDER BY total_usd_by_pair_map DESC
/*
SELECT
a.trading_pair, a.total_usd_by_pair, a.total_usd AS univ3_usd, a.share_of_pair_usd AS univ3_dominance,
b.project_version AS dominant_dex, b.total_usd AS best_usd, b.share_of_pair_usd AS best_pair_dominance,

CASE WHEN b.project_version = 'Uniswap v3' THEN 'Uniswap v3 winning the pair'
WHEN b.project_version = 'Uniswap v2' THEN 'Uniswap v2 winning the pair'
WHEN b.project_version = 'Uniswap v1' THEN 'Uniswap v1 winning the pair'
ELSE 'Uniswap losing the pair'
END AS pair_winner,
CASE WHEN b.project_version = 'Uniswap v3' THEN NULL
ELSE a.total_usd - b.total_usd
END AS univ3_delta,
a.total_usd_by_pair *(1-a.share_of_pair_usd) AS uncaptured_volume, -- total volume for each pair not going through v3
a.trading_pair_map
FROM trade_stats a
INNER JOIN (SELECT * FROM trade_stats WHERE pair_rank = 1) b
ON a.trading_pair = b.trading_pair
WHERE a.project_version = 'Uniswap v3'
ORDER BY a.total_usd_by_pair DESC
*/"
51498,Uni v3 - UXCA - Volume Share (Uni Loses),,table,"WITH all_trades_raw AS
(
SELECT

DATE_TRUNC('day',t.block_time) AS day_time,
CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version)
ELSE t.project
END AS proj_v,
---
-- Token Mapping --
---
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,

CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b,

t.exchange_contract_address -- exchange_contract_address is the LP Position
,SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t
/*The LP mint transaction has the fee rate as a parameter
1. Join on the LP (contract address) to get the mint transaction
2. Use the mint transaction to join to the Position Manager and get the fee rate
(I hope there's an easier way to do this eventually)
*/
WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL)
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2,3,4,5
),
token_mapping AS(
SELECT t.token,
CASE
WHEN t.token IN ('WETH','ETH') THEN 'ETH'
WHEN t.token IN ('sETH','stETH','ankrETH','rETH','cETH') THEN 'ETH Token'
WHEN t.token IN ('sUSD','sEUR','sAUD') THEN 'Synth Stable'
WHEN (t.token LIKE '%USD%') OR (t.token IN ('DAI','cDAI', 'FEI','FRAX','UST')) THEN 'USD'
WHEN (t.token IN ('EURS')) THEN 'EUR'
WHEN (t.token LIKE '%BTC%')
    OR t.token IN ('WBTC','renBTC','hBTC','sBTC','oBTC','pBTC','tBTC','bBTC','cWBTC','0xBTC', 'imBTC') THEN 'BTC Token'
WHEN t.token = 'UNI' THEN 'UNI'
WHEN t.token IN ('SUSHI', 'BNT', 'BAL','ZRX','KNC','1INCH','xSUSHI','WOO') THEN 'DEX Token'
WHEN t.token IN ('MKR','COMP','AAVE','YFI','SNX','LINK','CRV','ALCX','RAI','TRIBE',
    'VISR','UMA','REN','CREAM','FARM','MTA','TRU','RGT','LQTY','CONV')
    Then 'DeFi Token'
WHEN t.token IN ('VERA','ENJ','MANA','SAND','WAXE','AUDIO','RFOX','WHALE',
    'RARI','DG','TVK','REV','MEME','MUSE','AXS', 'SLP')
    Then 'Metaverse Token'    
WHEN t.token IN ('CEL','NEXO','eRSDL','GERO') Then 'CeDeFi Token'
WHEN t.token IN ('DPI','MVI') Then 'Index Token'
WHEN t.token IN ('MATIC','LRC','CTSI','OMG','QUICK') Then 'L2-Sidechain'
WHEN t.token IN ('RUNE','LUNA','FTM','CARDS','KYL','SRM','PSWAP','OCC','GLCH','DFYN') Then 'Alt/Cross-Chain'
WHEN (t.token LIKE '%DOGE%') OR (t.token IN ('SHIB','LEASH','ELON','AKITA','SHIH','WOOFY','KISHU')) THEN 'Meme' --WOOFY is debatable, but I think #1 use case is meme
WHEN (t.token LIKE '%2x-FLI%') OR (t.token = 'ETH2x ADL') THEN 'Leverage Token'
WHEN t.token IN ('sYFI','sXTZ','sXRP','sXMR','sXAU','sXAG','sUNI',
                'sTRX','sRUNE','sLTC','sLINK','sETH','sETC','sEOS','sDOT','sDEFI'
                'sDASH','sCRV','sCOMP','sADA','sAAVE') THEN 'Synth Token'
WHEN t.token IN ('sOIL') THEN 'Synth Commodity'
WHEN t.token IN ('sTSLA','sNFLX','sMSFT','sGOOG','sFTSE','sFB','sCOIN','sAMZN','sAAPL') THEN 'Synth Stock'
WHEN t.token IN ('GTC') THEN 'Cause Token'
WHEN t.token IN ('Burn Addr') THEN 'Burn Addr'
ELSE 'Unmapped'
END AS token_map
FROM (
    SELECT DISTINCT token_a AS token FROM all_trades_raw
    UNION
    SELECT DISTINCT token_b AS token FROM all_trades_raw
    ) t
),

all_trades AS(
SELECT
day_time, proj_v,
token_a, token_b,
exchange_contract_address,
usd_traded,
--pair type mapping--
m1.token_map as token_a_map,
m2.token_map as token_b_map
FROM
all_trades_raw r

LEFT JOIN token_mapping m1
ON r.token_a = m1.token
LEFT JOIN token_mapping m2
ON r.token_b = m2.token
),
/*
most_recent_price AS
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute,
    contract_address,
    symbol,
    decimals,
    price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this
    ) last_price
WHERE last_price.recency_rank = 1 --To get the most recent price for liquidity joining
),*/
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd
FROM all_trades
GROUP BY 1,2,3,4
),
sum_pairs_map AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
--CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
--,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd_map
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS(
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd AS suma ,b.sum_usd AS sumb,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair
FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
final_trading_pairs_map AS(
SELECT
--a.forward_pair,
--a.backward_pair,
a.forward_pair_map, a.backward_pair_map,
a.sum_usd_map AS suma ,b.sum_usd_map AS sumb,
CASE
WHEN RIGHT(a.backward_pair_map,3)='ETH' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,3)='ETH' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='ETH Token' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,9)='ETH Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='BTC Token' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,9)='BTC Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='USD Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='USD Stable' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='EUR Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='EUR Stable' THEN a.backward_pair_map
WHEN (a.sum_usd_map >= b.sum_usd_map) -- when a > b
OR b.sum_usd_map IS NULL -- or if backward usd is null
THEN a.forward_pair_map -- select forward
ELSE a.backward_pair_map --else select backward in every other circumstance
END AS trading_pair_map
FROM sum_pairs_map a
LEFT JOIN sum_pairs_map b
ON a.forward_pair_map = b.backward_pair_map
),


v_trades AS (
SELECT
atx.day_time,
atx.proj_v AS project_version,
--atx.*,  f1.*, f2.*,
--f1.trading_pair,
--f2.trading_pair,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
COALESCE(f1m.trading_pair_map,f2m.trading_pair_map) AS trading_pair_map,
atx.usd_traded,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair,
--SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map,
--atx.fee_tier,
--atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
LEFT JOIN final_trading_pairs_map f1m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f1m.forward_pair_map
LEFT JOIN final_trading_pairs_map f2m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f2m.backward_pair_map
)

/*lp_withdraws AS(
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws
FROM (SELECT DISTINCT exchange_contract_address
FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_deposits AS(
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_tvl AS(
SELECT
net.lp_pos,
SUM(net.net_usd) AS tvl_usd
FROM (
    SELECT
    d.lp_pos,
    d.token,
    --d.project_version,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --how many tokens are in the LP
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) AS net_tokens_erc20, --tokens in the LP with appropriate decimals (only Dune logged erc20's)
    ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price AS net_usd --USD value of each token in the LP (Dune logged erc 20s only)
    FROM lp_deposits d
    INNER JOIN lp_withdraws w
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    --AND d.project_version = w.project_version
    LEFT JOIN most_recent_price p
    ON d.token = p.""contract_address""
    ) net
GROUP BY net.lp_pos
)*/
,trade_stats AS (
SELECT
--v.day_time,
v.trading_pair,
v.trading_pair_map,
v.project_version,
--,v.fee_tier
--,COUNT(v.trading_pair) AS num_trades
total_usd_by_pair,
SUM(v.usd_traded) AS total_usd,
SUM(v.usd_traded) / 
(CASE
WHEN total_usd_by_pair = 0 THEN 1 --handling for divide by zero errors that came up.
WHEN total_usd_by_pair IS NULL THEN 1
ELSE total_usd_by_pair
END) AS share_of_pair_usd,
RANK() OVER(PARTITION BY v.trading_pair ORDER BY SUM(v.usd_traded) DESC) AS pair_rank

--,SUM(v.fees_collected_usd) AS total_fees_usd
--,lp.tvl_usd AS total_value_locked
--,SUM(v.fees_collected_usd) / lp.tvl_usd AS fee_to_tvl_ratio
FROM v_trades v
--LEFT JOIN lp_tvl lp
--ON v.exchange_contract_address = lp.lp_pos
--AND v.project_version = lp.project_version
WHERE /*v.day_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '364 days'::INTERVAL)
AND*/ v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3,4--v.exchange_contract_address, v.trading_pair--, lp.tvl_usd, v.project_version--, v.fee_tier
--ORDER BY v.day_time, total_usd_by_pair DESC, SUM(v.usd_traded) DESC
--HAVING
--SUM(v.usd_traded) >100000 --Filter to remove outlier/small pairs
--AND lp.tvl_usd >1000 --remove more outliers / pairs with no prices
--ORDER BY SUM(v.fees_collected_usd) DESC
),
starting_stats AS(
SELECT DISTINCT
trading_pair,
trading_pair_map,
total_usd_by_pair
FROM
trade_stats
)

SELECT
a.trading_pair, a.total_usd_by_pair, --a.total_usd AS univ3_usd, a.share_of_pair_usd AS univ3_dominance,
b.project_version AS dominant_dex, b.total_usd AS best_usd, b.share_of_pair_usd AS best_pair_dominance,

/*CASE WHEN b.project_version = 'Uniswap v3' THEN 'Uniswap v3 winning the pair'
WHEN b.project_version = 'Uniswap v2' THEN 'Uniswap v2 winning the pair'
WHEN b.project_version = 'Uniswap v1' THEN 'Uniswap v1 winning the pair'
ELSE 'Uniswap losing the pair'
END AS pair_winner,*/

CASE WHEN au.total_usd IS NULL THEN 0
ELSE au.total_usd
END AS univ3_usd,
CASE WHEN au.share_of_pair_usd IS NULL THEN 0
ELSE au.share_of_pair_usd
END AS univ3_dominance

,CASE WHEN b.project_version = 'Uniswap v3' THEN NULL
ELSE
(CASE WHEN au.total_usd IS NULL THEN 0
ELSE au.total_usd
END) - b.total_usd
END AS univ3_delta

,a.total_usd_by_pair *(1-
(CASE WHEN au.share_of_pair_usd IS NULL THEN 0
ELSE au.share_of_pair_usd
END)
) AS uncaptured_volume -- total volume for each pair not going through v3


,a.trading_pair_map

FROM starting_stats a
LEFT JOIN (SELECT * FROM trade_stats WHERE project_version = 'Uniswap v3') au --uni v3 pairs
ON a.trading_pair = au.trading_pair

INNER JOIN (SELECT * FROM trade_stats WHERE pair_rank = 1) b
ON a.trading_pair = b.trading_pair
WHERE /*a.project_version = 'Uniswap v3'
AND*/ b.project_version NOT LIKE '%Uniswap%' --To pull Univ3 Wins
ORDER BY a.total_usd_by_pair DESC
"
52014,Uni v3 UCXA - Top-Level Metrics,,counter,"WITH hrs AS(
SELECT
CASE
WHEN '{{Time Period}}' = '1 hour' THEN
    '0 hours'
WHEN '{{Time Period}}' = '6 hours' THEN
    '5 hours'
WHEN '{{Time Period}}' = '12 hours' THEN
    '11 hours'
WHEN '{{Time Period}}' = '24 hours' THEN
    '23 hours'
WHEN '{{Time Period}}' = '7 days' THEN
    '167 hours'
WHEN '{{Time Period}}' = '30 days' THEN
    '719 hours'
WHEN '{{Time Period}}' = '60 days' THEN
    '1439 hours'
WHEN '{{Time Period}}' = '90 days' THEN
    '2159 hours'
WHEN '{{Time Period}}' = '6 months' THEN
    '4379 hours'--(24*(365/2))-1 = 4379
WHEN '{{Time Period}}' = '1 year' THEN
    '8759 hours'--(24*365)-1 = 8759
END AS start,

CASE
WHEN '{{Time Period}}' = '1 hour' THEN
    '1 hour' --(0*2)+1
WHEN '{{Time Period}}' = '6 hours' THEN
    '11 hours' --(5*2)+1
WHEN '{{Time Period}}' = '12 hours' THEN
    '13 hours' --(11*2)+1
WHEN '{{Time Period}}' = '24 hours' THEN
    '47 hours' --(23*2)+1
WHEN '{{Time Period}}' = '7 days' THEN
    '335 hours' --(167*2)+1
WHEN '{{Time Period}}' = '30 days' THEN
    '1439 hours' --(719*2)+1
WHEN '{{Time Period}}' = '60 days' THEN
    '2879 hours'  --(1439*2)+1
WHEN '{{Time Period}}' = '90 days' THEN
    '4319 hours'  --(2159*2)+1
WHEN '{{Time Period}}' = '6 months' THEN
    '8757 hours' --(4379*2)+1
WHEN '{{Time Period}}' = '1 year' THEN
    '17519 hours'--(8759*2)+1
END AS endy

),

all_trades AS
(
SELECT
-- 'tx_from' is user address for dex.trades
DATE_TRUNC('hour',t.block_time) AS hr_time,
CONCAT (t.project, ' v',COALESCE(t.version,'1'))
AS proj_v,
---
-- Token Mapping -- TODO: Figure out if there's a better way to do this... Submit these to Dune's token mapping? Is there a better way?
---
t.exchange_contract_address -- exchange_contract_address is the LP Position
,SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t
/*The LP mint transaction has the fee rate as a parameter
1. Join on the LP (contract address) to get the mint transaction
2. Use the mint transaction to join to the Position Manager and get the fee rate
(I hope there's an easier way to do this eventually)
*/
WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time > (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL - '{{Time Period}}'::INTERVAL) --minus twice to handle for the change in growth
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2,3
),
num_users AS
(
SELECT
proj_v,
COUNT(DISTINCT (CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= (SELECT start FROM hrs)::INTERVAL) THEN tx_from END) )
AS users_curr,

COUNT(DISTINCT
    (CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time > (SELECT start FROM hrs)::INTERVAL)
    AND (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= (SELECT endy FROM hrs)::INTERVAL)
    THEN tx_from END) )
AS users_prev

FROM (
    SELECT
    tx_from,-- 'tx_from' is user address for dex.trades
    DATE_TRUNC('hour',t.block_time) AS hr_time,
    CONCAT (t.project, ' v',COALESCE(t.version,'1'))
    AS proj_v
    FROM dex.""trades"" t
    WHERE
    t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
    AND t.block_time > (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL - '{{Time Period}}'::INTERVAL) --greater than only because the parameter is last X days
    AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
    ) rawtr
    GROUP BY 1
),

/*
most_recent_price AS
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute,
    contract_address,
    symbol,
    decimals,
    price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this
    ) last_price
WHERE last_price.recency_rank = 1 --To get the most recent price for liquidity joining
),*/


v_trades AS (
SELECT
atx.hr_time,
atx.proj_v AS project_version,
--atx.*,  f1.*, f2.*,
--f1.trading_pair,
--f2.trading_pair,
atx.usd_traded,

SUM(atx.usd_traded) OVER () AS total_usd_all,
-- Longer-term, I should do these in a separate query, but I'm doing these calcs here so that I can cascade them down to the final table. It's a mess

SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= (SELECT start FROM hrs)::INTERVAL) THEN atx.usd_traded ELSE 0 END) OVER()
AS total_usd_all_curr,

SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time > (SELECT start FROM hrs)::INTERVAL) AND (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= (SELECT endy FROM hrs)::INTERVAL)
    THEN atx.usd_traded ELSE 0 END) OVER()
AS total_usd_all_prev,

atx.exchange_contract_address
FROM all_trades atx
)
,trade_stats AS (
SELECT
v.hr_time,
v.project_version,
total_usd_all,
total_usd_all_curr,
total_usd_all_prev,
SUM(v.usd_traded) AS total_usd

FROM v_trades v

WHERE
v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3,4,5
),
growth_stats AS (
SELECT
project_version,
total_usd_all,
total_usd_all_curr,
total_usd_all_prev,

SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= (SELECT start FROM hrs)::INTERVAL) THEN total_usd ELSE 0 END)
AS total_usd_curr,

SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time > (SELECT start FROM hrs)::INTERVAL)
    AND (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= (SELECT endy FROM hrs)::INTERVAL) --(23*2)+1
THEN total_usd ELSE 0 END)
AS total_usd_prev

FROM trade_stats
GROUP BY 1,2,3,4

),
topplevel AS(
SELECT

CASE WHEN project_version = 'Uniswap v3' THEN '*Uniswap v3*'
ELSE project_version
END AS project_version,
total_usd_curr / total_usd_all_curr AS share,

CASE WHEN (total_usd_prev IS NULL) OR (total_usd_prev=0) THEN NULL
ELSE (total_usd_curr / total_usd_all_curr) - (total_usd_prev / total_usd_all_prev)
END AS share_growth,

total_usd_curr,
CASE WHEN (total_usd_prev IS NULL) OR (total_usd_prev=0) THEN NULL
ELSE (total_usd_curr - total_usd_prev)/total_usd_prev
END AS usd_growth,
n.users_curr,
CASE WHEN (n.users_prev IS NULL) OR (n.users_prev=0) THEN NULL
ELSE (n.users_curr::decimal - n.users_prev::decimal)/n.users_prev::decimal
END AS growth_users


FROM growth_stats g
LEFT JOIN num_users n
ON n.proj_v = g.project_version

)

SELECT
project_version, --just to validate it's working
--uni v3 volume share
share*100 AS v3_share,
--uni v3 volume share change
share_growth*100 AS v3_share_change,
--uni v3 volume
total_usd_curr AS v3_volume,
        --formatted in billys
total_usd_curr::decimal/1000000000 AS v3_volume_billy,
total_usd_curr::decimal/1000000 AS v3_volume_milly,
--uni v3 volume change
usd_growth*100 AS v3_volume_change,
--uni v3 users
users_curr AS v3_users,
        --thousands
users_curr::decimal/1000 AS v3_users_thousy,
--uni v3 users change
growth_users*100 AS v3_users_growth
FROM topplevel
WHERE project_version = '*Uniswap v3*'"
52081,Uni v3 UCXA - Growth Metrics,,counter,"WITH
dater AS
(SELECT
'61 days' AS range), --Just so I don't have to rewrite this 100 times. --since the table stops at 30 days (30*2 = 60)

all_trades AS
(
SELECT
-- 'tx_from' is user address for dex.trades
DATE_TRUNC('hour',t.block_time) AS hr_time,
CONCAT (t.project, ' v',COALESCE(t.version,'1'))
AS proj_v,
---
-- Token Mapping -- TODO: Figure out if there's a better way to do this... Submit these to Dune's token mapping? Is there a better way?
---
t.exchange_contract_address -- exchange_contract_address is the LP Position
,SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t
/*The LP mint transaction has the fee rate as a parameter
1. Join on the LP (contract address) to get the mint transaction
2. Use the mint transaction to join to the Position Manager and get the fee rate
(I hope there's an easier way to do this eventually)
*/
WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
/*t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND*/ t.block_time > (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - (SELECT range from dater)::INTERVAL)
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2,3
),
num_users AS
(
SELECT
proj_v,
COUNT(DISTINCT (CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '23 hours'::INTERVAL) THEN tx_from END) ) AS users_24h,
    COUNT(DISTINCT
            (CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time > '23 hours'::INTERVAL)
            AND (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '47 hours'::INTERVAL) --(23*2)+1
            THEN tx_from END)
        ) AS users_24h_prev,
COUNT(DISTINCT (CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '167 hours'::INTERVAL) THEN tx_from END) ) AS users_1w, --(24*7)-1 = 167
    COUNT(DISTINCT (CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time > '167 hours'::INTERVAL)
        AND (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '335 hours'::INTERVAL) --(167*2)+1
    THEN tx_from END) ) AS users_1w_prev,
COUNT(DISTINCT (CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '719 hours'::INTERVAL) THEN tx_from END) ) AS users_30d, --(24*30)-1 = 719
    COUNT(DISTINCT (CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time > '719 hours'::INTERVAL)
        AND (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '1439 hours'::INTERVAL) --(719*2)+1
    THEN tx_from END) ) AS users_30d_prev
FROM (
    SELECT
    tx_from,-- 'tx_from' is user address for dex.trades
    DATE_TRUNC('hour',t.block_time) AS hr_time,
    CONCAT (t.project, ' v',COALESCE(t.version,'1'))
    AS proj_v
    FROM dex.""trades"" t
    WHERE
    /*t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
    AND*/ t.block_time > (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - (SELECT range from dater)::INTERVAL) --greater than only because the parameter is last X days
    AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
    ) rawtr
    GROUP BY 1
),

/*
most_recent_price AS
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute,
    contract_address,
    symbol,
    decimals,
    price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this
    ) last_price
WHERE last_price.recency_rank = 1 --To get the most recent price for liquidity joining
),*/


v_trades AS (
SELECT
atx.hr_time,
atx.proj_v AS project_version,
--atx.*,  f1.*, f2.*,
--f1.trading_pair,
--f2.trading_pair,
atx.usd_traded,

SUM(atx.usd_traded) OVER () AS total_usd_all,
-- Longer-term, I should do these in a separate query, but I'm doing these calcs here so that I can cascade them down to the final table. It's a mess
SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '23 hours'::INTERVAL) THEN atx.usd_traded ELSE 0 END) OVER() AS total_usd_all_24h,
SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '167 hours'::INTERVAL) THEN atx.usd_traded ELSE 0 END) OVER() AS total_usd_all_1w,
SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '719 hours'::INTERVAL) THEN atx.usd_traded ELSE 0 END) OVER() AS total_usd_all_30d,
SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time > '23 hours'::INTERVAL) AND (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '47 hours'::INTERVAL)
    THEN atx.usd_traded ELSE 0 END) OVER() AS total_usd_all_24h_prev,
SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time > '167 hours'::INTERVAL) AND (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '335 hours'::INTERVAL)
    THEN atx.usd_traded ELSE 0 END) OVER() AS total_usd_all_1w_prev,
SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time > '719 hours'::INTERVAL) AND (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '1439 hours'::INTERVAL)
    THEN atx.usd_traded ELSE 0 END) OVER() AS total_usd_all_30d_prev,
--atx.fee_tier,
--atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx
)
,trade_stats AS (
SELECT
v.hr_time,
v.project_version,
total_usd_all,
total_usd_all_24h,
total_usd_all_1w,
total_usd_all_30d,
total_usd_all_24h_prev,
total_usd_all_1w_prev,
total_usd_all_30d_prev,
SUM(v.usd_traded) AS total_usd

FROM v_trades v

WHERE
v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3,4,5,6,7,8,9
),
growth_stats AS (
SELECT
project_version,
total_usd_all_24h,
total_usd_all_1w,
total_usd_all_30d,
total_usd_all_24h_prev,
total_usd_all_1w_prev,
total_usd_all_30d_prev,

SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '23 hours'::INTERVAL) THEN total_usd ELSE 0 END) AS total_usd_24h,
    SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time > '23 hours'::INTERVAL)
        AND (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '47 hours'::INTERVAL) --(23*2)+1
    THEN total_usd ELSE 0 END) AS total_usd_24h_prev,
SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '167 hours'::INTERVAL) THEN total_usd ELSE 0 END) AS total_usd_1w, --(24*7)-1 = 167
    SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time > '167 hours'::INTERVAL)
        AND (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '335 hours'::INTERVAL) --(167*2)+1
    THEN total_usd ELSE 0 END) AS total_usd_1w_prev,
SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '719 hours'::INTERVAL) THEN total_usd ELSE 0 END) AS total_usd_30d, --(24*30)-1 = 719
    SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time > '719 hours'::INTERVAL)
        AND (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '1439 hours'::INTERVAL) --(719*2)+1
    THEN total_usd ELSE 0 END) AS total_usd_30d_prev
--SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '2159 hours'::INTERVAL) THEN total_usd ELSE 0 END) AS total_usd_90d, --(24*90)-1 = 2159
--SUM(CASE WHEN (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - hr_time <= '8759 hours'::INTERVAL) THEN total_usd ELSE 0 END) AS total_usd_1y --(24*365)-1 = 8759
--SUM(total_usd) / (SUM(total_usd) OVER ()) AS total_usd--,
/*SUM(CASE WHEN project_version = 'Uniswap v3' THEN total_usd ELSE 0 END) AS total_usd_univ3,
SUM(CASE WHEN project_version = 'Uniswap v3' THEN total_usd ELSE 0 END) /1000000 AS total_usd_univ3_m,
SUM(CASE WHEN project_version = 'Uniswap v3' THEN total_usd ELSE 0 END) /1000000000 AS total_usd_univ3_b,
SUM(CASE WHEN project_version = 'Uniswap v2' THEN total_usd ELSE 0 END) AS total_usd_univ2,
SUM(CASE WHEN project_version LIKE '%Uniswap%' THEN total_usd ELSE 0 END) AS total_usd_alluni,
(SUM(CASE WHEN project_version LIKE '%Uniswap%' THEN total_usd ELSE 0 END) / SUM(total_usd))*100 AS alluni_dex_share,
(SUM(CASE WHEN project_version = 'Uniswap v3' THEN total_usd ELSE 0 END) / SUM(total_usd))*100 AS univ3_dex_share
*/--,
--SUM(total_usd)/total_usd_by_dex AS pct_of_dex,
--SUM(total_usd)/total_usd_by_pair AS pct_of_pair
FROM trade_stats
GROUP BY 1,2,3,4,5,6,7
--WHERE
--project_version LIKE '%Uniswap%'
--trade_pair_rank <= 25
--GROUP BY 1,2,3--,4,5,6,7,8

--HAVING SUM(total_usd)/total_usd_by_pair > .0005 --Greater than 0.5% rounded up

--ORDER BY trade_pair_rank ASC
)
SELECT
RANK() OVER(ORDER BY total_usd_1w DESC) AS dexy_rank,

CASE WHEN project_version = 'Uniswap v3' THEN '*Uniswap v3*'
ELSE project_version
END AS project_version,
CASE WHEN (total_usd_all_24h IS NULL) OR (total_usd_all_24h=0) THEN 0
ELSE total_usd_24h / total_usd_all_24h
END AS share_24h,

CASE WHEN (total_usd_all_24h_prev IS NULL) OR (total_usd_all_24h_prev=0) THEN 0
ELSE ((total_usd_24h / total_usd_all_24h) - (total_usd_24h_prev / total_usd_all_24h_prev))*100
END AS share_24h_growth,

total_usd_24h,
CASE WHEN (total_usd_24h_prev IS NULL) OR (total_usd_24h_prev=0) THEN 0
ELSE (total_usd_24h - total_usd_24h_prev)/total_usd_24h_prev
END AS growth_24h,
n.users_24h,
CASE WHEN (users_24h_prev IS NULL) OR (users_24h_prev=0) THEN 0
ELSE (n.users_24h::decimal - n.users_24h_prev::decimal)/n.users_24h_prev::decimal
END AS growth_users_24h,

""total_usd_1w"" / ""total_usd_all_1w"" AS share_1w,
CASE WHEN (total_usd_all_1w_prev IS NULL) OR (total_usd_all_1w_prev=0) THEN 0
ELSE ((total_usd_1w / total_usd_all_1w) - (total_usd_1w_prev / total_usd_all_1w_prev))*100
END AS share_1w_growth,

total_usd_1w,
CASE WHEN (total_usd_1w_prev IS NULL) OR (total_usd_1w_prev=0) THEN 0
ELSE (total_usd_1w - total_usd_1w_prev)/total_usd_1w_prev 
END AS growth_1w,
n.users_1w,
CASE WHEN (users_1w_prev IS NULL) OR (users_1w_prev=0) THEN 0
ELSE (n.users_1w::decimal - n.users_1w_prev::decimal)/n.users_1w_prev::decimal
END AS growth_users_1w,

""total_usd_30d"" / ""total_usd_all_30d"" AS share_30d,
CASE WHEN (total_usd_all_30d_prev IS NULL) OR (total_usd_all_30d_prev=0) THEN 0
ELSE ((total_usd_30d / total_usd_all_30d) - (total_usd_30d_prev / total_usd_all_30d_prev))*100
END AS share_30d_growth,

total_usd_30d,
CASE WHEN (total_usd_30d_prev IS NULL) OR (total_usd_30d_prev=0) THEN 0
ELSE (total_usd_30d - total_usd_30d_prev)/total_usd_30d_prev
END AS growth_30d,
n.users_30d,
CASE WHEN (users_30d_prev IS NULL) OR (users_30d_prev=0) THEN 0
ELSE (n.users_30d::decimal - n.users_30d_prev::decimal)/n.users_30d_prev::decimal
END AS growth_users_30d


FROM growth_stats g
LEFT JOIN num_users n
ON n.proj_v = g.project_version

WHERE total_usd_30d > 0

ORDER BY total_usd_1w DESC

"
53525,Uni v3 - UXCA - DEX Share by Pairs,,table,"WITH all_trades_raw AS
(
SELECT

DATE_TRUNC('day',t.block_time) AS day_time,
CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version)
ELSE t.project
END AS proj_v,
---
-- Token Mapping --
---
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,

CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b,

t.exchange_contract_address -- exchange_contract_address is the LP Position
,SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t
/*The LP mint transaction has the fee rate as a parameter
1. Join on the LP (contract address) to get the mint transaction
2. Use the mint transaction to join to the Position Manager and get the fee rate
(I hope there's an easier way to do this eventually)
*/
WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL)
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2,3,4,5
),
token_mapping AS(
SELECT t.token,
CASE
WHEN t.token IN ('WETH','ETH') THEN 'ETH'
WHEN t.token IN ('sETH','stETH','ankrETH','rETH','cETH') THEN 'ETH Token'
WHEN t.token IN ('sUSD','sEUR','sAUD') THEN 'Synth Stable'
WHEN (t.token LIKE '%USD%') OR (t.token IN ('DAI','cDAI', 'FEI','FRAX','UST')) THEN 'USD'
WHEN (t.token IN ('EURS')) THEN 'EUR'
WHEN t.token IN ('WBTC','renBTC','hBTC','sBTC','oBTC','pBTC','tBTC','bBTC','cWBTC','0xBTC') THEN 'BTC Token'
WHEN t.token = 'UNI' THEN 'UNI'
WHEN t.token IN ('SUSHI', 'BNT', 'BAL','ZRX','KNC','1INCH','xSUSHI','WOO') THEN 'DEX Token'
WHEN t.token IN ('MKR','COMP','AAVE','YFI','SNX','LINK','CRV','ALCX','RAI','TRIBE',
    'VISR','UMA','REN','CREAM','FARM','MTA','TRU','RGT','LQTY','CONV')
    Then 'DeFi Token'
WHEN t.token IN ('VERA','ENJ','MANA','SAND','WAXE','AUDIO','RFOX','WHALE',
    'RARI','DG','TVK','REV','MEME','MUSE','AXS', 'SLP')
    Then 'Metaverse Token'    
WHEN t.token IN ('CEL','NEXO','eRSDL','GERO') Then 'CeDeFi Token'
WHEN t.token IN ('DPI','MVI') Then 'Index Token'
WHEN t.token IN ('MATIC','LRC','CTSI','OMG','QUICK') Then 'L2-Sidechain'
WHEN t.token IN ('RUNE','LUNA','FTM','CARDS','KYL','SRM','PSWAP','OCC','GLCH','DFYN') Then 'Alt/Cross-Chain'
WHEN (t.token LIKE '%DOGE%') OR (t.token IN ('SHIB','LEASH','ELON','AKITA','SHIH','WOOFY','KISHU')) THEN 'Meme' --WOOFY is debatable, but I think #1 use case is meme
WHEN (t.token LIKE '%2x-FLI%') OR (t.token = 'ETH2x ADL') THEN 'Leverage Token'
WHEN t.token IN ('sYFI','sXTZ','sXRP','sXMR','sXAU','sXAG','sUNI',
                'sTRX','sRUNE','sLTC','sLINK','sETH','sETC','sEOS','sDOT','sDEFI'
                'sDASH','sCRV','sCOMP','sADA','sAAVE') THEN 'Synth Token'
WHEN t.token IN ('sOIL') THEN 'Synth Commodity'
WHEN t.token IN ('sTSLA','sNFLX','sMSFT','sGOOG','sFTSE','sFB','sCOIN','sAMZN','sAAPL') THEN 'Synth Stock'
WHEN t.token IN ('GTC') THEN 'Cause Token'
WHEN t.token IN ('Burn Addr') THEN 'Burn Addr'
ELSE 'Unmapped'
END AS token_map
FROM (
    SELECT DISTINCT token_a AS token FROM all_trades_raw
    UNION
    SELECT DISTINCT token_b AS token FROM all_trades_raw
    ) t
),

all_trades AS(
SELECT
day_time, proj_v,
token_a, token_b,
exchange_contract_address,
usd_traded,
--pair type mapping--
m1.token_map as token_a_map,
m2.token_map as token_b_map
FROM
all_trades_raw r

LEFT JOIN token_mapping m1
ON r.token_a = m1.token
LEFT JOIN token_mapping m2
ON r.token_b = m2.token
),

/*
most_recent_price AS
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute,
    contract_address,
    symbol,
    decimals,
    price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this
    ) last_price
WHERE last_price.recency_rank = 1 --To get the most recent price for liquidity joining
),*/
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd
FROM all_trades
GROUP BY 1,2,3,4
),
sum_pairs_map AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
--CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
--,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd_map
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS(
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd AS suma ,b.sum_usd AS sumb,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair
FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
final_trading_pairs_map AS(
SELECT
--a.forward_pair,
--a.backward_pair,
a.forward_pair_map, a.backward_pair_map,
a.sum_usd_map AS suma ,b.sum_usd_map AS sumb,
CASE
WHEN RIGHT(a.backward_pair_map,3)='ETH' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,3)='ETH' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='ETH Token' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,9)='ETH Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='BTC Token' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,9)='BTC Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='USD Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='USD Stable' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='EUR Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='EUR Stable' THEN a.backward_pair_map
WHEN (a.sum_usd_map >= b.sum_usd_map) -- when a > b
OR b.sum_usd_map IS NULL -- or if backward usd is null
THEN a.forward_pair_map -- select forward
ELSE a.backward_pair_map --else select backward in every other circumstance
END AS trading_pair_map
FROM sum_pairs_map a
LEFT JOIN sum_pairs_map b
ON a.forward_pair_map = b.backward_pair_map
),


v_trades AS (
SELECT
atx.day_time,
atx.proj_v AS project_version,
--atx.*,  f1.*, f2.*,
--f1.trading_pair,
--f2.trading_pair,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
COALESCE(f1m.trading_pair_map,f2m.trading_pair_map) AS trading_pair_map,
atx.usd_traded,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map,
SUM(atx.usd_traded) OVER(PARTITION BY proj_v) AS total_usd_by_dex,
SUM(atx.usd_traded) OVER(PARTITION BY proj_v, COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map_dex,
SUM(atx.usd_traded) OVER(PARTITION BY proj_v, COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair_dex,
--atx.fee_tier,
--atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
LEFT JOIN final_trading_pairs_map f1m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f1m.forward_pair_map
LEFT JOIN final_trading_pairs_map f2m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f2m.backward_pair_map
)
/*lp_withdraws AS(
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws
FROM (SELECT DISTINCT exchange_contract_address
FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_deposits AS(
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_tvl AS(
SELECT
net.lp_pos,
SUM(net.net_usd) AS tvl_usd
FROM (
    SELECT
    d.lp_pos,
    d.token,
    --d.project_version,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --how many tokens are in the LP
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) AS net_tokens_erc20, --tokens in the LP with appropriate decimals (only Dune logged erc20's)
    ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price AS net_usd --USD value of each token in the LP (Dune logged erc 20s only)
    FROM lp_deposits d
    INNER JOIN lp_withdraws w
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    --AND d.project_version = w.project_version
    LEFT JOIN most_recent_price p
    ON d.token = p.""contract_address""
    ) net
GROUP BY net.lp_pos
)*/
,trade_stats AS (
SELECT
--v.day_time,
v.trading_pair,
v.trading_pair_map,
v.project_version,
--,v.fee_tier
--,COUNT(v.trading_pair) AS num_trades
total_usd_by_pair,
total_usd_by_pair_map,
total_usd_by_dex,
total_usd_by_pair_map_dex,
total_usd_by_pair_dex,
SUM(v.usd_traded) AS total_usd,
SUM(v.usd_traded) / 
(CASE
WHEN total_usd_by_pair = 0 THEN 1 --handling for divide by zero errors that came up.
WHEN total_usd_by_pair IS NULL THEN 1
ELSE total_usd_by_pair
END) AS share_of_pair_usd,
RANK() OVER(PARTITION BY v.trading_pair ORDER BY SUM(v.usd_traded) DESC) AS pair_rank,
DENSE_RANK() OVER (ORDER BY total_usd_by_pair DESC) AS trade_pair_rank,
DENSE_RANK() OVER (ORDER BY total_usd_by_dex DESC) AS dex_rank,
DENSE_RANK() OVER (PARTITION BY v.project_version ORDER BY SUM(v.usd_traded) DESC) AS dex_rank_by_pair,
DENSE_RANK() OVER (PARTITION BY project_version ORDER BY total_usd_by_pair_map_dex DESC) AS trade_pair_map_dex_rank,
DENSE_RANK() OVER (PARTITION BY project_version ORDER BY total_usd_by_pair_dex DESC) AS trade_pair_dex_rank

--,SUM(v.fees_collected_usd) AS total_fees_usd
--,lp.tvl_usd AS total_value_locked
--,SUM(v.fees_collected_usd) / lp.tvl_usd AS fee_to_tvl_ratio
FROM v_trades v
--LEFT JOIN lp_tvl lp
--ON v.exchange_contract_address = lp.lp_pos
--AND v.project_version = lp.project_version
WHERE /*v.day_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '364 days'::INTERVAL)
AND*/ v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3,4,5,6,7,8--v.exchange_contract_address, v.trading_pair--, lp.tvl_usd, v.project_version--, v.fee_tier
--ORDER BY v.day_time, total_usd_by_pair DESC, SUM(v.usd_traded) DESC
--HAVING
--SUM(v.usd_traded) >100000 --Filter to remove outlier/small pairs
--AND lp.tvl_usd >1000 --remove more outliers / pairs with no prices
--ORDER BY SUM(v.fees_collected_usd) DESC
)
SELECT
CASE WHEN trade_pair_dex_rank <=10 THEN trading_pair--_map
ELSE 'Other' END
AS trading_pair,--_map,
project_version,
total_usd_by_dex,
SUM(total_usd) AS total_usd,
SUM(total_usd)/total_usd_by_dex AS pct_of_dex
FROM trade_stats
WHERE
dex_rank <= 10
GROUP BY 1,2,3
--HAVING SUM(total_usd)/total_usd_by_dex > .0045 --Greater than 0.5% rounded up
ORDER BY total_usd_by_dex DESC, SUM(total_usd) DESC
"
51511,Uni v3 - UXCA - DEX Share by Pair Type,,table,"WITH all_trades_raw AS
(
SELECT

DATE_TRUNC('day',t.block_time) AS day_time,
CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version)
ELSE t.project
END AS proj_v,
---
-- Token Mapping --
---
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,

CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b,

t.exchange_contract_address -- exchange_contract_address is the LP Position
,SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t
/*The LP mint transaction has the fee rate as a parameter
1. Join on the LP (contract address) to get the mint transaction
2. Use the mint transaction to join to the Position Manager and get the fee rate
(I hope there's an easier way to do this eventually)
*/
WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL)
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2,3,4,5
),
token_mapping AS(
SELECT t.token,
CASE
WHEN t.token IN ('WETH','ETH') THEN 'ETH'
WHEN t.token IN ('sETH','stETH','ankrETH','rETH','cETH') THEN 'ETH Token'
WHEN t.token IN ('sUSD','sEUR','sAUD') THEN 'Synth Stable'
WHEN (t.token LIKE '%USD%') OR (t.token IN ('DAI','cDAI', 'FEI','FRAX','UST')) THEN 'USD'
WHEN (t.token IN ('EURS')) THEN 'EUR'
WHEN t.token IN ('WBTC','renBTC','hBTC','sBTC','oBTC','pBTC','tBTC','bBTC','cWBTC','0xBTC') THEN 'BTC Token'
WHEN t.token = 'UNI' THEN 'UNI'
WHEN t.token IN ('SUSHI', 'BNT', 'BAL','ZRX','KNC','1INCH','xSUSHI','WOO') THEN 'DEX Token'
WHEN t.token IN ('MKR','COMP','AAVE','YFI','SNX','LINK','CRV','ALCX','RAI','TRIBE',
    'VISR','UMA','REN','CREAM','FARM','MTA','TRU','RGT','LQTY','CONV')
    Then 'DeFi Token'
WHEN t.token IN ('VERA','ENJ','MANA','SAND','WAXE','AUDIO','RFOX','WHALE',
    'RARI','DG','TVK','REV','MEME','MUSE','AXS', 'SLP')
    Then 'Metaverse Token'    
WHEN t.token IN ('CEL','NEXO','eRSDL','GERO') Then 'CeDeFi Token'
WHEN t.token IN ('DPI','MVI') Then 'Index Token'
WHEN t.token IN ('MATIC','LRC','CTSI','OMG','QUICK') Then 'L2-Sidechain'
WHEN t.token IN ('RUNE','LUNA','FTM','CARDS','KYL','SRM','PSWAP','OCC','GLCH','DFYN') Then 'Alt/Cross-Chain'
WHEN (t.token LIKE '%DOGE%') OR (t.token IN ('SHIB','LEASH','ELON','AKITA','SHIH','WOOFY','KISHU')) THEN 'Meme' --WOOFY is debatable, but I think #1 use case is meme
WHEN (t.token LIKE '%2x-FLI%') OR (t.token = 'ETH2x ADL') THEN 'Leverage Token'
WHEN t.token IN ('sYFI','sXTZ','sXRP','sXMR','sXAU','sXAG','sUNI',
                'sTRX','sRUNE','sLTC','sLINK','sETH','sETC','sEOS','sDOT','sDEFI'
                'sDASH','sCRV','sCOMP','sADA','sAAVE') THEN 'Synth Token'
WHEN t.token IN ('sOIL') THEN 'Synth Commodity'
WHEN t.token IN ('sTSLA','sNFLX','sMSFT','sGOOG','sFTSE','sFB','sCOIN','sAMZN','sAAPL') THEN 'Synth Stock'
WHEN t.token IN ('GTC') THEN 'Cause Token'
WHEN t.token IN ('Burn Addr') THEN 'Burn Addr'
ELSE 'Unmapped'
END AS token_map
FROM (
    SELECT DISTINCT token_a AS token FROM all_trades_raw
    UNION
    SELECT DISTINCT token_b AS token FROM all_trades_raw
    ) t
),

all_trades AS(
SELECT
day_time, proj_v,
token_a, token_b,
exchange_contract_address,
usd_traded,
--pair type mapping--
m1.token_map as token_a_map,
m2.token_map as token_b_map
FROM
all_trades_raw r

LEFT JOIN token_mapping m1
ON r.token_a = m1.token
LEFT JOIN token_mapping m2
ON r.token_b = m2.token
),

/*
most_recent_price AS
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute,
    contract_address,
    symbol,
    decimals,
    price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this
    ) last_price
WHERE last_price.recency_rank = 1 --To get the most recent price for liquidity joining
),*/
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd
FROM all_trades
GROUP BY 1,2,3,4
),
sum_pairs_map AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
--CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
--,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd_map
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS(
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd AS suma ,b.sum_usd AS sumb,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair
FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
final_trading_pairs_map AS(
SELECT
--a.forward_pair,
--a.backward_pair,
a.forward_pair_map, a.backward_pair_map,
a.sum_usd_map AS suma ,b.sum_usd_map AS sumb,
CASE
WHEN RIGHT(a.backward_pair_map,3)='ETH' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,3)='ETH' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='ETH Token' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,9)='ETH Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='BTC Token' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,9)='BTC Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='USD Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='USD Stable' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='EUR Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='EUR Stable' THEN a.backward_pair_map
WHEN (a.sum_usd_map >= b.sum_usd_map) -- when a > b
OR b.sum_usd_map IS NULL -- or if backward usd is null
THEN a.forward_pair_map -- select forward
ELSE a.backward_pair_map --else select backward in every other circumstance
END AS trading_pair_map
FROM sum_pairs_map a
LEFT JOIN sum_pairs_map b
ON a.forward_pair_map = b.backward_pair_map
),


v_trades AS (
SELECT
atx.day_time,
atx.proj_v AS project_version,
--atx.*,  f1.*, f2.*,
--f1.trading_pair,
--f2.trading_pair,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
COALESCE(f1m.trading_pair_map,f2m.trading_pair_map) AS trading_pair_map,
atx.usd_traded,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map,
SUM(atx.usd_traded) OVER(PARTITION BY proj_v) AS total_usd_by_dex,
SUM(atx.usd_traded) OVER(PARTITION BY proj_v, COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map_dex,
--atx.fee_tier,
--atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
LEFT JOIN final_trading_pairs_map f1m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f1m.forward_pair_map
LEFT JOIN final_trading_pairs_map f2m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f2m.backward_pair_map
)
/*lp_withdraws AS(
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws
FROM (SELECT DISTINCT exchange_contract_address
FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_deposits AS(
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_tvl AS(
SELECT
net.lp_pos,
SUM(net.net_usd) AS tvl_usd
FROM (
    SELECT
    d.lp_pos,
    d.token,
    --d.project_version,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --how many tokens are in the LP
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) AS net_tokens_erc20, --tokens in the LP with appropriate decimals (only Dune logged erc20's)
    ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price AS net_usd --USD value of each token in the LP (Dune logged erc 20s only)
    FROM lp_deposits d
    INNER JOIN lp_withdraws w
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    --AND d.project_version = w.project_version
    LEFT JOIN most_recent_price p
    ON d.token = p.""contract_address""
    ) net
GROUP BY net.lp_pos
)*/
,trade_stats AS (
SELECT
--v.day_time,
v.trading_pair,
v.trading_pair_map,
v.project_version,
--,v.fee_tier
--,COUNT(v.trading_pair) AS num_trades
total_usd_by_pair,
total_usd_by_pair_map,
total_usd_by_dex,
total_usd_by_pair_map_dex,
SUM(v.usd_traded) AS total_usd,
SUM(v.usd_traded) / 
(CASE
WHEN total_usd_by_pair = 0 THEN 1 --handling for divide by zero errors that came up.
WHEN total_usd_by_pair IS NULL THEN 1
ELSE total_usd_by_pair
END) AS share_of_pair_usd,
RANK() OVER(PARTITION BY v.trading_pair ORDER BY SUM(v.usd_traded) DESC) AS pair_rank,
DENSE_RANK() OVER (ORDER BY total_usd_by_pair DESC) AS trade_pair_rank,
DENSE_RANK() OVER (ORDER BY total_usd_by_dex DESC) AS dex_rank,
DENSE_RANK() OVER (PARTITION BY v.project_version ORDER BY SUM(v.usd_traded) DESC) AS dex_rank_by_pair,
DENSE_RANK() OVER (PARTITION BY project_version ORDER BY total_usd_by_pair_map_dex DESC) AS trade_pair_map_dex_rank

--,SUM(v.fees_collected_usd) AS total_fees_usd
--,lp.tvl_usd AS total_value_locked
--,SUM(v.fees_collected_usd) / lp.tvl_usd AS fee_to_tvl_ratio
FROM v_trades v
--LEFT JOIN lp_tvl lp
--ON v.exchange_contract_address = lp.lp_pos
--AND v.project_version = lp.project_version
WHERE /*v.day_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '364 days'::INTERVAL)
AND*/ v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3,4,5,6,7--v.exchange_contract_address, v.trading_pair--, lp.tvl_usd, v.project_version--, v.fee_tier
--ORDER BY v.day_time, total_usd_by_pair DESC, SUM(v.usd_traded) DESC
--HAVING
--SUM(v.usd_traded) >100000 --Filter to remove outlier/small pairs
--AND lp.tvl_usd >1000 --remove more outliers / pairs with no prices
--ORDER BY SUM(v.fees_collected_usd) DESC
)
SELECT
CASE WHEN trade_pair_map_dex_rank <=10 THEN trading_pair_map
ELSE 'Other' END
AS trading_pair_map,
project_version,
total_usd_by_dex,
SUM(total_usd) AS total_usd_map,
SUM(total_usd)/total_usd_by_dex AS pct_of_dex
FROM trade_stats
WHERE
dex_rank <= 10
GROUP BY 1,2,3
--HAVING SUM(total_usd)/total_usd_by_dex > .0045 --Greater than 0.5% rounded up
ORDER BY total_usd_by_dex DESC, SUM(total_usd) DESC

/*
SELECT
a.trading_pair, a.total_usd_by_pair, a.total_usd AS univ3_usd, a.share_of_pair_usd AS univ3_dominance,
b.project_version AS dominant_dex, b.total_usd AS best_usd, b.share_of_pair_usd AS best_pair_dominance,

CASE WHEN b.project_version = 'Uniswap v3' THEN 'Uniswap v3 winning the pair'
WHEN b.project_version = 'Uniswap v2' THEN 'Uniswap v2 winning the pair'
WHEN b.project_version = 'Uniswap v1' THEN 'Uniswap v1 winning the pair'
ELSE 'Uniswap losing the pair'
END AS pair_winner,
CASE WHEN b.project_version = 'Uniswap v3' THEN NULL
ELSE a.total_usd - b.total_usd
END AS univ3_delta,
a.total_usd_by_pair *(1-a.share_of_pair_usd) AS uncaptured_volume, -- total volume for each pair not going through v3
a.trading_pair_map
FROM trade_stats a
INNER JOIN (SELECT * FROM trade_stats WHERE pair_rank = 1) b
ON a.trading_pair = b.trading_pair
WHERE a.project_version = 'Uniswap v3'
ORDER BY a.total_usd_by_pair DESC
*/"
53965,Uni v3 - UXCA - Time Period,,table,"WITH all_trades_raw AS
(
SELECT
block_time,
CASE WHEN '{{Time Period}}' IN ('24 hours','7 days') THEN DATE_TRUNC('hour',t.block_time)
ELSE DATE_TRUNC('hour',t.block_time)
END AS day_time,
CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version)
ELSE t.project
END AS proj_v,
---
-- Token Mapping --
---
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'

ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'

ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b,

t.exchange_contract_address -- exchange_contract_address is the LP Position
,SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t
/*The LP mint transaction has the fee rate as a parameter
1. Join on the LP (contract address) to get the mint transaction
2. Use the mint transaction to join to the Position Manager and get the fee rate
(I hope there's an easier way to do this eventually)
*/
WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr --only commenting out for this chart
AND t.block_time >= (DATE_TRUNC('hour',now()) - '{{Time Period}}'::INTERVAL)
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2,3,4,5,6
)
SELECT
TO_CHAR(MIN(a.block_time),'MM/dd/yy HH24:MI') AS min_time,
TO_CHAR(MAX(a.block_time),'MM/dd/yy HH24:MI') AS max_time
FROM all_trades_raw a"
51518,Uni v3 UXCA - DEX Share,,table,"WITH all_trades_raw AS
(
SELECT

DATE_TRUNC('day',t.block_time) AS day_time,
CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version)
ELSE t.project
END AS proj_v,
---
-- Token Mapping --
---
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,

CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b,

t.exchange_contract_address -- exchange_contract_address is the LP Position
,SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t
/*The LP mint transaction has the fee rate as a parameter
1. Join on the LP (contract address) to get the mint transaction
2. Use the mint transaction to join to the Position Manager and get the fee rate
(I hope there's an easier way to do this eventually)
*/
WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL)
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2,3,4,5
),
token_mapping AS(
SELECT t.token,
CASE
WHEN t.token IN ('WETH','ETH') THEN 'ETH'
WHEN t.token IN ('sETH','stETH','ankrETH','rETH','cETH') THEN 'ETH Token'
WHEN t.token IN ('sUSD','sEUR','sAUD') THEN 'Synth Stable'
WHEN (t.token LIKE '%USD%') OR (t.token IN ('DAI','cDAI', 'FEI','FRAX','UST')) THEN 'USD'
WHEN (t.token IN ('EURS')) THEN 'EUR'
WHEN t.token IN ('WBTC','renBTC','hBTC','sBTC','oBTC','pBTC','tBTC','bBTC','cWBTC','0xBTC') THEN 'BTC Token'
WHEN t.token = 'UNI' THEN 'UNI'
WHEN t.token IN ('SUSHI', 'BNT', 'BAL','ZRX','KNC','1INCH','xSUSHI','WOO') THEN 'DEX Token'
WHEN t.token IN ('MKR','COMP','AAVE','YFI','SNX','LINK','CRV','ALCX','RAI','TRIBE',
    'VISR','UMA','REN','CREAM','FARM','MTA','TRU','RGT','LQTY','CONV')
    Then 'DeFi Token'
WHEN t.token IN ('VERA','ENJ','MANA','SAND','WAXE','AUDIO','RFOX','WHALE',
    'RARI','DG','TVK','REV','MEME','MUSE','AXS', 'SLP')
    Then 'Metaverse Token'    
WHEN t.token IN ('CEL','NEXO','eRSDL','GERO') Then 'CeDeFi Token'
WHEN t.token IN ('DPI','MVI') Then 'Index Token'
WHEN t.token IN ('MATIC','LRC','CTSI','OMG','QUICK') Then 'L2-Sidechain'
WHEN t.token IN ('RUNE','LUNA','FTM','CARDS','KYL','SRM','PSWAP','OCC','GLCH','DFYN') Then 'Alt/Cross-Chain'
WHEN (t.token LIKE '%DOGE%') OR (t.token IN ('SHIB','LEASH','ELON','AKITA','SHIH','WOOFY','KISHU')) THEN 'Meme' --WOOFY is debatable, but I think #1 use case is meme
WHEN (t.token LIKE '%2x-FLI%') OR (t.token = 'ETH2x ADL') THEN 'Leverage Token'
WHEN t.token IN ('sYFI','sXTZ','sXRP','sXMR','sXAU','sXAG','sUNI',
                'sTRX','sRUNE','sLTC','sLINK','sETH','sETC','sEOS','sDOT','sDEFI'
                'sDASH','sCRV','sCOMP','sADA','sAAVE') THEN 'Synth Token'
WHEN t.token IN ('sOIL') THEN 'Synth Commodity'
WHEN t.token IN ('sTSLA','sNFLX','sMSFT','sGOOG','sFTSE','sFB','sCOIN','sAMZN','sAAPL') THEN 'Synth Stock'
WHEN t.token IN ('GTC') THEN 'Cause Token'
WHEN t.token IN ('Burn Addr') THEN 'Burn Addr'
ELSE 'Unmapped'
END AS token_map
FROM (
    SELECT DISTINCT token_a AS token FROM all_trades_raw
    UNION
    SELECT DISTINCT token_b AS token FROM all_trades_raw
    ) t
),

all_trades AS(
SELECT
day_time, proj_v,
token_a, token_b,
exchange_contract_address,
usd_traded,
--pair type mapping--
m1.token_map as token_a_map,
m2.token_map as token_b_map
FROM
all_trades_raw r

LEFT JOIN token_mapping m1
ON r.token_a = m1.token
LEFT JOIN token_mapping m2
ON r.token_b = m2.token
),

/*
most_recent_price AS
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute,
    contract_address,
    symbol,
    decimals,
    price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this
    ) last_price
WHERE last_price.recency_rank = 1 --To get the most recent price for liquidity joining
),*/
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd
FROM all_trades
GROUP BY 1,2,3,4
),
sum_pairs_map AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
--CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
--,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd_map
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS(
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd AS suma ,b.sum_usd AS sumb,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair
FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
final_trading_pairs_map AS(
SELECT
--a.forward_pair,
--a.backward_pair,
a.forward_pair_map, a.backward_pair_map,
a.sum_usd_map AS suma ,b.sum_usd_map AS sumb,
CASE
WHEN RIGHT(a.backward_pair_map,3)='ETH' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,3)='ETH' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='ETH Token' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,9)='ETH Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='BTC Token' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,9)='BTC Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='USD Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='USD Stable' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='EUR Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='EUR Stable' THEN a.backward_pair_map
WHEN (a.sum_usd_map >= b.sum_usd_map) -- when a > b
OR b.sum_usd_map IS NULL -- or if backward usd is null
THEN a.forward_pair_map -- select forward
ELSE a.backward_pair_map --else select backward in every other circumstance
END AS trading_pair_map
FROM sum_pairs_map a
LEFT JOIN sum_pairs_map b
ON a.forward_pair_map = b.backward_pair_map
),


v_trades AS (
SELECT
atx.day_time,
atx.proj_v AS project_version,
--atx.*,  f1.*, f2.*,
--f1.trading_pair,
--f2.trading_pair,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
COALESCE(f1m.trading_pair_map,f2m.trading_pair_map) AS trading_pair_map,
atx.usd_traded,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map,
SUM(atx.usd_traded) OVER(PARTITION BY proj_v) AS total_usd_by_dex,
--SUM(atx.usd_traded) OVER(PARTITION BY proj_v,COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair_dex,
--atx.fee_tier,
--atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
LEFT JOIN final_trading_pairs_map f1m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f1m.forward_pair_map
LEFT JOIN final_trading_pairs_map f2m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f2m.backward_pair_map
)
/*lp_withdraws AS(
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws
FROM (SELECT DISTINCT exchange_contract_address
FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_deposits AS(
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_tvl AS(
SELECT
net.lp_pos,
SUM(net.net_usd) AS tvl_usd
FROM (
    SELECT
    d.lp_pos,
    d.token,
    --d.project_version,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --how many tokens are in the LP
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) AS net_tokens_erc20, --tokens in the LP with appropriate decimals (only Dune logged erc20's)
    ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price AS net_usd --USD value of each token in the LP (Dune logged erc 20s only)
    FROM lp_deposits d
    INNER JOIN lp_withdraws w
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    --AND d.project_version = w.project_version
    LEFT JOIN most_recent_price p
    ON d.token = p.""contract_address""
    ) net
GROUP BY net.lp_pos
)*/
,trade_stats AS (
SELECT
--v.day_time,
v.trading_pair,
v.trading_pair_map,
v.project_version,
--,v.fee_tier
--,COUNT(v.trading_pair) AS num_trades
total_usd_by_pair,
total_usd_by_pair_map,
total_usd_by_dex,
SUM(v.usd_traded) AS total_usd,
SUM(v.usd_traded) / 
(CASE
WHEN total_usd_by_pair = 0 THEN 1 --handling for divide by zero errors that came up.
WHEN total_usd_by_pair IS NULL THEN 1
ELSE total_usd_by_pair
END) AS share_of_pair_usd,
RANK() OVER(PARTITION BY v.trading_pair ORDER BY SUM(v.usd_traded) DESC) AS pair_rank,
DENSE_RANK() OVER (ORDER BY total_usd_by_pair DESC) AS trade_pair_rank,
DENSE_RANK() OVER (ORDER BY total_usd_by_dex DESC) AS dex_rank,
DENSE_RANK() OVER (PARTITION BY v.project_version ORDER BY SUM(v.usd_traded) DESC) AS dex_rank_by_pair

--,SUM(v.fees_collected_usd) AS total_fees_usd
--,lp.tvl_usd AS total_value_locked
--,SUM(v.fees_collected_usd) / lp.tvl_usd AS fee_to_tvl_ratio
FROM v_trades v
--LEFT JOIN lp_tvl lp
--ON v.exchange_contract_address = lp.lp_pos
--AND v.project_version = lp.project_version
WHERE /*v.day_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '364 days'::INTERVAL)
AND*/ v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3,4,5,6--v.exchange_contract_address, v.trading_pair--, lp.tvl_usd, v.project_version--, v.fee_tier
--ORDER BY v.day_time, total_usd_by_pair DESC, SUM(v.usd_traded) DESC
--HAVING
--SUM(v.usd_traded) >100000 --Filter to remove outlier/small pairs
--AND lp.tvl_usd >1000 --remove more outliers / pairs with no prices
--ORDER BY SUM(v.fees_collected_usd) DESC
)
SELECT
trading_pair,
trading_pair_map,
CASE WHEN
project_version = 'Uniswap v3' THEN '*Uniswap v3*'
WHEN pair_rank <= 10 THEN project_version
ELSE 'Other'
END AS project_version,
total_usd_by_pair,
total_usd_by_pair_map,
--total_usd_by_dex,
trade_pair_rank,
--pair_rank,
SUM(total_usd) AS total_usd_map,
--SUM(total_usd)/total_usd_by_dex AS pct_of_dex,
SUM(total_usd)/total_usd_by_pair AS pct_of_pair
FROM trade_stats
WHERE
trade_pair_rank <= 15
GROUP BY 1,2,3,4,5,6

--HAVING SUM(total_usd)/total_usd_by_pair > .0005 --Greater than 0.5% rounded up

ORDER BY trade_pair_rank ASC
-- Left these label formats as '0,'' so that it's easier to see who's the leader.
--When things become b, m, k volume, it's harder (for me at least) to pick out
--who the leaders are"
52038,Uni v3 UXCA - Other DEX Share,,chart,"WITH all_trades_raw AS
(
SELECT

DATE_TRUNC('day',t.block_time) AS day_time,
CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version)
ELSE t.project
END AS proj_v,
---
-- Token Mapping --
---
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,

CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b,

t.exchange_contract_address -- exchange_contract_address is the LP Position
,SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t
/*The LP mint transaction has the fee rate as a parameter
1. Join on the LP (contract address) to get the mint transaction
2. Use the mint transaction to join to the Position Manager and get the fee rate
(I hope there's an easier way to do this eventually)
*/
WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL)
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2,3,4,5
),
token_mapping AS(
SELECT t.token,
CASE
WHEN t.token IN ('WETH','ETH') THEN 'ETH'
WHEN t.token IN ('sETH','stETH','ankrETH','rETH','cETH') THEN 'ETH Token'
WHEN t.token IN ('sUSD','sEUR','sAUD') THEN 'Synth Stable'
WHEN (t.token LIKE '%USD%') OR (t.token IN ('DAI','cDAI', 'FEI','FRAX','UST')) THEN 'USD'
WHEN (t.token IN ('EURS')) THEN 'EUR'
WHEN t.token IN ('WBTC','renBTC','hBTC','sBTC','oBTC','pBTC','tBTC','bBTC','cWBTC','0xBTC') THEN 'BTC Token'
WHEN t.token = 'UNI' THEN 'UNI'
WHEN t.token IN ('SUSHI', 'BNT', 'BAL','ZRX','KNC','1INCH','xSUSHI','WOO') THEN 'DEX Token'
WHEN t.token IN ('MKR','COMP','AAVE','YFI','SNX','LINK','CRV','ALCX','RAI','TRIBE',
    'VISR','UMA','REN','CREAM','FARM','MTA','TRU','RGT','LQTY','CONV')
    Then 'DeFi Token'
WHEN t.token IN ('VERA','ENJ','MANA','SAND','WAXE','AUDIO','RFOX','WHALE',
    'RARI','DG','TVK','REV','MEME','MUSE','AXS', 'SLP')
    Then 'Metaverse Token'    
WHEN t.token IN ('CEL','NEXO','eRSDL','GERO') Then 'CeDeFi Token'
WHEN t.token IN ('DPI','MVI') Then 'Index Token'
WHEN t.token IN ('MATIC','LRC','CTSI','OMG','QUICK') Then 'L2-Sidechain'
WHEN t.token IN ('RUNE','LUNA','FTM','CARDS','KYL','SRM','PSWAP','OCC','GLCH','DFYN') Then 'Alt/Cross-Chain'
WHEN (t.token LIKE '%DOGE%') OR (t.token IN ('SHIB','LEASH','ELON','AKITA','SHIH','WOOFY','KISHU')) THEN 'Meme' --WOOFY is debatable, but I think #1 use case is meme
WHEN (t.token LIKE '%2x-FLI%') OR (t.token = 'ETH2x ADL') THEN 'Leverage Token'
WHEN t.token IN ('sYFI','sXTZ','sXRP','sXMR','sXAU','sXAG','sUNI',
                'sTRX','sRUNE','sLTC','sLINK','sETH','sETC','sEOS','sDOT','sDEFI'
                'sDASH','sCRV','sCOMP','sADA','sAAVE') THEN 'Synth Token'
WHEN t.token IN ('sOIL') THEN 'Synth Commodity'
WHEN t.token IN ('sTSLA','sNFLX','sMSFT','sGOOG','sFTSE','sFB','sCOIN','sAMZN','sAAPL') THEN 'Synth Stock'
WHEN t.token IN ('GTC') THEN 'Cause Token'
WHEN t.token IN ('Burn Addr') THEN 'Burn Addr'
ELSE 'Unmapped'
END AS token_map
FROM (
    SELECT DISTINCT token_a AS token FROM all_trades_raw
    UNION
    SELECT DISTINCT token_b AS token FROM all_trades_raw
    ) t
),

all_trades AS(
SELECT
day_time, proj_v,
token_a, token_b,
exchange_contract_address,
usd_traded,
--pair type mapping--
m1.token_map as token_a_map,
m2.token_map as token_b_map
FROM
all_trades_raw r

LEFT JOIN token_mapping m1
ON r.token_a = m1.token
LEFT JOIN token_mapping m2
ON r.token_b = m2.token
),

/*
most_recent_price AS
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute,
    contract_address,
    symbol,
    decimals,
    price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this
    ) last_price
WHERE last_price.recency_rank = 1 --To get the most recent price for liquidity joining
),*/
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd
FROM all_trades
GROUP BY 1,2,3,4
),
sum_pairs_map AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
--CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
--,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd_map
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS(
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd AS suma ,b.sum_usd AS sumb,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair
FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
final_trading_pairs_map AS(
SELECT
--a.forward_pair,
--a.backward_pair,
a.forward_pair_map, a.backward_pair_map,
a.sum_usd_map AS suma ,b.sum_usd_map AS sumb,
CASE
WHEN RIGHT(a.backward_pair_map,3)='ETH' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,3)='ETH' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='ETH Token' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,9)='ETH Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='BTC Token' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,9)='BTC Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='USD Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='USD Stable' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='EUR Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='EUR Stable' THEN a.backward_pair_map
WHEN (a.sum_usd_map >= b.sum_usd_map) -- when a > b
OR b.sum_usd_map IS NULL -- or if backward usd is null
THEN a.forward_pair_map -- select forward
ELSE a.backward_pair_map --else select backward in every other circumstance
END AS trading_pair_map
FROM sum_pairs_map a
LEFT JOIN sum_pairs_map b
ON a.forward_pair_map = b.backward_pair_map
),


v_trades AS (
SELECT
atx.day_time,
atx.proj_v AS project_version,
--atx.*,  f1.*, f2.*,
--f1.trading_pair,
--f2.trading_pair,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
COALESCE(f1m.trading_pair_map,f2m.trading_pair_map) AS trading_pair_map,
atx.usd_traded,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map,
SUM(atx.usd_traded) OVER(PARTITION BY proj_v) AS total_usd_by_dex,
--atx.fee_tier,
--atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
LEFT JOIN final_trading_pairs_map f1m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f1m.forward_pair_map
LEFT JOIN final_trading_pairs_map f2m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f2m.backward_pair_map
)
/*lp_withdraws AS(
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws
FROM (SELECT DISTINCT exchange_contract_address
FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_deposits AS(
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_tvl AS(
SELECT
net.lp_pos,
SUM(net.net_usd) AS tvl_usd
FROM (
    SELECT
    d.lp_pos,
    d.token,
    --d.project_version,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --how many tokens are in the LP
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) AS net_tokens_erc20, --tokens in the LP with appropriate decimals (only Dune logged erc20's)
    ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price AS net_usd --USD value of each token in the LP (Dune logged erc 20s only)
    FROM lp_deposits d
    INNER JOIN lp_withdraws w
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    --AND d.project_version = w.project_version
    LEFT JOIN most_recent_price p
    ON d.token = p.""contract_address""
    ) net
GROUP BY net.lp_pos
)*/
,trade_stats AS (
SELECT
--v.day_time,
v.trading_pair,
v.trading_pair_map,
v.project_version,
--,v.fee_tier
--,COUNT(v.trading_pair) AS num_trades
total_usd_by_pair,
total_usd_by_pair_map,
total_usd_by_dex,
SUM(v.usd_traded) AS total_usd,
SUM(v.usd_traded) / 
(CASE
WHEN total_usd_by_pair = 0 THEN 1 --handling for divide by zero errors that came up.
WHEN total_usd_by_pair IS NULL THEN 1
ELSE total_usd_by_pair
END) AS share_of_pair_usd,
RANK() OVER(PARTITION BY v.trading_pair ORDER BY SUM(v.usd_traded) DESC) AS pair_rank,
DENSE_RANK() OVER (ORDER BY total_usd_by_pair DESC) AS trade_pair_rank

--,SUM(v.fees_collected_usd) AS total_fees_usd
--,lp.tvl_usd AS total_value_locked
--,SUM(v.fees_collected_usd) / lp.tvl_usd AS fee_to_tvl_ratio
FROM v_trades v
--LEFT JOIN lp_tvl lp
--ON v.exchange_contract_address = lp.lp_pos
--AND v.project_version = lp.project_version
WHERE /*v.day_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '364 days'::INTERVAL)
AND*/ v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3,4,5,6--v.exchange_contract_address, v.trading_pair--, lp.tvl_usd, v.project_version--, v.fee_tier
--ORDER BY v.day_time, total_usd_by_pair DESC, SUM(v.usd_traded) DESC
--HAVING
--SUM(v.usd_traded) >100000 --Filter to remove outlier/small pairs
--AND lp.tvl_usd >1000 --remove more outliers / pairs with no prices
--ORDER BY SUM(v.fees_collected_usd) DESC
)
SELECT
--trading_pair,
trading_pair_map,
CASE
WHEN project_version = 'Uniswap v3' THEN CONCAT('Uni V3 - ',trading_pair_map)
WHEN project_version = 'Uniswap v2' THEN CONCAT('Uni V2 - ',trading_pair_map)
WHEN project_version = 'Uniswap v1' THEN CONCAT('Uni V1 - ',trading_pair_map)
ELSE CONCAT(project_version,' - ', trading_pair_map)
END AS dex_trading_pair_map,
project_version,
--total_usd_by_pair,
--total_usd_by_pair_map,
--total_usd_by_dex,
--trade_pair_rank,
SUM(total_usd) AS total_usd_map--,
--SUM(total_usd)/total_usd_by_dex AS pct_of_dex,
--SUM(total_usd)/total_usd_by_pair AS pct_of_pair
FROM trade_stats
WHERE
project_version NOT LIKE '%Uniswap%'
--trade_pair_rank <= 25
GROUP BY 1,2,3--,4,5,6,7,8

--HAVING SUM(total_usd)/total_usd_by_pair > .0005 --Greater than 0.5% rounded up

--ORDER BY trade_pair_rank ASC"
52823,Uni v3 UXCA - Uni v2 Share,,table,"WITH all_trades_raw AS
(
SELECT

DATE_TRUNC('day',t.block_time) AS day_time,
CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version)
ELSE t.project
END AS proj_v,
---
-- Token Mapping --
---
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,

CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b,

t.exchange_contract_address -- exchange_contract_address is the LP Position
,SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t
/*The LP mint transaction has the fee rate as a parameter
1. Join on the LP (contract address) to get the mint transaction
2. Use the mint transaction to join to the Position Manager and get the fee rate
(I hope there's an easier way to do this eventually)
*/
WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL)
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2,3,4,5
),
token_mapping AS(
SELECT t.token,
CASE
WHEN t.token IN ('WETH','ETH') THEN 'ETH'
WHEN t.token IN ('sETH','stETH','ankrETH','rETH','cETH') THEN 'ETH Token'
WHEN t.token IN ('sUSD','sEUR','sAUD') THEN 'Synth Stable'
WHEN (t.token LIKE '%USD%') OR (t.token IN ('DAI','cDAI', 'FEI','FRAX','UST')) THEN 'USD'
WHEN (t.token IN ('EURS')) THEN 'EUR'
WHEN t.token IN ('WBTC','renBTC','hBTC','sBTC','oBTC','pBTC','tBTC','bBTC','cWBTC','0xBTC') THEN 'BTC Token'
WHEN t.token = 'UNI' THEN 'UNI'
WHEN t.token IN ('SUSHI', 'BNT', 'BAL','ZRX','KNC','1INCH','xSUSHI','WOO') THEN 'DEX Token'
WHEN t.token IN ('MKR','COMP','AAVE','YFI','SNX','LINK','CRV','ALCX','RAI','TRIBE',
    'VISR','UMA','REN','CREAM','FARM','MTA','TRU','RGT','LQTY','CONV')
    Then 'DeFi Token'
WHEN t.token IN ('VERA','ENJ','MANA','SAND','WAXE','AUDIO','RFOX','WHALE',
    'RARI','DG','TVK','REV','MEME','MUSE','AXS', 'SLP')
    Then 'Metaverse Token'    
WHEN t.token IN ('CEL','NEXO','eRSDL','GERO') Then 'CeDeFi Token'
WHEN t.token IN ('DPI','MVI') Then 'Index Token'
WHEN t.token IN ('MATIC','LRC','CTSI','OMG','QUICK') Then 'L2-Sidechain'
WHEN t.token IN ('RUNE','LUNA','FTM','CARDS','KYL','SRM','PSWAP','OCC','GLCH','DFYN') Then 'Alt/Cross-Chain'
WHEN (t.token LIKE '%DOGE%') OR (t.token IN ('SHIB','LEASH','ELON','AKITA','SHIH','WOOFY','KISHU')) THEN 'Meme' --WOOFY is debatable, but I think #1 use case is meme
WHEN (t.token LIKE '%2x-FLI%') OR (t.token = 'ETH2x ADL') THEN 'Leverage Token'
WHEN t.token IN ('sYFI','sXTZ','sXRP','sXMR','sXAU','sXAG','sUNI',
                'sTRX','sRUNE','sLTC','sLINK','sETH','sETC','sEOS','sDOT','sDEFI'
                'sDASH','sCRV','sCOMP','sADA','sAAVE') THEN 'Synth Token'
WHEN t.token IN ('sOIL') THEN 'Synth Commodity'
WHEN t.token IN ('sTSLA','sNFLX','sMSFT','sGOOG','sFTSE','sFB','sCOIN','sAMZN','sAAPL') THEN 'Synth Stock'
WHEN t.token IN ('GTC') THEN 'Cause Token'
WHEN t.token IN ('Burn Addr') THEN 'Burn Addr'
ELSE 'Unmapped'
END AS token_map
FROM (
    SELECT DISTINCT token_a AS token FROM all_trades_raw
    UNION
    SELECT DISTINCT token_b AS token FROM all_trades_raw
    ) t
),

all_trades AS(
SELECT
day_time, proj_v,
token_a, token_b,
exchange_contract_address,
usd_traded,
--pair type mapping--
m1.token_map as token_a_map,
m2.token_map as token_b_map
FROM
all_trades_raw r

LEFT JOIN token_mapping m1
ON r.token_a = m1.token
LEFT JOIN token_mapping m2
ON r.token_b = m2.token
),

/*
most_recent_price AS
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute,
    contract_address,
    symbol,
    decimals,
    price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this
    ) last_price
WHERE last_price.recency_rank = 1 --To get the most recent price for liquidity joining
),*/
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd
FROM all_trades
GROUP BY 1,2,3,4
),
sum_pairs_map AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
--CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
--,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd_map
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS(
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd AS suma ,b.sum_usd AS sumb,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair
FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
final_trading_pairs_map AS(
SELECT
--a.forward_pair,
--a.backward_pair,
a.forward_pair_map, a.backward_pair_map,
a.sum_usd_map AS suma ,b.sum_usd_map AS sumb,
CASE
WHEN RIGHT(a.backward_pair_map,3)='ETH' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,3)='ETH' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='ETH Token' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,9)='ETH Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='BTC Token' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,9)='BTC Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='USD Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='USD Stable' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='EUR Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='EUR Stable' THEN a.backward_pair_map
WHEN (a.sum_usd_map >= b.sum_usd_map) -- when a > b
OR b.sum_usd_map IS NULL -- or if backward usd is null
THEN a.forward_pair_map -- select forward
ELSE a.backward_pair_map --else select backward in every other circumstance
END AS trading_pair_map
FROM sum_pairs_map a
LEFT JOIN sum_pairs_map b
ON a.forward_pair_map = b.backward_pair_map
),


v_trades AS (
SELECT
atx.day_time,
atx.proj_v AS project_version,
--atx.*,  f1.*, f2.*,
--f1.trading_pair,
--f2.trading_pair,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
COALESCE(f1m.trading_pair_map,f2m.trading_pair_map) AS trading_pair_map,
atx.usd_traded,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map,
SUM(atx.usd_traded) OVER(PARTITION BY proj_v) AS total_usd_by_dex,
--atx.fee_tier,
--atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
LEFT JOIN final_trading_pairs_map f1m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f1m.forward_pair_map
LEFT JOIN final_trading_pairs_map f2m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f2m.backward_pair_map
)
/*lp_withdraws AS(
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws
FROM (SELECT DISTINCT exchange_contract_address
FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_deposits AS(
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_tvl AS(
SELECT
net.lp_pos,
SUM(net.net_usd) AS tvl_usd
FROM (
    SELECT
    d.lp_pos,
    d.token,
    --d.project_version,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --how many tokens are in the LP
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) AS net_tokens_erc20, --tokens in the LP with appropriate decimals (only Dune logged erc20's)
    ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price AS net_usd --USD value of each token in the LP (Dune logged erc 20s only)
    FROM lp_deposits d
    INNER JOIN lp_withdraws w
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    --AND d.project_version = w.project_version
    LEFT JOIN most_recent_price p
    ON d.token = p.""contract_address""
    ) net
GROUP BY net.lp_pos
)*/
,trade_stats AS (
SELECT
--v.day_time,
v.trading_pair,
v.trading_pair_map,
v.project_version,
--,v.fee_tier
--,COUNT(v.trading_pair) AS num_trades
total_usd_by_pair,
total_usd_by_pair_map,
total_usd_by_dex,
SUM(v.usd_traded) AS total_usd,
SUM(v.usd_traded) / 
(CASE
WHEN total_usd_by_pair = 0 THEN 1 --handling for divide by zero errors that came up.
WHEN total_usd_by_pair IS NULL THEN 1
ELSE total_usd_by_pair
END) AS share_of_pair_usd,
RANK() OVER(PARTITION BY v.trading_pair ORDER BY SUM(v.usd_traded) DESC) AS pair_rank,
DENSE_RANK() OVER (ORDER BY total_usd_by_pair DESC) AS trade_pair_rank

--,SUM(v.fees_collected_usd) AS total_fees_usd
--,lp.tvl_usd AS total_value_locked
--,SUM(v.fees_collected_usd) / lp.tvl_usd AS fee_to_tvl_ratio
FROM v_trades v
--LEFT JOIN lp_tvl lp
--ON v.exchange_contract_address = lp.lp_pos
--AND v.project_version = lp.project_version
WHERE /*v.day_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '364 days'::INTERVAL)
AND*/ v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3,4,5,6--v.exchange_contract_address, v.trading_pair--, lp.tvl_usd, v.project_version--, v.fee_tier
--ORDER BY v.day_time, total_usd_by_pair DESC, SUM(v.usd_traded) DESC
--HAVING
--SUM(v.usd_traded) >100000 --Filter to remove outlier/small pairs
--AND lp.tvl_usd >1000 --remove more outliers / pairs with no prices
--ORDER BY SUM(v.fees_collected_usd) DESC
)
SELECT
--trading_pair,
trading_pair_map,
CASE
WHEN project_version = 'Uniswap v3' THEN CONCAT('V3 ',trading_pair_map)
WHEN project_version = 'Uniswap v2' THEN CONCAT('V2 ',trading_pair_map)
WHEN project_version = 'Uniswap v1' THEN CONCAT('V1 ',trading_pair_map)
ELSE trading_pair_map
END AS uni_trading_pair_map,
project_version,
--total_usd_by_pair,
--total_usd_by_pair_map,
--total_usd_by_dex,
--trade_pair_rank,
SUM(total_usd) AS total_usd_map--,
--SUM(total_usd)/total_usd_by_dex AS pct_of_dex,
--SUM(total_usd)/total_usd_by_pair AS pct_of_pair
FROM trade_stats
WHERE
project_version LIKE '%Uniswap v2%'
--trade_pair_rank <= 25
GROUP BY 1,2,3--,4,5,6,7,8

--HAVING SUM(total_usd)/total_usd_by_pair > .0005 --Greater than 0.5% rounded up

--ORDER BY trade_pair_rank ASC"
48451,Uni v3 - UXCA - Distinct Pair Dominance,,table,"WITH all_trades_raw AS
(
SELECT

DATE_TRUNC('day',t.block_time) AS day_time,
CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version)
ELSE t.project
END AS proj_v,
---
-- Token Mapping --
---
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,

CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b,

t.exchange_contract_address,
CASE WHEN t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL) THEN 'current period'
ELSE 'previous period'
END AS period

-- exchange_contract_address is the LP Position
,SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t
/*The LP mint transaction has the fee rate as a parameter
1. Join on the LP (contract address) to get the mint transaction
2. Use the mint transaction to join to the Position Manager and get the fee rate
(I hope there's an easier way to do this eventually)
*/
WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL - '{{Time Period}}'::INTERVAL) --Minus Interval x2 so that we can measure PoP change
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2,3,4,5,6
),

token_mapping AS(
SELECT t.token,
CASE
WHEN t.token IN ('WETH','ETH') THEN 'ETH'
WHEN t.token IN ('sETH','stETH','ankrETH','rETH','cETH') THEN 'ETH Token'
WHEN t.token IN ('sUSD','sEUR','sAUD') THEN 'Synth Stable'
WHEN (t.token LIKE '%USD%') OR (t.token IN ('DAI','cDAI', 'FEI','FRAX','UST')) THEN 'USD'
WHEN (t.token IN ('EURS')) THEN 'EUR'
WHEN t.token IN ('WBTC','renBTC','hBTC','sBTC','oBTC','pBTC','tBTC','bBTC','cWBTC','0xBTC') THEN 'BTC Token'
WHEN t.token = 'UNI' THEN 'UNI'
WHEN t.token IN ('SUSHI', 'BNT', 'BAL','ZRX','KNC','1INCH','xSUSHI','WOO') THEN 'DEX Token'
WHEN t.token IN ('MKR','COMP','AAVE','YFI','SNX','LINK','CRV','ALCX','RAI','TRIBE',
    'VISR','UMA','REN','CREAM','FARM','MTA','TRU','RGT','LQTY','CONV')
    Then 'DeFi Token'
WHEN t.token IN ('VERA','ENJ','MANA','SAND','WAXE','AUDIO','RFOX','WHALE',
    'RARI','DG','TVK','REV','MEME','MUSE','AXS', 'SLP')
    Then 'Metaverse Token'    
WHEN t.token IN ('CEL','NEXO','eRSDL','GERO') Then 'CeDeFi Token'
WHEN t.token IN ('DPI','MVI') Then 'Index Token'
WHEN t.token IN ('MATIC','LRC','CTSI','OMG','QUICK') Then 'L2-Sidechain'
WHEN t.token IN ('RUNE','LUNA','FTM','CARDS','KYL','SRM','PSWAP','OCC','GLCH','DFYN') Then 'Alt/Cross-Chain'
WHEN (t.token LIKE '%DOGE%') OR (t.token IN ('SHIB','LEASH','ELON','AKITA','SHIH','WOOFY','KISHU')) THEN 'Meme' --WOOFY is debatable, but I think #1 use case is meme
WHEN (t.token LIKE '%2x-FLI%') OR (t.token = 'ETH2x ADL') THEN 'Leverage Token'
WHEN t.token IN ('sYFI','sXTZ','sXRP','sXMR','sXAU','sXAG','sUNI',
                'sTRX','sRUNE','sLTC','sLINK','sETH','sETC','sEOS','sDOT','sDEFI'
                'sDASH','sCRV','sCOMP','sADA','sAAVE') THEN 'Synth Token'
WHEN t.token IN ('sOIL') THEN 'Synth Commodity'
WHEN t.token IN ('sTSLA','sNFLX','sMSFT','sGOOG','sFTSE','sFB','sCOIN','sAMZN','sAAPL') THEN 'Synth Stock'
WHEN t.token IN ('GTC') THEN 'Cause Token'
WHEN t.token IN ('Burn Addr') THEN 'Burn Addr'
ELSE 'Unmapped'
END AS token_map
FROM (
    SELECT DISTINCT token_a AS token FROM all_trades_raw
    UNION
    SELECT DISTINCT token_b AS token FROM all_trades_raw
    ) t
),

all_trades AS(
SELECT
period,
day_time, proj_v,
token_a, token_b,
exchange_contract_address,
usd_traded,
--pair type mapping--
m1.token_map as token_a_map,
m2.token_map as token_b_map
FROM
all_trades_raw r

LEFT JOIN token_mapping m1
ON r.token_a = m1.token
LEFT JOIN token_mapping m2
ON r.token_b = m2.token
),
/*
most_recent_price AS
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute,
    contract_address,
    symbol,
    decimals,
    price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this
    ) last_price
WHERE last_price.recency_rank = 1 --To get the most recent price for liquidity joining
),*/
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd
FROM all_trades
GROUP BY 1,2,3,4
),
sum_pairs_map AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
--CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
--,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd_map
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS(
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd AS suma ,b.sum_usd AS sumb,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair
FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
final_trading_pairs_map AS(
SELECT
--a.forward_pair,
--a.backward_pair,
a.forward_pair_map, a.backward_pair_map,
a.sum_usd_map AS suma ,b.sum_usd_map AS sumb,
CASE
WHEN RIGHT(a.backward_pair_map,3)='ETH' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,3)='ETH' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='ETH Token' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,9)='ETH Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='BTC Token' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,9)='BTC Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='USD Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='USD Stable' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='EUR Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='EUR Stable' THEN a.backward_pair_map
WHEN (a.sum_usd_map >= b.sum_usd_map) -- when a > b
OR b.sum_usd_map IS NULL -- or if backward usd is null
THEN a.forward_pair_map -- select forward
ELSE a.backward_pair_map --else select backward in every other circumstance
END AS trading_pair_map
FROM sum_pairs_map a
LEFT JOIN sum_pairs_map b
ON a.forward_pair_map = b.backward_pair_map
),


v_trades AS (
SELECT
atx.day_time,
atx.proj_v AS project_version,
--atx.*,  f1.*, f2.*,
--f1.trading_pair,
--f2.trading_pair,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
COALESCE(f1m.trading_pair_map,f2m.trading_pair_map) AS trading_pair_map,
atx.usd_traded,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map,
SUM(atx.usd_traded) OVER(PARTITION BY proj_v) AS total_usd_by_dex,
--atx.fee_tier,
--atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
LEFT JOIN final_trading_pairs_map f1m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f1m.forward_pair_map
LEFT JOIN final_trading_pairs_map f2m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f2m.backward_pair_map

WHERE atx.period = 'current period'
),

v_trades_prev AS ( --for pop calc
SELECT
atx.day_time,
atx.proj_v AS project_version,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
COALESCE(f1m.trading_pair_map,f2m.trading_pair_map) AS trading_pair_map,
atx.usd_traded,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map,
SUM(atx.usd_traded) OVER(PARTITION BY proj_v) AS total_usd_by_dex,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
LEFT JOIN final_trading_pairs_map f1m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f1m.forward_pair_map
LEFT JOIN final_trading_pairs_map f2m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f2m.backward_pair_map

WHERE atx.period = 'previous period'
)


,trade_stats AS (
SELECT

v.trading_pair_map,
v.trading_pair,
v.project_version,

--total_usd_by_pair_map,
total_usd_by_pair,
SUM(v.usd_traded) AS total_usd,

--DENSE_RANK() OVER(ORDER BY total_usd_by_pair_map DESC) AS pair_map_rank,
--RANK() OVER(PARTITION BY v.trading_pair_map ORDER BY SUM(v.usd_traded) DESC) AS map_rank,
DENSE_RANK() OVER(ORDER BY total_usd_by_pair DESC) AS map_rank,
RANK() OVER(PARTITION BY v.trading_pair ORDER BY SUM(v.usd_traded) DESC) AS p_rank

FROM v_trades v

WHERE v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3, 4
)
,trade_stats_prev AS (
SELECT

v.trading_pair_map,
v.trading_pair,
v.project_version,

--total_usd_by_pair_map,
total_usd_by_pair,
SUM(v.usd_traded) AS total_usd,

--DENSE_RANK() OVER(ORDER BY total_usd_by_pair_map DESC) AS pair_map_rank,
--RANK() OVER(PARTITION BY v.trading_pair_map ORDER BY SUM(v.usd_traded) DESC) AS map_rank,
DENSE_RANK() OVER(ORDER BY total_usd_by_pair DESC) AS map_rank,
RANK() OVER(PARTITION BY v.trading_pair ORDER BY SUM(v.usd_traded) DESC) AS p_rank

FROM v_trades_prev v

WHERE v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3, 4
),
starting_stats AS(
SELECT DISTINCT
trading_pair_map,
trading_pair,
total_usd_by_pair
FROM
trade_stats
),
starting_stats_prev AS(
SELECT DISTINCT
trading_pair_map,
trading_pair,
total_usd_by_pair
FROM
trade_stats_prev
)
--SELECT * FROM trade_stats_prev
--WHERE trading_pair_map LIKE '%L2%'
--LIMIT 1000

--SELECT * FROM trade_stats
SELECT
RANK() OVER(ORDER BY a.total_usd_by_pair DESC) AS pair_rank,
a.trading_pair,
--a.project_version,
a.total_usd_by_pair,
---
CASE WHEN ap.total_usd_by_pair IS NULL THEN NULL
ELSE
(a.total_usd_by_pair - ap.total_usd_by_pair) /
NULLIF(ap.total_usd_by_pair,0) 
END AS total_usd_change,
--a.total_usd_by_dex,
--a.pair_map_rank,
COALESCE(au.total_usd,0) AS total_usd_v3,
COALESCE(au.total_usd/NULLIF(a.total_usd_by_pair,0),0) AS pct_of_v3,
---
CASE WHEN (au.total_usd_by_pair IS NULL) OR (aup.total_usd_by_pair IS NULL) THEN NULL
ELSE
((au.total_usd/NULLIF(au.total_usd_by_pair,0)) - (aup.total_usd/NULLIF(aup.total_usd_by_pair,0)))*100 
END AS v3_share_change,
---
CASE WHEN b.project_version = 'Uniswap v3' THEN '*Uniswap v3*'
ELSE b.project_version
END AS dom_dex,
---
CASE WHEN b.project_version = 'Uniswap v3' THEN NULL
ELSE b.total_usd
END AS total_usd_dom,
---
CASE WHEN b.project_version = 'Uniswap v3' THEN NULL
ELSE b.total_usd/NULLIF(b.total_usd_by_pair,0)
END AS pct_of_dom,

CASE WHEN b.project_version = 'Uniswap v3' THEN NULL
ELSE b.total_usd - au.total_usd
END AS uni_v3_defecit_usd,

CASE WHEN b.project_version = 'Uniswap v3' THEN NULL
ELSE (b.total_usd/NULLIF(b.total_usd_by_pair,0)) - (au.total_usd/NULLIF(au.total_usd_by_pair,0))
END AS uni_v3_defecit_pct,

a.trading_pair_map

FROM starting_stats a --all pairs, regardless of dex

LEFT JOIN (SELECT * FROM trade_stats WHERE project_version = 'Uniswap v3') au --uni v3 pairs
ON a.trading_pair = au.trading_pair
--AND a.project_version = au.project_version
LEFT JOIN (SELECT * FROM trade_stats_prev WHERE project_version = 'Uniswap v3') aup --uni v3 previous pairs
ON a.trading_pair = aup.trading_pair
--AND a.project_version = aup.project_version
LEFT JOIN starting_stats_prev ap --all prev pairs
ON a.trading_pair = ap.trading_pair
--AND a.project_version = ap.project_version
LEFT JOIN (SELECT * FROM trade_stats WHERE p_rank = 1) b --top pair
ON a.trading_pair = b.trading_pair
---
--WHERE au.project_version = 'Uniswap v3'
--AND aup.project_version = 'Uniswap v3'
/*WHERE
pair_map_rank <= 15*/
--GROUP BY
--a.trading_pair_map,
--a.total_usd_by_pair_map,
--b.project_version,
--b.total_usd_by_pair_map,b.total_usd

--HAVING SUM(total_usd)/total_usd_by_pair_map > .0045 --Greater than 0.5% rounded up

ORDER BY a.total_usd_by_pair DESC"
52008,Uni v3 UXCA - Uni v3 Share,,table,"WITH all_trades_raw AS
(
SELECT

DATE_TRUNC('day',t.block_time) AS day_time,
CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version)
ELSE t.project
END AS proj_v,
---
-- Token Mapping --
---
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,

CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b,

t.exchange_contract_address -- exchange_contract_address is the LP Position
,SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t
/*The LP mint transaction has the fee rate as a parameter
1. Join on the LP (contract address) to get the mint transaction
2. Use the mint transaction to join to the Position Manager and get the fee rate
(I hope there's an easier way to do this eventually)
*/
WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL)
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2,3,4,5
),
token_mapping AS(
SELECT t.token,
CASE
WHEN t.token IN ('WETH','ETH') THEN 'ETH'
WHEN t.token IN ('sETH','stETH','ankrETH','rETH','cETH') THEN 'ETH Token'
WHEN t.token IN ('sUSD','sEUR','sAUD') THEN 'Synth Stable'
WHEN (t.token LIKE '%USD%') OR (t.token IN ('DAI','cDAI', 'FEI','FRAX','UST')) THEN 'USD'
WHEN (t.token IN ('EURS')) THEN 'EUR'
WHEN t.token IN ('WBTC','renBTC','hBTC','sBTC','oBTC','pBTC','tBTC','bBTC','cWBTC','0xBTC') THEN 'BTC Token'
WHEN t.token = 'UNI' THEN 'UNI'
WHEN t.token IN ('SUSHI', 'BNT', 'BAL','ZRX','KNC','1INCH','xSUSHI','WOO') THEN 'DEX Token'
WHEN t.token IN ('MKR','COMP','AAVE','YFI','SNX','LINK','CRV','ALCX','RAI','TRIBE',
    'VISR','UMA','REN','CREAM','FARM','MTA','TRU','RGT','LQTY','CONV')
    Then 'DeFi Token'
WHEN t.token IN ('VERA','ENJ','MANA','SAND','WAXE','AUDIO','RFOX','WHALE',
    'RARI','DG','TVK','REV','MEME','MUSE','AXS', 'SLP')
    Then 'Metaverse Token'    
WHEN t.token IN ('CEL','NEXO','eRSDL','GERO') Then 'CeDeFi Token'
WHEN t.token IN ('DPI','MVI') Then 'Index Token'
WHEN t.token IN ('MATIC','LRC','CTSI','OMG','QUICK') Then 'L2-Sidechain'
WHEN t.token IN ('RUNE','LUNA','FTM','CARDS','KYL','SRM','PSWAP','OCC','GLCH','DFYN') Then 'Alt/Cross-Chain'
WHEN (t.token LIKE '%DOGE%') OR (t.token IN ('SHIB','LEASH','ELON','AKITA','SHIH','WOOFY','KISHU')) THEN 'Meme' --WOOFY is debatable, but I think #1 use case is meme
WHEN (t.token LIKE '%2x-FLI%') OR (t.token = 'ETH2x ADL') THEN 'Leverage Token'
WHEN t.token IN ('sYFI','sXTZ','sXRP','sXMR','sXAU','sXAG','sUNI',
                'sTRX','sRUNE','sLTC','sLINK','sETH','sETC','sEOS','sDOT','sDEFI'
                'sDASH','sCRV','sCOMP','sADA','sAAVE') THEN 'Synth Token'
WHEN t.token IN ('sOIL') THEN 'Synth Commodity'
WHEN t.token IN ('sTSLA','sNFLX','sMSFT','sGOOG','sFTSE','sFB','sCOIN','sAMZN','sAAPL') THEN 'Synth Stock'
WHEN t.token IN ('GTC') THEN 'Cause Token'
WHEN t.token IN ('Burn Addr') THEN 'Burn Addr'
ELSE 'Unmapped'
END AS token_map
FROM (
    SELECT DISTINCT token_a AS token FROM all_trades_raw
    UNION
    SELECT DISTINCT token_b AS token FROM all_trades_raw
    ) t
),

all_trades AS(
SELECT
day_time, proj_v,
token_a, token_b,
exchange_contract_address,
usd_traded,
--pair type mapping--
m1.token_map as token_a_map,
m2.token_map as token_b_map
FROM
all_trades_raw r

LEFT JOIN token_mapping m1
ON r.token_a = m1.token
LEFT JOIN token_mapping m2
ON r.token_b = m2.token
),

/*
most_recent_price AS
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute,
    contract_address,
    symbol,
    decimals,
    price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this
    ) last_price
WHERE last_price.recency_rank = 1 --To get the most recent price for liquidity joining
),*/
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd
FROM all_trades
GROUP BY 1,2,3,4
),
sum_pairs_map AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
--CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
--,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd_map
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS(
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd AS suma ,b.sum_usd AS sumb,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair
FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
final_trading_pairs_map AS(
SELECT
--a.forward_pair,
--a.backward_pair,
a.forward_pair_map, a.backward_pair_map,
a.sum_usd_map AS suma ,b.sum_usd_map AS sumb,
CASE
WHEN RIGHT(a.backward_pair_map,3)='ETH' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,3)='ETH' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='ETH Token' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,9)='ETH Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='BTC Token' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,9)='BTC Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='USD Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='USD Stable' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='EUR Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='EUR Stable' THEN a.backward_pair_map
WHEN (a.sum_usd_map >= b.sum_usd_map) -- when a > b
OR b.sum_usd_map IS NULL -- or if backward usd is null
THEN a.forward_pair_map -- select forward
ELSE a.backward_pair_map --else select backward in every other circumstance
END AS trading_pair_map
FROM sum_pairs_map a
LEFT JOIN sum_pairs_map b
ON a.forward_pair_map = b.backward_pair_map
),


v_trades AS (
SELECT
atx.day_time,
atx.proj_v AS project_version,
--atx.*,  f1.*, f2.*,
--f1.trading_pair,
--f2.trading_pair,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
COALESCE(f1m.trading_pair_map,f2m.trading_pair_map) AS trading_pair_map,
atx.usd_traded,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map,
SUM(atx.usd_traded) OVER(PARTITION BY proj_v) AS total_usd_by_dex,
--atx.fee_tier,
--atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
LEFT JOIN final_trading_pairs_map f1m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f1m.forward_pair_map
LEFT JOIN final_trading_pairs_map f2m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f2m.backward_pair_map
)
/*lp_withdraws AS(
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws
FROM (SELECT DISTINCT exchange_contract_address
FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_deposits AS(
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_tvl AS(
SELECT
net.lp_pos,
SUM(net.net_usd) AS tvl_usd
FROM (
    SELECT
    d.lp_pos,
    d.token,
    --d.project_version,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --how many tokens are in the LP
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) AS net_tokens_erc20, --tokens in the LP with appropriate decimals (only Dune logged erc20's)
    ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price AS net_usd --USD value of each token in the LP (Dune logged erc 20s only)
    FROM lp_deposits d
    INNER JOIN lp_withdraws w
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    --AND d.project_version = w.project_version
    LEFT JOIN most_recent_price p
    ON d.token = p.""contract_address""
    ) net
GROUP BY net.lp_pos
)*/
,trade_stats AS (
SELECT
--v.day_time,
v.trading_pair,
v.trading_pair_map,
v.project_version,
--,v.fee_tier
--,COUNT(v.trading_pair) AS num_trades
total_usd_by_pair,
total_usd_by_pair_map,
total_usd_by_dex,
SUM(v.usd_traded) AS total_usd,
SUM(v.usd_traded) / 
(CASE
WHEN total_usd_by_pair = 0 THEN 1 --handling for divide by zero errors that came up.
WHEN total_usd_by_pair IS NULL THEN 1
ELSE total_usd_by_pair
END) AS share_of_pair_usd,
RANK() OVER(PARTITION BY v.trading_pair ORDER BY SUM(v.usd_traded) DESC) AS pair_rank,
DENSE_RANK() OVER (ORDER BY total_usd_by_pair DESC) AS trade_pair_rank

--,SUM(v.fees_collected_usd) AS total_fees_usd
--,lp.tvl_usd AS total_value_locked
--,SUM(v.fees_collected_usd) / lp.tvl_usd AS fee_to_tvl_ratio
FROM v_trades v
--LEFT JOIN lp_tvl lp
--ON v.exchange_contract_address = lp.lp_pos
--AND v.project_version = lp.project_version
WHERE /*v.day_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '364 days'::INTERVAL)
AND*/ v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3,4,5,6--v.exchange_contract_address, v.trading_pair--, lp.tvl_usd, v.project_version--, v.fee_tier
--ORDER BY v.day_time, total_usd_by_pair DESC, SUM(v.usd_traded) DESC
--HAVING
--SUM(v.usd_traded) >100000 --Filter to remove outlier/small pairs
--AND lp.tvl_usd >1000 --remove more outliers / pairs with no prices
--ORDER BY SUM(v.fees_collected_usd) DESC
)
SELECT
--trading_pair,
trading_pair_map,
CASE
WHEN project_version = 'Uniswap v3' THEN CONCAT('V3 ',trading_pair_map)
WHEN project_version = 'Uniswap v2' THEN CONCAT('V2 ',trading_pair_map)
WHEN project_version = 'Uniswap v1' THEN CONCAT('V1 ',trading_pair_map)
ELSE trading_pair_map
END AS uni_trading_pair_map,
project_version,
--total_usd_by_pair,
--total_usd_by_pair_map,
--total_usd_by_dex,
--trade_pair_rank,
SUM(total_usd) AS total_usd_map--,
--SUM(total_usd)/total_usd_by_dex AS pct_of_dex,
--SUM(total_usd)/total_usd_by_pair AS pct_of_pair
FROM trade_stats
WHERE
project_version LIKE '%Uniswap v3%'
--trade_pair_rank <= 25
GROUP BY 1,2,3--,4,5,6,7,8

--HAVING SUM(total_usd)/total_usd_by_pair > .0005 --Greater than 0.5% rounded up

--ORDER BY trade_pair_rank ASC"
51491,Uni v3 - UXCA - Volume Share (Uni v2 wins),,table,"WITH all_trades_raw AS
(
SELECT

DATE_TRUNC('day',t.block_time) AS day_time,
CASE WHEN t.version != '1' THEN CONCAT (t.project, ' v',t.version)
ELSE t.project
END AS proj_v,
---
-- Token Mapping --
---
CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_a_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_a_symbol,t.token_a_address::text)
END AS token_a,

CASE --filling in missing addresses for coins. Maybe not worth keeping up, some are memes.
WHEN t.token_b_symbol::text = 'WETH' THEN 'ETH'
WHEN t.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN t.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN t.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN t.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x6c28aef8977c9b773996d0e8376d2ee379446f2f' THEN 'QUICK'
WHEN t.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN t.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN t.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN t.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN t.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN t.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN t.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN t.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN t.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN t.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN t.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN t.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN t.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN t.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN t.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN t.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN t.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN t.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN t.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN t.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN t.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN t.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN t.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN t.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN t.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN t.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN t.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN t.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN t.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN t.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN t.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN t.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN t.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN t.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN t.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN t.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN t.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
ELSE COALESCE(t.token_b_symbol,t.token_b_address::text)
END AS token_b,

t.exchange_contract_address -- exchange_contract_address is the LP Position
,SUM(t.usd_amount) AS usd_traded --TODO: Find some way to pull in USD of any missing tokens
FROM dex.""trades"" t
/*The LP mint transaction has the fee rate as a parameter
1. Join on the LP (contract address) to get the mint transaction
2. Use the mint transaction to join to the Position Manager and get the fee rate
(I hope there's an easier way to do this eventually)
*/
WHERE
--t.project = 'Uniswap'
--AND t.version = '3' AND
t.block_time >= '05-05-2021 17:00' -- Uni v3 launch date/hr
AND t.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '{{Time Period}}'::INTERVAL)
AND t.usd_amount IS NOT NULL -- For these, Dune's table didn't have any entries. 
AND t.category = 'DEX' -- Remove aggregators who route to DEXs (e.g., Matcha -> SushiSwap, we only want the SushiSwap Part)
GROUP BY 1,2,3,4,5
),
token_mapping AS(
SELECT t.token,
CASE
WHEN t.token IN ('WETH','ETH') THEN 'ETH'
WHEN t.token IN ('sETH','stETH','ankrETH','rETH','cETH') THEN 'ETH Token'
WHEN t.token IN ('sUSD','sEUR','sAUD') THEN 'Synth Stable'
WHEN (t.token LIKE '%USD%') OR (t.token IN ('DAI','cDAI', 'FEI','FRAX','UST')) THEN 'USD'
WHEN (t.token IN ('EURS')) THEN 'EUR'
WHEN t.token IN ('WBTC','renBTC','hBTC','sBTC','oBTC','pBTC','tBTC','bBTC','cWBTC','0xBTC') THEN 'BTC Token'
WHEN t.token = 'UNI' THEN 'UNI'
WHEN t.token IN ('SUSHI', 'BNT', 'BAL','ZRX','KNC','1INCH','xSUSHI','WOO') THEN 'DEX Token'
WHEN t.token IN ('MKR','COMP','AAVE','YFI','SNX','LINK','CRV','ALCX','RAI','TRIBE',
    'VISR','UMA','REN','CREAM','FARM','MTA','TRU','RGT','LQTY','CONV')
    Then 'DeFi Token'
WHEN t.token IN ('VERA','ENJ','MANA','SAND','WAXE','AUDIO','RFOX','WHALE',
    'RARI','DG','TVK','REV','MEME','MUSE','AXS', 'SLP')
    Then 'Metaverse Token'    
WHEN t.token IN ('CEL','NEXO','eRSDL','GERO') Then 'CeDeFi Token'
WHEN t.token IN ('DPI','MVI') Then 'Index Token'
WHEN t.token IN ('MATIC','LRC','CTSI','OMG','QUICK') Then 'L2-Sidechain'
WHEN t.token IN ('RUNE','LUNA','FTM','CARDS','KYL','SRM','PSWAP','OCC','GLCH','DFYN') Then 'Alt/Cross-Chain'
WHEN (t.token LIKE '%DOGE%') OR (t.token IN ('SHIB','LEASH','ELON','AKITA','SHIH','WOOFY','KISHU')) THEN 'Meme' --WOOFY is debatable, but I think #1 use case is meme
WHEN (t.token LIKE '%2x-FLI%') OR (t.token = 'ETH2x ADL') THEN 'Leverage Token'
WHEN t.token IN ('sYFI','sXTZ','sXRP','sXMR','sXAU','sXAG','sUNI',
                'sTRX','sRUNE','sLTC','sLINK','sETH','sETC','sEOS','sDOT','sDEFI'
                'sDASH','sCRV','sCOMP','sADA','sAAVE') THEN 'Synth Token'
WHEN t.token IN ('sOIL') THEN 'Synth Commodity'
WHEN t.token IN ('sTSLA','sNFLX','sMSFT','sGOOG','sFTSE','sFB','sCOIN','sAMZN','sAAPL') THEN 'Synth Stock'
WHEN t.token IN ('GTC') THEN 'Cause Token'
WHEN t.token IN ('Burn Addr') THEN 'Burn Addr'
ELSE 'Unmapped'
END AS token_map
FROM (
    SELECT DISTINCT token_a AS token FROM all_trades_raw
    UNION
    SELECT DISTINCT token_b AS token FROM all_trades_raw
    ) t
),

all_trades AS(
SELECT
day_time, proj_v,
token_a, token_b,
exchange_contract_address,
usd_traded,
--pair type mapping--
m1.token_map as token_a_map,
m2.token_map as token_b_map
FROM
all_trades_raw r

LEFT JOIN token_mapping m1
ON r.token_a = m1.token
LEFT JOIN token_mapping m2
ON r.token_b = m2.token
),

/*
most_recent_price AS
(
SELECT last_price.contract_address, last_price.symbol, last_price.decimals, last_price.price, last_price.minute
 FROM (
    SELECT
    minute,
    contract_address,
    symbol,
    decimals,
    price,
    RANK() OVER(PARTITION BY contract_address ORDER BY minute DESC) AS recency_rank
    FROM prices.usd
    WHERE minute > (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '1 days'::INTERVAL) -- to help tighten this
    ) last_price
WHERE last_price.recency_rank = 1 --To get the most recent price for liquidity joining
),*/
sum_pairs AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
,CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd
FROM all_trades
GROUP BY 1,2,3,4
),
sum_pairs_map AS( -- Using this to decide which trading pair order to pick (i.e WBTC/USDC vs USDC/WBTC). We'll pick the one with the greatest usd volume.
--starting set
SELECT 
--CONCAT(token_a,'/',token_b) AS forward_pair -- Trading pair
--,CONCAT(token_b,'/',token_a) AS backward_pair -- For joining buys/sells later
CONCAT(token_a_map,'/',token_b_map) AS forward_pair_map -- Trading pair
,CONCAT(token_b_map,'/',token_a_map) AS backward_pair_map -- For joining buys/sells later
,SUM(usd_traded) AS sum_usd_map
FROM all_trades
GROUP BY 1,2
),

final_trading_pairs AS(
SELECT
a.forward_pair, a.backward_pair,
a.sum_usd AS suma ,b.sum_usd AS sumb,
CASE
WHEN RIGHT(a.backward_pair,3)='ETH' THEN a.forward_pair -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair,3)='ETH' THEN a.backward_pair
WHEN RIGHT(a.backward_pair,4)='WBTC' THEN a.forward_pair
WHEN RIGHT(a.forward_pair,4)='WBTC' THEN a.backward_pair
WHEN (a.sum_usd >= b.sum_usd) -- when a > b
OR b.sum_usd IS NULL -- or if backward usd is null
THEN a.forward_pair -- select forward
ELSE a.backward_pair --else select backward in every other circumstance
END AS trading_pair
FROM sum_pairs a
LEFT JOIN sum_pairs b
ON a.forward_pair = b.backward_pair
),
final_trading_pairs_map AS(
SELECT
--a.forward_pair,
--a.backward_pair,
a.forward_pair_map, a.backward_pair_map,
a.sum_usd_map AS suma ,b.sum_usd_map AS sumb,
CASE
WHEN RIGHT(a.backward_pair_map,3)='ETH' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,3)='ETH' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='ETH Token' THEN a.forward_pair_map -- if the backward version ends in WETH, do forward
WHEN RIGHT(a.forward_pair_map,9)='ETH Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,9)='BTC Token' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,9)='BTC Token' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='USD Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='USD Stable' THEN a.backward_pair_map
WHEN RIGHT(a.backward_pair_map,10)='EUR Stable' THEN a.forward_pair_map
WHEN RIGHT(a.forward_pair_map,10)='EUR Stable' THEN a.backward_pair_map
WHEN (a.sum_usd_map >= b.sum_usd_map) -- when a > b
OR b.sum_usd_map IS NULL -- or if backward usd is null
THEN a.forward_pair_map -- select forward
ELSE a.backward_pair_map --else select backward in every other circumstance
END AS trading_pair_map
FROM sum_pairs_map a
LEFT JOIN sum_pairs_map b
ON a.forward_pair_map = b.backward_pair_map
),


v_trades AS (
SELECT
atx.day_time,
atx.proj_v AS project_version,
--atx.*,  f1.*, f2.*,
--f1.trading_pair,
--f2.trading_pair,
COALESCE(f1.trading_pair,f2.trading_pair) AS trading_pair,
COALESCE(f1m.trading_pair_map,f2m.trading_pair_map) AS trading_pair_map,
atx.usd_traded,
SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1.trading_pair,f2.trading_pair)) AS total_usd_by_pair,
--SUM(atx.usd_traded) OVER(PARTITION BY COALESCE(f1m.trading_pair_map,f2m.trading_pair_map)) AS total_usd_by_pair_map,
--atx.fee_tier,
--atx.fees_collected_usd,
atx.exchange_contract_address
FROM all_trades atx

LEFT JOIN final_trading_pairs f1
ON CONCAT(atx.token_a,'/',atx.token_b) = f1.forward_pair
LEFT JOIN final_trading_pairs f2
ON CONCAT(atx.token_a,'/',atx.token_b) = f2.backward_pair
LEFT JOIN final_trading_pairs_map f1m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f1m.forward_pair_map
LEFT JOIN final_trading_pairs_map f2m
ON CONCAT(atx.token_a_map,'/',atx.token_b_map) = f2m.backward_pair_map
)
/*lp_withdraws AS(
SELECT
a.exchange_contract_address AS lp_pos,
w.contract_address AS token,
SUM(w.value) AS token_withdraws
FROM (SELECT DISTINCT exchange_contract_address
FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" w
ON a.exchange_contract_address = w.""from""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_deposits AS(
SELECT
a.exchange_contract_address AS lp_pos,
d.contract_address AS token,
SUM(d.value) AS token_deposits
FROM (SELECT DISTINCT exchange_contract_address FROM all_trades) a
LEFT JOIN erc20.""ERC20_evt_Transfer"" d
ON a.exchange_contract_address = d.""to""
GROUP BY 1,2
--ORDER BY 1 DESC
),

lp_tvl AS(
SELECT
net.lp_pos,
SUM(net.net_usd) AS tvl_usd
FROM (
    SELECT
    d.lp_pos,
    d.token,
    --d.project_version,
    d.token_deposits - COALESCE(w.token_withdraws,0) AS net_tokens, --how many tokens are in the LP
    (d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals) AS net_tokens_erc20, --tokens in the LP with appropriate decimals (only Dune logged erc20's)
    ((d.token_deposits - COALESCE(w.token_withdraws,0)) / (10^p.decimals)) * p.price AS net_usd --USD value of each token in the LP (Dune logged erc 20s only)
    FROM lp_deposits d
    INNER JOIN lp_withdraws w
    ON d.lp_pos = w.lp_pos
    AND d.token = w.token
    --AND d.project_version = w.project_version
    LEFT JOIN most_recent_price p
    ON d.token = p.""contract_address""
    ) net
GROUP BY net.lp_pos
)*/
,trade_stats AS (
SELECT
--v.day_time,
v.trading_pair,
v.trading_pair_map,
v.project_version,
--,v.fee_tier
--,COUNT(v.trading_pair) AS num_trades
total_usd_by_pair,
SUM(v.usd_traded) AS total_usd,
SUM(v.usd_traded) / 
(CASE
WHEN total_usd_by_pair = 0 THEN 1 --handling for divide by zero errors that came up.
WHEN total_usd_by_pair IS NULL THEN 1
ELSE total_usd_by_pair
END) AS share_of_pair_usd,
RANK() OVER(PARTITION BY v.trading_pair ORDER BY SUM(v.usd_traded) DESC) AS pair_rank

--,SUM(v.fees_collected_usd) AS total_fees_usd
--,lp.tvl_usd AS total_value_locked
--,SUM(v.fees_collected_usd) / lp.tvl_usd AS fee_to_tvl_ratio
FROM v_trades v
--LEFT JOIN lp_tvl lp
--ON v.exchange_contract_address = lp.lp_pos
--AND v.project_version = lp.project_version
WHERE /*v.day_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '364 days'::INTERVAL)
AND*/ v.usd_traded IS NOT NULL -- Eventually see if Dune adds new tokens, or we need to manually
GROUP BY 1, 2,3,4--v.exchange_contract_address, v.trading_pair--, lp.tvl_usd, v.project_version--, v.fee_tier
--ORDER BY v.day_time, total_usd_by_pair DESC, SUM(v.usd_traded) DESC
--HAVING
--SUM(v.usd_traded) >100000 --Filter to remove outlier/small pairs
--AND lp.tvl_usd >1000 --remove more outliers / pairs with no prices
--ORDER BY SUM(v.fees_collected_usd) DESC
),
starting_stats AS(
SELECT DISTINCT
trading_pair,
trading_pair_map,
total_usd_by_pair
FROM
trade_stats
)
SELECT
a.trading_pair, a.total_usd_by_pair, --a.total_usd AS univ3_usd, a.share_of_pair_usd AS univ3_dominance,
/*b.project_version AS dominant_dex,*/ b.total_usd AS best_usd, b.share_of_pair_usd AS best_pair_dominance,

CASE WHEN au.total_usd IS NULL THEN 0
ELSE au.total_usd
END AS univ3_usd,
CASE WHEN au.share_of_pair_usd IS NULL THEN 0
ELSE au.share_of_pair_usd
END AS univ3_dominance

,CASE WHEN b.project_version = 'Uniswap v3' THEN NULL
ELSE
(CASE WHEN au.total_usd IS NULL THEN 0
ELSE au.total_usd
END) - b.total_usd
END AS univ3_delta

,a.total_usd_by_pair *(1-
(CASE WHEN au.share_of_pair_usd IS NULL THEN 0
ELSE au.share_of_pair_usd
END)
) AS uncaptured_volume -- total volume for each pair not going through v3



,a.trading_pair_map

FROM starting_stats a
LEFT JOIN (SELECT * FROM trade_stats WHERE project_version = 'Uniswap v3') au --uni v3 pairs
ON a.trading_pair = au.trading_pair
INNER JOIN (SELECT * FROM trade_stats WHERE pair_rank = 1) b
ON a.trading_pair = b.trading_pair
WHERE b.project_version = 'Uniswap v2' --To pull Univ3 Wins
ORDER BY a.total_usd_by_pair DESC
"
43147,Uniswap V2 vs V3 Ramp Up,,table,"WITH alltrades AS (SELECT d.block_time, d.project, d.version,""tx_hash"",
/*COALESCE(d.token_a_symbol,d.token_a_address::text) AS token_received,
d.token_a_amount AS quantity_received,
COALESCE(d.token_b_symbol,d.token_b_address::text) AS token_sent, */
d.token_b_amount AS quantity_sent,
d.usd_amount
FROM dex.trades d
WHERE
d.project = 'Uniswap'
AND d.version IN ('1','2', '3')
AND d.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '{{Trailing Number of Days}} days'::INTERVAL)
AND d.block_time >= '05-05-2021 17:00'
--AND d.token_a_amount IS NOT NULL
--AND d.token_b_amount IS NOT NULL
)

SELECT
date_trunc('hour',a.block_time) AS date_hour,
CASE
WHEN version = '1' THEN 'Uni v1'
WHEN version = '2' THEN 'Uni v2'
WHEN version = '3' THEN 'Uni v3'
ELSE 'n/a'
END AS version,
--token_received,
--token_sent,
COUNT(DISTINCT tx_hash) AS num_trades,
SUM(a.usd_amount) AS total_usd
FROM alltrades a
GROUP BY 1,2
ORDER BY 1 DESC, 2 DESC
--,3,4"
44204,Uniswap V2 V3 Trading Pair Dominance (All Pairs),,table,"WITH alltrades AS (SELECT d.block_time, d.project, d.version,tx_hash,
CASE
WHEN d.token_a_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN d.token_a_address::text = '\xcc8fa225d80b9c7d42f96e9570156c65d6caaa25' THEN 'SLP'
WHEN d.token_a_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN d.token_a_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN d.token_a_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN d.token_a_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN d.token_a_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN d.token_a_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN d.token_a_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN d.token_a_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN d.token_a_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN d.token_a_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN d.token_a_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN d.token_a_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN d.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN d.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN d.token_a_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN d.token_a_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN d.token_a_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN d.token_a_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN d.token_a_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN d.token_a_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN d.token_a_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN d.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN d.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN d.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN d.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN d.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN d.token_a_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN d.token_a_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN d.token_a_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN d.token_a_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN d.token_a_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN d.token_a_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN d.token_a_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN d.token_a_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN d.token_a_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN d.token_a_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN d.token_a_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN d.token_a_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN d.token_a_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN d.token_a_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
WHEN d.token_a_address::text = 'xb5fe099475d3030dde498c3bb6f3854f762a48ad' THEN 'FNK'

ELSE COALESCE(d.token_a_symbol, d.token_a_address::text)
--CONCAT(LEFT(d.token_a_address::text,3),'...',RIGHT(d.token_a_address::text,3))
--)
END AS token_received,
d.token_a_amount AS quantity_received,
CASE
WHEN d.token_b_address::text = '\x0000000000000000000000000000000000000000' THEN 'Burn Addr'
WHEN d.token_b_address::text = '\xcc8fa225d80b9c7d42f96e9570156c65d6caaa25' THEN 'SLP'
WHEN d.token_b_address::text = '\xde30da39c46104798bb5aa3fe8b9e0e1f348163f' THEN 'GTC'
WHEN d.token_b_address::text = '\xa47c8bf37f92abed4a126bda807a7b7498661acd' THEN 'UST'
WHEN d.token_b_address::text = '\x6c28AeF8977c9B773996d0e8376d2EE379446F2f' THEN 'QUICK'
WHEN d.token_b_address::text = '\x519c1001d550c0a1dae7d1fc220f7d14c2a521bb' THEN 'PSWAP'
WHEN d.token_b_address::text = '\xf411903cbc70a74d22900a5de66a2dda66507255' THEN 'VERA'
WHEN d.token_b_address::text = '\x2f109021afe75b949429fe30523ee7c0d5b27207' THEN 'OCC'
WHEN d.token_b_address::text = '\xc834fa996fa3bec7aad3693af486ae53d8aa8b50' THEN 'CONV'
WHEN d.token_b_address::text = '\x4691937a7508860f876c9c0a2a617e7d9e945d4b' THEN 'WOO'
WHEN d.token_b_address::text = '\x9695e0114e12c0d3a3636fab5a18e6b737529023' THEN 'DFYN'
WHEN d.token_b_address::text = '\x3431f91b3a388115f00c5ba9fdb899851d005fb5' THEN 'GERO'
WHEN d.token_b_address::text = '\x038a68ff68c393373ec894015816e33ad41bd564' THEN 'GLCH'
WHEN d.token_b_address::text = '\xa2b4c0af19cc16a6cfacce81f192b024d625817d' THEN 'KISHU'
WHEN d.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN d.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN d.token_b_address::text = '\x3301ee63fb29f863f2333bd4466acb46cd8323e6' THEN 'AKITA'
WHEN d.token_b_address::text = '\x5218e472cfcfe0b64a064f055b43b4cdc9efd3a6' THEN 'eRSDL'
WHEN d.token_b_address::text = '\x1453dbb8a29551ade11d89825ca812e05317eaeb' THEN 'TEND'
WHEN d.token_b_address::text = '\x35a532d376ffd9a705d0bb319532837337a398e7' THEN 'WDOGE'
WHEN d.token_b_address::text = '\x17ef75aa22dd5f6c2763b8304ab24f40ee54d48a' THEN 'RVP'
WHEN d.token_b_address::text = '\x6dea81c8171d0ba574754ef6f8b412f2ed88c54d' THEN 'LQTY'
WHEN d.token_b_address::text = '\x3832d2f059e55934220881f831be501d180671a7' THEN 'renDOGE'
WHEN d.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN d.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN d.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN d.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN d.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
WHEN d.token_b_address::text = '\x27c70cd1946795b66be9d954418546998b546634' THEN 'LEASH'
WHEN d.token_b_address::text = '\x956f47f50a910163d8bf957cf5846d573e7f87ca' THEN 'FEI'
WHEN d.token_b_address::text = '\x5f98805a4e8be255a32880fdec7f6728c6568ba0' THEN 'LUSD'
WHEN d.token_b_address::text = '\xb525ecee288b99216cd481c56b6efbdbe9bf90b5' THEN 'KUMA'
WHEN d.token_b_address::text = '\xd291e7a03283640fdc51b121ac401383a46cc623' THEN 'RGT'
WHEN d.token_b_address::text = '\x3d6f0dea3ac3c607b3998e6ce14b6350721752d9' THEN 'CARDS'
WHEN d.token_b_address::text = '\x841fb148863454a3b3570f515414759be9091465' THEN 'SHIH'
WHEN d.token_b_address::text = '\xd0660cd418a64a1d44e9214ad8e459324d8157f1' THEN 'WOOFY'
WHEN d.token_b_address::text = '\x853d955acef822db058eb8505911ed77f175b99e' THEN 'FRAX'
WHEN d.token_b_address::text = '\x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb' THEN 'sETH'
WHEN d.token_b_address::text = '\xae7ab96520de3a18e5e111b5eaab095312d7fe84' THEN 'stETH'
WHEN d.token_b_address::text = '\xe95a203b1a91a908f9b9ce46459d101078c2c3cb' THEN 'ankrETH'
WHEN d.token_b_address::text = '\x9559aaa82d9649c7a7b220e7c461d2e74c9a3593' THEN 'rETH'
WHEN d.token_b_address::text = '\x4ddc2d193948926d02f9b1fe9e1daa0718270ed5' THEN 'cETH'
WHEN d.token_b_address::text = 'xb5fe099475d3030dde498c3bb6f3854f762a48ad' THEN 'FNK'

ELSE COALESCE(d.token_b_symbol,d.token_b_address::text)
--CONCAT(LEFT(d.token_b_address::text,3),'...',RIGHT(d.token_b_address::text,3))
--)
END AS token_sent,
d.token_b_amount AS quantity_sent,
d.usd_amount
FROM dex.trades d
WHERE
d.project = 'Uniswap'
AND d.version IN ('2', '3')
--AND d.version = '3'
AND d.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '{{Trailing Number of Days}} days'::INTERVAL)
AND d.block_time >= '05-05-2021 17:00'
--AND d.token_a_amount IS NOT NULL
--AND d.token_b_amount IS NOT NULL
),

all_pairs AS
(
SELECT
--date_trunc('hour',a.block_time) AS date_hour, --I'll leave this out for now, becuase I don't have a thesis on pool change over time, rather just what's most often being used.
CASE
WHEN version = '1' THEN 'Uni v1'
WHEN version = '2' THEN 'Uni v2'
WHEN version = '3' THEN 'Uni v3'
ELSE 'n/a'
END AS version,
token_received,
token_sent,
CONCAT(token_received, '/', token_sent) AS trading_pair,
CONCAT(token_sent, '/', token_received) AS flipped_pair, -- for joining
COUNT(DISTINCT tx_hash) AS num_trades,
SUM(quantity_received) AS total_quantity_received,
SUM(quantity_sent) AS total_quantity_sent,
SUM(a.usd_amount) AS total_usd
FROM alltrades a
GROUP BY 1, 2, 3, 4, 5
HAVING /*SUM(quantity_received) IS NOT NULL
AND SUM(quantity_sent) IS NOT NULL
AND*/ SUM(a.usd_amount) IS NOT NULL
ORDER BY 1 DESC, /*2 DESC,*/ 9 DESC
),
--SELECT * FROM all_pairs
unified_pairs AS (
--Here I'm trying to unify the buy/sell pairs (i.e. combine WETH/USDC and USDC/WETH)
-- Idea is to join the table to a flipped version of the trading pair, create a ""buy count"" , ""sell count"" , ""total count""
SELECT DISTINCT
buy.version,
buy.trading_pair,
sell.flipped_pair,
CASE WHEN (buy.total_usd >= sell.total_usd) OR (sell.total_usd IS NULL) THEN buy.trading_pair --if buy> sell give me buy
ELSE sell.trading_pair --else if sell>buy, give me sell
END AS val_trading_pair, --which direction had the highest volume? pick that one.
CASE WHEN (buy.total_usd < sell.total_usd) THEN buy.trading_pair --give me the opposite of what I want
ELSE buy.flipped_pair --probably could've mad this simpler by copying val_trading_pair and flipping the thens... oh well this works
END AS val_flipped_pair,
buy.num_trades AS num_buys,
sell.num_trades AS num_sells,
buy.total_usd AS total_usd_buys,
sell.total_usd AS total_usd_sells,
buy.num_trades + COALESCE(sell.num_trades,0) AS overall_numberof_trades,
buy.total_usd + COALESCE(sell.total_usd,0) AS overall_total_usd
FROM all_pairs buy
LEFT JOIN all_pairs sell
ON buy.trading_pair = sell.flipped_pair
AND buy.version = sell.version
)
, version3 AS (
SELECT
--version,
--RANK() OVER (ORDER BY overall_total_usd DESC) AS pair_rank,
CASE WHEN RIGHT(val_trading_pair,4) = 'WETH' THEN val_flipped_pair -- if pair ends in WETH, flip it.
ELSE val_trading_pair
END AS trading_pair,
val_flipped_pair,
/*num_buys, num_sells,
total_usd_buys, total_usd_sells,*/
overall_numberof_trades, overall_total_usd,
ROUND((overall_numberof_trades / SUM(overall_numberof_trades) OVER ()),4) AS total_trade_volume_share,
ROUND((overall_total_usd / SUM(overall_total_usd) OVER ()),4) AS total_usd_share
FROM unified_pairs
WHERE trading_pair = val_trading_pair
AND version = 'Uni v3'
ORDER BY overall_total_usd DESC
--LIMIT 100
)
, version2 AS (
SELECT
--version,
RANK() OVER (ORDER BY overall_total_usd DESC) AS pair_rank,
CASE WHEN RIGHT(val_trading_pair,4) = 'WETH' THEN val_flipped_pair -- if pair ends in WETH, flip it.
ELSE val_trading_pair
END AS trading_pair,
val_flipped_pair,
/*num_buys, num_sells,
total_usd_buys, total_usd_sells,*/
overall_numberof_trades, overall_total_usd,
ROUND((overall_numberof_trades / SUM(overall_numberof_trades) OVER ()),4) AS total_trade_volume_share,
ROUND((overall_total_usd / SUM(overall_total_usd) OVER ()),4) AS total_usd_share
FROM unified_pairs
WHERE trading_pair = val_trading_pair
AND version = 'Uni v2'
ORDER BY overall_total_usd DESC
--LIMIT 100
)

SELECT
v2.trading_pair,
--v3.trading_pair,
--f.val_flipped_pair,
v2.overall_numberof_trades AS v2_trades,
v2.overall_total_usd AS v2_total_usd,
COALESCE(v3.overall_numberof_trades,f.overall_numberof_trades,0) AS v3_trades,
COALESCE(v3.overall_total_usd,f.overall_total_usd,0) AS v3_total_usd,
--- calculated fields
COALESCE(v3.overall_numberof_trades,f.overall_numberof_trades,0)::decimal/
(v2.overall_numberof_trades+
COALESCE(v3.overall_numberof_trades,f.overall_numberof_trades,0))::decimal AS v3_trade_dominance,
-- break b/c this got confusing
COALESCE(v3.overall_total_usd,f.overall_total_usd,0)::decimal/
(v2.overall_total_usd+
COALESCE(v3.overall_total_usd,f.overall_total_usd,0))::decimal AS v3_usd_dominance,
-- final counting values
(v2.overall_numberof_trades+
COALESCE(v3.overall_numberof_trades,f.overall_numberof_trades,0))::decimal AS total_trades,
(v2.overall_total_usd+
COALESCE(v3.overall_total_usd,f.overall_total_usd,0))::decimal AS total_usd
--use v2 trading pair
FROM version2 AS v2
LEFT JOIN version3 AS v3
ON v2.trading_pair = v3.trading_pair
LEFT JOIN version3 AS f
ON v2.trading_pair = f.val_flipped_pair

--WHERE v3.overall_numberof_trades > 0

ORDER BY (v2.overall_total_usd+
COALESCE(v3.overall_total_usd,f.overall_total_usd,0))::decimal DESC
--LIMIT 1000"
44224,Uniswap V2 V3 Trading Pairs(Inactive Pairs),,table,"WITH alltrades AS (SELECT d.block_time, d.project, d.version,tx_hash,
CASE WHEN d.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN d.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN d.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN d.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN d.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(d.token_a_symbol,d.token_a_address::text) 
END AS token_received,
d.token_a_amount AS quantity_received,
CASE WHEN d.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN d.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN d.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN d.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN d.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(d.token_b_symbol,d.token_b_address::text)
END AS token_sent,
d.token_b_amount AS quantity_sent,
d.usd_amount
FROM dex.trades d
WHERE
d.project = 'Uniswap'
AND d.version IN ('2', '3')
--AND d.version = '3'
AND d.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '{{Trailing Number of Days}} days'::INTERVAL)
AND d.block_time >= '05-05-2021 17:00'
--AND d.token_a_amount IS NOT NULL
--AND d.token_b_amount IS NOT NULL
),

all_pairs AS
(
SELECT
--date_trunc('hour',a.block_time) AS date_hour, --I'll leave this out for now, becuase I don't have a thesis on pool change over time, rather just what's most often being used.
CASE
WHEN version = '1' THEN 'Uni v1'
WHEN version = '2' THEN 'Uni v2'
WHEN version = '3' THEN 'Uni v3'
ELSE 'n/a'
END AS version,
token_received,
token_sent,
CONCAT(token_received, '/', token_sent) AS trading_pair,
CONCAT(token_sent, '/', token_received) AS flipped_pair, -- for joining
COUNT(DISTINCT tx_hash) AS num_trades,
SUM(quantity_received) AS total_quantity_received,
SUM(quantity_sent) AS total_quantity_sent,
SUM(a.usd_amount) AS total_usd
FROM alltrades a
GROUP BY 1, 2, 3, 4, 5
HAVING SUM(quantity_received) IS NOT NULL
AND SUM(quantity_sent) IS NOT NULL
AND SUM(a.usd_amount) IS NOT NULL
--ORDER BY 1 DESC, /*2 DESC,*/ 9 DESC
),
--SELECT * FROM all_pairs
unified_pairs AS (
--Here I'm trying to unify the buy/sell pairs (i.e. combine WETH/USDC and USDC/WETH)
-- Idea is to join the table to a flipped version of the trading pair, create a ""buy count"" , ""sell count"" , ""total count""
SELECT DISTINCT
buy.version,
buy.trading_pair,
sell.flipped_pair,
CASE WHEN (buy.total_usd >= sell.total_usd) OR (sell.total_usd IS NULL) THEN buy.trading_pair --if buy> sell give me buy
ELSE sell.trading_pair --else if sell>buy, give me sell
END AS val_trading_pair, --which direction had the highest volume? pick that one.
CASE WHEN (buy.total_usd < sell.total_usd) THEN buy.trading_pair --give me the opposite of what I want
ELSE buy.flipped_pair --probably could've mad this simpler by copying val_trading_pair and flipping the thens... oh well this works
END AS val_flipped_pair,
buy.num_trades AS num_buys,
sell.num_trades AS num_sells,
buy.total_usd AS total_usd_buys,
sell.total_usd AS total_usd_sells,
buy.num_trades + COALESCE(sell.num_trades,0) AS overall_numberof_trades,
buy.total_usd + COALESCE(sell.total_usd,0) AS overall_total_usd
FROM all_pairs buy
LEFT JOIN all_pairs sell
ON buy.trading_pair = sell.flipped_pair
AND buy.version = sell.version
)
, version3 AS (
SELECT
--version,
--RANK() OVER (ORDER BY overall_total_usd DESC) AS pair_rank,
CASE WHEN RIGHT(val_trading_pair,4) = 'WETH' THEN val_flipped_pair -- if pair ends in WETH, flip it.
ELSE val_trading_pair
END AS trading_pair,
val_flipped_pair,
/*num_buys, num_sells,
total_usd_buys, total_usd_sells,*/
overall_numberof_trades, overall_total_usd,
ROUND((overall_numberof_trades / SUM(overall_numberof_trades) OVER ()),4) AS total_trade_volume_share,
ROUND((overall_total_usd / SUM(overall_total_usd) OVER ()),4) AS total_usd_share
FROM unified_pairs
WHERE trading_pair = val_trading_pair
AND version = 'Uni v3'
--ORDER BY overall_total_usd DESC
--LIMIT 100
)
, version2 AS (
SELECT
--version,
RANK() OVER (ORDER BY overall_total_usd DESC) AS pair_rank,
CASE WHEN RIGHT(val_trading_pair,4) = 'WETH' THEN val_flipped_pair -- if pair ends in WETH, flip it.
ELSE val_trading_pair
END AS trading_pair,
val_flipped_pair,
/*num_buys, num_sells,
total_usd_buys, total_usd_sells,*/
overall_numberof_trades, overall_total_usd,
ROUND((overall_numberof_trades / SUM(overall_numberof_trades) OVER ()),4) AS total_trade_volume_share,
ROUND((overall_total_usd / SUM(overall_total_usd) OVER ()),4) AS total_usd_share
FROM unified_pairs
WHERE trading_pair = val_trading_pair
AND version = 'Uni v2'
--ORDER BY overall_total_usd DESC
--LIMIT 100
)

SELECT
COALESCE(v2.trading_pair, v3.trading_pair) AS trading_pair,
--v3.trading_pair,
--f.val_flipped_pair,
v2.overall_numberof_trades AS v2_trades,
v2.overall_total_usd AS v2_total_usd/*,
COALESCE(v3.overall_numberof_trades,f.overall_numberof_trades,0) AS v3_trades,
COALESCE(v3.overall_total_usd,f.overall_total_usd,0) AS v3_total_usd,
--- calculated fields
COALESCE(v3.overall_numberof_trades,f.overall_numberof_trades,0)::decimal/
(v2.overall_numberof_trades+
COALESCE(v3.overall_numberof_trades,f.overall_numberof_trades,0))::decimal AS v3_trade_dominance,
-- break b/c this got confusing
COALESCE(v3.overall_total_usd,f.overall_total_usd,0)::decimal/
(v2.overall_total_usd+
COALESCE(v3.overall_total_usd,f.overall_total_usd,0))::decimal AS v3_usd_dominance,
-- final counting values
(v2.overall_numberof_trades+
COALESCE(v3.overall_numberof_trades,f.overall_numberof_trades,0))::decimal AS total_trades,
(v2.overall_total_usd+
COALESCE(v3.overall_total_usd,f.overall_total_usd,0))::decimal AS total_usd
--use v2 trading pair*/
FROM version2 AS v2
LEFT JOIN version3 AS v3
ON v2.trading_pair = v3.trading_pair
LEFT JOIN version3 AS f
ON v2.trading_pair = f.val_flipped_pair

WHERE COALESCE(v3.overall_numberof_trades,f.overall_numberof_trades,0) = 0
AND v2.overall_numberof_trades > 0
--AND COALESCE(v2.trading_pair, v3.trading_pair) LIKE '%USDC%'

ORDER BY v2.overall_total_usd DESC
--LIMIT 1000"
43639,Uniswap V2 Popular Pairs,,table,"WITH alltrades AS (SELECT d.block_time, d.project, d.version,tx_hash,
CASE WHEN d.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN d.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN d.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN d.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN d.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(d.token_a_symbol,d.token_a_address::text) 
END AS token_received,
d.token_a_amount AS quantity_received,
CASE WHEN d.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN d.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN d.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN d.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN d.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(d.token_b_symbol,d.token_b_address::text)
END AS token_sent,
d.token_b_amount AS quantity_sent,
d.usd_amount
FROM dex.trades d
WHERE
d.project = 'Uniswap'
--AND d.version IN ('1','2', '3')
AND d.version = '2'
AND d.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '{{Trailing Number of Days}} days'::INTERVAL)
AND d.block_time >= '05-05-2021 17:00'
--AND d.token_a_amount IS NOT NULL
--AND d.token_b_amount IS NOT NULL
),

all_pairs AS
(
SELECT
--date_trunc('hour',a.block_time) AS date_hour, --I'll leave this out for now, becuase I don't have a thesis on pool change over time, rather just what's most often being used.
CASE
WHEN version = '1' THEN 'Uni v1'
WHEN version = '2' THEN 'Uni v2'
WHEN version = '3' THEN 'Uni v3'
ELSE 'n/a'
END AS version,
token_received,
token_sent,
CONCAT(token_received, '/', token_sent) AS trading_pair,
CONCAT(token_sent, '/', token_received) AS flipped_pair, -- for joining
COUNT(DISTINCT tx_hash) AS num_trades,
SUM(quantity_received) AS total_quantity_received,
SUM(quantity_sent) AS total_quantity_sent,
SUM(a.usd_amount) AS total_usd
FROM alltrades a
GROUP BY 1, 2, 3, 4, 5
HAVING SUM(quantity_received) IS NOT NULL
AND SUM(quantity_sent) IS NOT NULL
AND SUM(a.usd_amount) IS NOT NULL
ORDER BY 1 DESC, /*2 DESC,*/ 9 DESC
),
--SELECT * FROM all_pairs
unified_pairs AS (
--Here I'm trying to unify the buy/sell pairs (i.e. combine WETH/USDC and USDC/WETH)
-- Idea is to join the table to a flipped version of the trading pair, create a ""buy count"" , ""sell count"" , ""total count""
SELECT DISTINCT
buy.version,
buy.trading_pair,
sell.flipped_pair,
CASE WHEN (buy.total_usd >= sell.total_usd) OR (sell.total_usd IS NULL) THEN buy.trading_pair
ELSE sell.trading_pair
END AS val_trading_pair, --which direction had the highest volume? pick that one.
CASE WHEN (buy.total_usd < sell.total_usd) THEN buy.trading_pair
ELSE buy.flipped_pair
END AS val_flipped_pair,
buy.num_trades AS num_buys,
sell.num_trades AS num_sells,
buy.total_usd AS total_usd_buys,
sell.total_usd AS total_usd_sells,
buy.num_trades + COALESCE(sell.num_trades,0) AS overall_numberof_trades,
buy.total_usd + COALESCE(sell.total_usd,0) AS overall_total_usd
FROM all_pairs buy
LEFT JOIN all_pairs sell
ON buy.trading_pair = sell.flipped_pair
AND buy.version = sell.version
)

SELECT
--version,
RANK() OVER (ORDER BY overall_total_usd DESC) AS pair_rank,
CASE WHEN RIGHT(val_trading_pair,4) = 'WETH' THEN val_flipped_pair -- if pair ends in WETH, flip it.
ELSE val_trading_pair
END AS trading_pair,
/*num_buys, num_sells,
total_usd_buys, total_usd_sells,*/
overall_numberof_trades, overall_total_usd,
ROUND((overall_numberof_trades / SUM(overall_numberof_trades) OVER ()),4) AS total_trade_volume_share,
ROUND((overall_total_usd / SUM(overall_total_usd) OVER ()),4) AS total_usd_share
FROM unified_pairs
WHERE trading_pair = val_trading_pair
ORDER BY overall_total_usd DESC
--LIMIT 100

"
241722,Uniswap V2 vs V3 Ramp Up by Fee Tier,,table,"WITH alltrades AS (SELECT d.block_time, d.project, d.version,""tx_hash"",
/*COALESCE(d.token_a_symbol,d.token_a_address::text) AS token_received,
d.token_a_amount AS quantity_received,
COALESCE(d.token_b_symbol,d.token_b_address::text) AS token_sent, */
d.token_b_amount AS quantity_sent,
d.usd_amount,
pc.""fee""/1e6 AS fee_tier
FROM dex.trades d

INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" pc
    ON pc.""pool"" = d.exchange_contract_address

WHERE
d.project = 'Uniswap'
AND d.version IN ('1','2', '3')
AND d.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '{{Trailing Number of Days}} days'::INTERVAL)
AND d.block_time >= '05-05-2021 17:00'
--AND d.token_a_amount IS NOT NULL
--AND d.token_b_amount IS NOT NULL
)

SELECT *,  ROUND(fee_tier*100,2)::text || '%' AS fee_tier_pct
FROM (
    SELECT
    date_trunc('hour',a.block_time) AS date_hour,
    fee_tier,
    CASE
    WHEN version = '1' THEN 'Uni v1'
    WHEN version = '2' THEN 'Uni v2'
    WHEN version = '3' THEN 'Uni v3'
    ELSE 'n/a'
    END AS version,
    --token_received,
    --token_sent,
    COUNT(DISTINCT tx_hash) AS num_trades,
    SUM(a.usd_amount) AS total_usd,
    SUM(a.usd_amount*fee_tier) AS total_fees_usd
    FROM alltrades a
    GROUP BY 1,2,3
    ORDER BY 1 DESC, 3 DESC
    --,3,4
    ) t"
44349,Uniswap V2 vs V3 Ramp Up - First 365 Days,,table,"WITH alltrades AS (
SELECT
date_trunc('day',d.block_time) AS date_day,
d.project, d.version,
/*COALESCE(d.token_a_symbol,d.token_a_address::text) AS token_received,
d.token_a_amount AS quantity_received,
COALESCE(d.token_b_symbol,d.token_b_address::text) AS token_sent,
d.token_b_amount AS quantity_sent,*/
COUNT(DISTINCT tx_hash) AS num_trades,
SUM(d.usd_amount) AS total_USD
FROM dex.trades d
WHERE
d.project = 'Uniswap'
AND d.version IN ('1','2', '3')
AND
(
(version = '1' AND date_trunc('day',d.block_time) >= '11-01-2018 00:00') --uni v1 launch https://uniswap.org/blog/uniswap-history/
OR (version = '2' AND date_trunc('day',d.block_time) >= '05-18-2020 00:00') --uni v2 launch https://uniswap.org/blog/launch-uniswap-v2/
OR (version = '3' AND date_trunc('day',d.block_time) >= '05-05-2021 00:00')-- uni v3 launch https://uniswap.org/blog/launch-uniswap-v3/
)
--AND d.token_a_amount IS NOT NULL
--AND d.token_b_amount IS NOT NULL
GROUP BY
1,2,3
),
days_since AS(
SELECT
RANK() OVER(PARTITION BY a.project, a.version ORDER BY a.date_day ASC) AS days_since_launch,
date_day,
CASE
WHEN version = '1' THEN 'Uni v1'
WHEN version = '2' THEN 'Uni v2'
WHEN version = '3' THEN 'Uni v3'
ELSE 'n/a'
END AS version,
num_trades,
total_USD

FROM alltrades a
)
SELECT * FROM days_since
WHERE days_since_launch <= 365
AND --don't select most recent day for v3, since the day won't be complete.
1 = (
CASE WHEN
days_since_launch = (SELECT days_since_launch FROM days_since
                    WHERE version = 'Uni v3' ORDER BY days_since_launch DESC LIMIT 1)
AND version = 'Uni v3' THEN 0
ELSE 1
END
)
--DATE_PART('day',DATE_TRUNC('day',now()) - '05-06-2021') + 30 -- I want to do days since Uni v3 launch + 30

---- idkkkkkkk
/*
SELECT
date_trunc('hour',a.block_time) AS date_hour,
CASE
WHEN version = '1' THEN 'Uni v1'
WHEN version = '2' THEN 'Uni v2'
WHEN version = '3' THEN 'Uni v3'
ELSE 'n/a'
END AS version,
--token_received,
--token_sent,
COUNT(a.block_time) AS num_trades,
SUM(a.usd_amount) AS total_usd
FROM alltrades a
GROUP BY 1,2
ORDER BY 1 DESC, 2 DESC
--,3,4*/"
44027,Uniswap V2 vs V3 Ramp Up (T24H),,table,"WITH alltrades AS (SELECT d.block_time, d.project, d.version, tx_hash,
/*COALESCE(d.token_a_symbol,d.token_a_address::text) AS token_received,
d.token_a_amount AS quantity_received,
COALESCE(d.token_b_symbol,d.token_b_address::text) AS token_sent, */
d.token_b_amount AS quantity_sent,
d.usd_amount
FROM dex.trades d
WHERE
d.project = 'Uniswap'
AND d.version IN ('1','2', '3')
AND d.block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '23 hours'::INTERVAL)
AND d.block_time >= '05-05-2021 17:00'
--AND d.token_a_amount IS NOT NULL
--AND d.token_b_amount IS NOT NULL
)

SELECT
date_trunc('hour',a.block_time) AS date_hour,
CASE
WHEN version = '1' THEN 'Uni v1'
WHEN version = '2' THEN 'Uni v2'
WHEN version = '3' THEN 'Uni v3'
ELSE 'n/a'
END AS version,
--token_received,
--token_sent,
COUNT(DISTINCT tx_hash) AS num_trades,
SUM(a.usd_amount) AS total_usd
FROM alltrades a
GROUP BY 1,2
ORDER BY 1,2 DESC
--,3,4"
44186,Uniswap V2 V3 Trading Pair Dominance (Active Pairs >$1k Volume),,table,"WITH alltrades AS (SELECT d.block_time, d.project, d.version,tx_hash,
CASE WHEN d.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN d.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN d.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN d.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN d.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(d.token_a_symbol,d.token_a_address::text) 
END AS token_received,
d.token_a_amount AS quantity_received,
CASE WHEN d.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN d.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN d.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN d.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN d.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(d.token_b_symbol,d.token_b_address::text)
END AS token_sent,
d.token_b_amount AS quantity_sent,
d.usd_amount
FROM dex.trades d
WHERE
d.project = 'Uniswap'
AND d.version IN ('2', '3')
--AND d.version = '3'
AND d.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '{{Trailing Number of Days}} days'::INTERVAL)
AND d.block_time >= '05-05-2021 17:00'
--AND d.token_a_amount IS NOT NULL
--AND d.token_b_amount IS NOT NULL
),

all_pairs AS
(
SELECT
--date_trunc('hour',a.block_time) AS date_hour, --I'll leave this out for now, becuase I don't have a thesis on pool change over time, rather just what's most often being used.
CASE
WHEN version = '1' THEN 'Uni v1'
WHEN version = '2' THEN 'Uni v2'
WHEN version = '3' THEN 'Uni v3'
ELSE 'n/a'
END AS version,
token_received,
token_sent,
CONCAT(token_received, '/', token_sent) AS trading_pair,
CONCAT(token_sent, '/', token_received) AS flipped_pair, -- for joining
COUNT(DISTINCT tx_hash) AS num_trades,
SUM(quantity_received) AS total_quantity_received,
SUM(quantity_sent) AS total_quantity_sent,
SUM(a.usd_amount) AS total_usd
FROM alltrades a
GROUP BY 1, 2, 3, 4, 5
HAVING /*SUM(quantity_received) IS NOT NULL
AND SUM(quantity_sent) IS NOT NULL
AND*/ SUM(a.usd_amount) IS NOT NULL
--ORDER BY 1 DESC, /*2 DESC,*/ 9 DESC
),
--SELECT * FROM all_pairs
unified_pairs AS (
--Here I'm trying to unify the buy/sell pairs (i.e. combine WETH/USDC and USDC/WETH)
-- Idea is to join the table to a flipped version of the trading pair, create a ""buy count"" , ""sell count"" , ""total count""
SELECT DISTINCT
buy.version,
buy.trading_pair,
sell.flipped_pair,
CASE WHEN (buy.total_usd >= sell.total_usd) OR (sell.total_usd IS NULL) THEN buy.trading_pair --if buy> sell give me buy
ELSE sell.trading_pair --else if sell>buy, give me sell
END AS val_trading_pair, --which direction had the highest volume? pick that one.
CASE WHEN (buy.total_usd < sell.total_usd) THEN buy.trading_pair --give me the opposite of what I want
ELSE buy.flipped_pair --probably could've mad this simpler by copying val_trading_pair and flipping the thens... oh well this works
END AS val_flipped_pair,
buy.num_trades AS num_buys,
sell.num_trades AS num_sells,
buy.total_usd AS total_usd_buys,
sell.total_usd AS total_usd_sells,
buy.num_trades + COALESCE(sell.num_trades,0) AS overall_numberof_trades,
buy.total_usd + COALESCE(sell.total_usd,0) AS overall_total_usd
FROM all_pairs buy
LEFT JOIN all_pairs sell
ON buy.trading_pair = sell.flipped_pair
AND buy.version = sell.version
)
, version3 AS (
SELECT
--version,
--RANK() OVER (ORDER BY overall_total_usd DESC) AS pair_rank,
CASE WHEN RIGHT(val_trading_pair,4) = 'WETH' THEN val_flipped_pair -- if pair ends in WETH, flip it.
ELSE val_trading_pair
END AS trading_pair,
val_flipped_pair,
/*num_buys, num_sells,
total_usd_buys, total_usd_sells,*/
overall_numberof_trades, overall_total_usd,
ROUND((overall_numberof_trades / SUM(overall_numberof_trades) OVER ()),4) AS total_trade_volume_share,
ROUND((overall_total_usd / SUM(overall_total_usd) OVER ()),4) AS total_usd_share
FROM unified_pairs
WHERE trading_pair = val_trading_pair
AND version = 'Uni v3'
--ORDER BY overall_total_usd DESC
--LIMIT 100
)
, version2 AS (
SELECT
--version,
RANK() OVER (ORDER BY overall_total_usd DESC) AS pair_rank,
CASE WHEN RIGHT(val_trading_pair,4) = 'WETH' THEN val_flipped_pair -- if pair ends in WETH, flip it.
ELSE val_trading_pair
END AS trading_pair,
val_flipped_pair,
/*num_buys, num_sells,
total_usd_buys, total_usd_sells,*/
overall_numberof_trades, overall_total_usd,
ROUND((overall_numberof_trades / SUM(overall_numberof_trades) OVER ()),4) AS total_trade_volume_share,
ROUND((overall_total_usd / SUM(overall_total_usd) OVER ()),4) AS total_usd_share
FROM unified_pairs
WHERE trading_pair = val_trading_pair
AND version = 'Uni v2'
--ORDER BY overall_total_usd DESC
--LIMIT 100
)

SELECT
COALESCE(v2.trading_pair, v3.trading_pair) AS trading_pair,
--v3.trading_pair,
--f.val_flipped_pair,
v2.overall_numberof_trades AS v2_trades,
v2.overall_total_usd AS v2_total_usd,
COALESCE(v3.overall_numberof_trades,f.overall_numberof_trades,0) AS v3_trades,
COALESCE(v3.overall_total_usd,f.overall_total_usd,0) AS v3_total_usd,
--- calculated fields
COALESCE(v3.overall_numberof_trades,f.overall_numberof_trades,0)::decimal/
(v2.overall_numberof_trades+
COALESCE(v3.overall_numberof_trades,f.overall_numberof_trades,0))::decimal AS v3_trade_dominance,
-- break b/c this got confusing
COALESCE(v3.overall_total_usd,f.overall_total_usd,0)::decimal/
(v2.overall_total_usd+
COALESCE(v3.overall_total_usd,f.overall_total_usd,0))::decimal AS v3_usd_dominance,
-- final counting values
(v2.overall_numberof_trades+
COALESCE(v3.overall_numberof_trades,f.overall_numberof_trades,0))::decimal AS total_trades,
(v2.overall_total_usd+
COALESCE(v3.overall_total_usd,f.overall_total_usd,0))::decimal AS total_usd
--use v2 trading pair
FROM version2 AS v2
LEFT JOIN version3 AS v3
ON v2.trading_pair = v3.trading_pair
LEFT JOIN version3 AS f
ON v2.trading_pair = f.val_flipped_pair

WHERE COALESCE(v3.overall_numberof_trades,f.overall_numberof_trades) > 0
--AND COALESCE(v2.trading_pair, v3.trading_pair) LIKE '%USDC%'
AND 
(v2.overall_total_usd+
COALESCE(v3.overall_total_usd,f.overall_total_usd,0))::decimal >=1000
ORDER BY (v2.overall_total_usd+
COALESCE(v3.overall_total_usd,f.overall_total_usd,0)) DESC
--LIMIT 1000"
43648,Uniswap V3 Popular Pairs,,table,"WITH alltrades AS (SELECT d.block_time, d.project, d.version,tx_hash,
CASE WHEN d.token_a_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN d.token_a_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN d.token_a_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN d.token_a_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN d.token_a_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN d.token_a_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN d.token_a_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(d.token_a_symbol,d.token_a_address::text) 
END AS token_received,
d.token_a_amount AS quantity_received,
CASE WHEN d.token_b_address::text = '\xf16e4d813f4dcfde4c5b44f305c908742de84ef0' THEN 'ETH2x ADL'
WHEN d.token_b_address::text = '\x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce' THEN 'SHIB'
WHEN d.token_b_address::text = '\x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3' THEN 'ELON'
WHEN d.token_b_address::text = '\x77fba179c79de5b7653f68b5039af940ada60ce0' THEN 'FORTH'
WHEN d.token_b_address::text = '\xf65b5c5104c4fafd4b709d9d60a185eae063276c' THEN 'TRU'
WHEN d.token_b_address::text = '\xc7283b66eb1eb5fb86327f08e1b5816b0720212b' THEN 'TRIBE'
WHEN d.token_b_address::text = '\xc8807f0f5ba3fa45ffbdc66928d71c5289249014' THEN 'ISP'
ELSE COALESCE(d.token_b_symbol,d.token_b_address::text)
END AS token_sent,
d.token_b_amount AS quantity_sent,
d.usd_amount
FROM dex.trades d
WHERE
d.project = 'Uniswap'
--AND d.version IN ('1','2', '3')
AND d.version = '3'
AND d.block_time >= (DATE_TRUNC('day',CURRENT_TIMESTAMP) - '{{Trailing Number of Days}} days'::INTERVAL)
AND d.block_time >= '05-05-2021 17:00'
--AND d.token_a_amount IS NOT NULL
--AND d.token_b_amount IS NOT NULL
),

all_pairs AS
(
SELECT
--date_trunc('hour',a.block_time) AS date_hour, --I'll leave this out for now, becuase I don't have a thesis on pool change over time, rather just what's most often being used.
CASE
WHEN version = '1' THEN 'Uni v1'
WHEN version = '2' THEN 'Uni v2'
WHEN version = '3' THEN 'Uni v3'
ELSE 'n/a'
END AS version,
token_received,
token_sent,
CONCAT(token_received, '/', token_sent) AS trading_pair,
CONCAT(token_sent, '/', token_received) AS flipped_pair, -- for joining
COUNT(DISTINCT tx_hash) AS num_trades,
SUM(quantity_received) AS total_quantity_received,
SUM(quantity_sent) AS total_quantity_sent,
SUM(a.usd_amount) AS total_usd
FROM alltrades a
GROUP BY 1, 2, 3, 4, 5
HAVING /*SUM(quantity_received) IS NOT NULL
AND SUM(quantity_sent) IS NOT NULL
AND*/ SUM(a.usd_amount) IS NOT NULL
ORDER BY 1 DESC, /*2 DESC,*/ 9 DESC
),
--SELECT * FROM all_pairs
unified_pairs AS (
--Here I'm trying to unify the buy/sell pairs (i.e. combine WETH/USDC and USDC/WETH)
-- Idea is to join the table to a flipped version of the trading pair, create a ""buy count"" , ""sell count"" , ""total count""
SELECT DISTINCT
buy.version,
buy.trading_pair,
sell.flipped_pair,
CASE WHEN (buy.total_usd >= sell.total_usd) OR (sell.total_usd IS NULL) THEN buy.trading_pair
ELSE sell.trading_pair
END AS val_trading_pair, --which direction had the highest volume? pick that one.
CASE WHEN (buy.total_usd < sell.total_usd) THEN buy.trading_pair
ELSE buy.flipped_pair
END AS val_flipped_pair,
buy.num_trades AS num_buys,
sell.num_trades AS num_sells,
buy.total_usd AS total_usd_buys,
sell.total_usd AS total_usd_sells,
buy.num_trades + COALESCE(sell.num_trades,0) AS overall_numberof_trades,
buy.total_usd + COALESCE(sell.total_usd,0) AS overall_total_usd
FROM all_pairs buy
LEFT JOIN all_pairs sell
ON buy.trading_pair = sell.flipped_pair
AND buy.version = sell.version
)

SELECT
--version,
RANK() OVER (ORDER BY overall_total_usd DESC) AS pair_rank,
CASE WHEN RIGHT(val_trading_pair,4) = 'WETH' THEN val_flipped_pair -- if pair ends in WETH, flip it.
ELSE val_trading_pair
END AS trading_pair,
/*num_buys, num_sells,
total_usd_buys, total_usd_sells,*/
overall_numberof_trades, overall_total_usd,
ROUND((overall_numberof_trades / SUM(overall_numberof_trades) OVER ()),4) AS total_trade_volume_share,
ROUND((overall_total_usd / SUM(overall_total_usd) OVER ()),4) AS total_usd_share
FROM unified_pairs
WHERE trading_pair = val_trading_pair
ORDER BY overall_total_usd DESC
--LIMIT 100

"
62069,Sommelier Finance TVL,,table,"WITH nfts AS
  (SELECT ""tokenId"" AS token_id,
          token0 AS token_a,
          token1 AS token_b
   FROM sommelier.""Vyper_contract_evt_AddedLiquidity""),
     add_liquidity AS
  (SELECT evt_block_time AS block_time,
          token_a,
          amount0 AS amount_a
   FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_IncreaseLiquidity""
   INNER JOIN nfts ON ""tokenId"" = token_id
   UNION ALL SELECT evt_block_time,
                    token_b,
                    amount1 AS amount_b
   FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_IncreaseLiquidity""
   INNER JOIN nfts ON ""tokenId"" = token_id),
     remove_liquidity AS
  (SELECT evt_block_time AS block_time,
          token_a, -amount0 AS amount_a
   FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_DecreaseLiquidity""
   INNER JOIN nfts ON ""tokenId"" = token_id
   UNION ALL SELECT evt_block_time,
                    token_b, -amount1 AS amount_b
   FROM uniswap_v3.""NonfungibleTokenPositionManager_evt_DecreaseLiquidity""
   INNER JOIN nfts ON ""tokenId"" = token_id)
SELECT block_time,
       sum(amount_usd) OVER (
                             ORDER BY block_time)
FROM
  (SELECT block_time,
          amount_a / 10^decimals * price AS amount_usd
   FROM add_liquidity
   INNER JOIN prices.""usd"" p ON token_a = p.contract_address
   AND date_trunc('minute', block_time) = MINUTE
   UNION ALL SELECT block_time,
                    amount_a / 10^decimals * price AS amount_usd
   FROM remove_liquidity
   INNER JOIN prices.""usd"" p ON token_a = p.contract_address
   AND date_trunc('minute', block_time) = MINUTE
   ORDER BY 1 DESC) a"
58621,Charm Alpha Vault TVL,,counter,"WITH pairs AS
  (SELECT charm.contract_address AS vault,
          token0,
          token1
   FROM charm.""AlphaVault_evt_Deposit"" charm
   INNER JOIN uniswap_v3.""Pair_evt_Mint"" uni ON charm.contract_address = OWNER
   INNER JOIN uniswap_v3.""Factory_evt_PoolCreated"" ON uni.contract_address = pool
   GROUP BY 1,
            2,
            3),
     deposits_and_withdrawals AS
  (SELECT evt_block_time,
          amount0 / 10^decimals * price AS amount
   FROM charm.""AlphaVault_evt_Deposit"" charm
   INNER JOIN pairs ON vault = charm.contract_address
   INNER JOIN prices.usd p ON token0 = p.contract_address
   AND date_trunc('minute', evt_block_time) = MINUTE
   UNION ALL SELECT evt_block_time,
                    amount1 / 10^decimals * price
   FROM charm.""AlphaVault_evt_Deposit"" charm
   INNER JOIN pairs ON vault = charm.contract_address
   INNER JOIN prices.usd p ON token1 = p.contract_address
   AND date_trunc('minute', evt_block_time) = MINUTE
   UNION ALL SELECT evt_block_time, -amount0 / 10^decimals * price
   FROM charm.""AlphaVault_evt_Withdraw"" charm
   INNER JOIN pairs ON vault = charm.contract_address
   INNER JOIN prices.usd p ON token0 = p.contract_address
   AND date_trunc('minute', evt_block_time) = MINUTE
   UNION ALL SELECT evt_block_time, -amount1 / 10^decimals * price
   FROM charm.""AlphaVault_evt_Withdraw"" charm
   INNER JOIN pairs ON vault = charm.contract_address
   INNER JOIN prices.usd p ON token1 = p.contract_address
   AND date_trunc('minute', evt_block_time) = MINUTE)
SELECT evt_block_time,
       sum(amount) OVER (
                         ORDER BY evt_block_time)
FROM deposits_and_withdrawals"
57131,Visor Finance TVL,,table,"WITH hypervisors AS
  (SELECT substring(DATA
                    FROM 109
                    FOR 20) AS contract,
          substring(DATA
                    FROM 13
                    FOR 20) AS token0,
          substring(DATA
                    FROM 45
                    FOR 20) AS token1
   FROM ethereum.logs
   WHERE topic1 = '\x16682fe0a2ffae99e47dc4431cb60eb5afccc35b1d4a4d0184d4516ed6031bbd'),
     deposits_and_withdrawals AS
  (SELECT block_time,
          token0,
          bytea2numeric(substring(DATA
                                  FROM 33
                                  FOR 32)) AS amount0,
          token1,
          bytea2numeric(substring(DATA
                                  FROM 65
                                  FOR 32)) AS amount1
   FROM ethereum.logs logs
   INNER JOIN hypervisors ON logs.contract_address = contract
   AND topic1 = '\x4e2ca0515ed1aef1395f66b5303bb5d6f1bf9d61a353fa53f73f8ac9973fa9f6'
   AND block_time >= '2021-05-16'
   UNION ALL SELECT block_time,
                    token0, -bytea2numeric(substring(DATA
                                                     FROM 33
                                                     FOR 32)) AS amount0,
                             token1, -bytea2numeric(substring(DATA
                                                              FROM 65
                                                              FOR 32)) AS amount1
   FROM ethereum.logs logs
   INNER JOIN hypervisors ON logs.contract_address = contract
   AND topic1 = '\xebff2602b3f468259e1e99f613fed6691f3a6526effe6ef3e768ba7ae7a36c4f'
   AND block_time >= '2021-05-16'),
     amounts AS
  (SELECT block_time,
          token0 AS token,
          amount0 / 10^decimals AS amount
   FROM deposits_and_withdrawals
   INNER JOIN erc20.tokens ON contract_address = token0
   WHERE amount0 != 0
   UNION ALL SELECT block_time,
                    token1,
                    amount1 / 10^decimals
   FROM deposits_and_withdrawals
   INNER JOIN erc20.tokens ON contract_address = token1
   WHERE amount1 != 0)
SELECT block_time,
       sum(amount) OVER (
                         ORDER BY block_time)
FROM
  (SELECT block_time,
          amount * price AS amount
   FROM amounts
   INNER JOIN prices.usd ON contract_address = token
   AND date_trunc('minute', block_time) = MINUTE
   AND MINUTE >= '2021-05-16') a"
62075,Total Charm Alpha Vault LPs over time,,table,"SELECT date, sum(1) OVER (
                          ORDER BY date)
FROM
  (SELECT min(evt_block_time) AS date,
          ""sender""
   FROM charm.""AlphaVault_evt_Deposit""
   GROUP BY 2) a"
62072,Total Sommelier Finance LPs over time,,table,"SELECT date, sum(1) OVER (
                          ORDER BY date)
FROM
  (SELECT min(evt_block_time) AS date,
          ""from""
   FROM sommelier.""Vyper_contract_evt_AddedLiquidity""
   INNER JOIN ethereum.""transactions"" ON evt_tx_hash = hash
   GROUP BY 2) a"
62071,Total Visor Finance LPs over time,,table,"WITH hypervisors AS
  (SELECT substring(DATA
                    FROM 109
                    FOR 20) AS hypervisor
   FROM ethereum.logs
   WHERE topic1 = '\x16682fe0a2ffae99e47dc4431cb60eb5afccc35b1d4a4d0184d4516ed6031bbd')
SELECT date, sum(1) OVER (
                          ORDER BY date)
FROM
  (SELECT min(block_time) AS date,
          account
   FROM
     (SELECT block_time,
             substring(topic2
                       FROM 13
                       FOR 20) AS account
      FROM ethereum.logs
      INNER JOIN hypervisors ON contract_address = hypervisor
      AND topic1 = '\x4e2ca0515ed1aef1395f66b5303bb5d6f1bf9d61a353fa53f73f8ac9973fa9f6'
      UNION ALL SELECT block_time,
                       substring(topic3
                                 FROM 13
                                 FOR 20)
      FROM ethereum.logs
      INNER JOIN hypervisors ON contract_address = hypervisor
      AND topic1 = '\xebff2602b3f468259e1e99f613fed6691f3a6526effe6ef3e768ba7ae7a36c4f') a
   GROUP BY 2) b"
9895,$UNI Trading Volume (by DEX),,table,"WITH prices AS (   -- Get usd prices last 24 hours                                                                                     
    SELECT  minute,                                                         
            contract_address,                                                                              
            price                                                                                
    FROM prices.usd                                                                                    
    WHERE minute >= now() - interval '30 days'
),volume as (
    
    SELECT
    date_trunc('day', block_time) AS date, 
    project,
    SUM(
        CASE WHEN token_a_address = a.contract_address THEN token_a_amount * a.price    -- Use token A when there's USD price for it                    
        ELSE token_b_amount * b.price                                                   -- Else use token b                             
        END   
        ) AS usd_volume                                                                                
FROM dex.""trades"" t                                                                             
LEFT JOIN prices a ON date_trunc('minute', block_time) = a.minute AND token_a_address = a.contract_address -- Joining with prices on time and token address for token A
LEFT JOIN prices b ON date_trunc('minute', block_time) = b.minute AND token_b_address = b.contract_address -- Joining with prices on time and token address for token B
WHERE block_time >= now() - interval '30 days'
and(token_a_address = '\x1f9840a85d5af5bf1d1762f925bdaddc4201f984'::bytea or token_b_address = '\x1f9840a85d5af5bf1d1762f925bdaddc4201f984'::bytea)
GROUP BY 1, 2) select * from volume

-- some checks
-- select * from dex.""trades"" where tx_hash='\x00062381093df9a4e5e02d5822adf0da8c24f39773838b1ec87f733d4855a78b'::bytea and(token_a_address = '\x1f9840a85d5af5bf1d1762f925bdaddc4201f984'::bytea or token_b_address = '\x1f9840a85d5af5bf1d1762f925bdaddc4201f984'::bytea)

-- select project, sum(usd_volume) from volume group by project"
9568,LPs Excluding Yield Farming Tokens,,table,"WITH lp AS
  (SELECT date_trunc('month', call_block_time)::date AS MONTH,
          date(call_block_time) AS date,
          ""to"" AS lp,
          'remove' AS TYPE,
          'v2' AS protocol
   FROM uniswap_v2.""Router02_call_removeLiquidityWithPermit""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router02_call_removeLiquidityETHWithPermit""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router02_call_removeLiquidityETHWithPermitSupportingFeeOnTransf""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router02_call_removeLiquidityETHSupportingFeeOnTransferTokens""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router02_call_removeLiquidityETH""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router02_call_removeLiquidity""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router01_call_removeLiquidityETH""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router01_call_removeLiquidity""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router01_call_removeLiquidityWithPermit""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'remove' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router01_call_removeLiquidityETHWithPermit""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'add' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router02_call_addLiquidityETH""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'add' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router02_call_addLiquidity""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'add' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router01_call_addLiquidityETH""
   WHERE call_success IS TRUE
   UNION SELECT date_trunc('month', call_block_time)::date AS MONTH,
                date(call_block_time) AS date,
                ""to"" AS lp,
                'add' AS TYPE,
                'v2' AS protocol
   FROM uniswap_v2.""Router01_call_addLiquidity""
   WHERE call_success IS TRUE 
   
   --- v1

--   UNION SELECT date_trunc('month', block_time)::date AS MONTH,
--                 date(block_time) AS date,
--                 liquidity_provider AS lp,
--                 'add' AS TYPE,
--                 'v1' AS protocol
--   FROM uniswap_v1.view_add_liquidity
--   UNION SELECT date_trunc('month', block_time)::date AS MONTH,
--                 date(block_time) AS date,
--                 liquidity_provider AS lp,
--                 'remove' AS TYPE,
--                 'v1' AS protocol
--   FROM uniswap_v1.view_remove_liquidity
   
   )
SELECT month, type, count(distinct lp) as mau_lp
FROM lp
group by month, type"
9896,$UNI Trading Volume (by Token Pair),,table,"WITH prices AS (   -- Get usd prices last 24 hours                                                                                     
    SELECT  minute,                                                         
            contract_address,                                                                              
            price                                                                                
    FROM prices.usd                                                                                    
    WHERE minute >= now() - interval '30 days'
),volume as (
    
    SELECT
    date_trunc('day', block_time) AS ""date"", 
    case when token_a_address = '\x1f9840a85d5af5bf1d1762f925bdaddc4201f984'::bytea then token_b_symbol else token_a_symbol end as token_traded_against,
    SUM(
        CASE WHEN token_a_address = a.contract_address THEN token_a_amount * a.price    -- Use token A when there's USD price for it                    
        ELSE token_b_amount * b.price                                                   -- Else use token b                             
        END   
        ) AS usd_volume                                                                                
FROM dex.""trades"" t                                                                             
LEFT JOIN prices a ON date_trunc('minute', block_time) = a.minute AND token_a_address = a.contract_address -- Joining with prices on time and token address for token A
LEFT JOIN prices b ON date_trunc('minute', block_time) = b.minute AND token_b_address = b.contract_address -- Joining with prices on time and token address for token B
WHERE block_time >= now() - interval '30 days'
and(token_a_address = '\x1f9840a85d5af5bf1d1762f925bdaddc4201f984'::bytea or token_b_address = '\x1f9840a85d5af5bf1d1762f925bdaddc4201f984'::bytea)
GROUP BY 1, 2) select * from volume order by ""date"", usd_volume desc

-- some checks
-- select * from dex.""trades"" where tx_hash='\x00062381093df9a4e5e02d5822adf0da8c24f39773838b1ec87f733d4855a78b'::bytea and(token_a_address = '\x1f9840a85d5af5bf1d1762f925bdaddc4201f984'::bytea or token_b_address = '\x1f9840a85d5af5bf1d1762f925bdaddc4201f984'::bytea)

-- select project, sum(usd_volume) from volume group by project"
23273,"Top Traders on Uniswap, 24h",,table,"select 
        case when trader_a='\x7a250d5630b4cf539739df2c5dacb4c659f2488d' then tx_from else trader_a end as trader, 
        -- count(*), 
        sum(usd_amount) as ""24h Volume($)"",
        round(100*sum(usd_amount)/ sum(sum(usd_amount)) over (partition by 1),2) ||'%' as ""Volume %""
    from dex.""trades""  
    where project ='Uniswap' and version = '2' and
         block_time >= (DATE_TRUNC('hour',CURRENT_TIMESTAMP) - '24 hours'::INTERVAL)
group by 1 
order by 2 desc nulls last limit 20
"
366378,Uniswap V2 VS V3 | USD stable to USD stable trading volume per day,,table,"SELECT  
        version as uniswap_version,
        date_trunc('day', block_time),
        SUM(usd_amount) as volume_daily
FROM dex.""trades""
WHERE (project = 'Uniswap')
-- @pandajackson42: token symbol from https://github.com/duneanalytics/abstractions/blob/master/ethereum/erc20/tokens.sql
AND token_a_symbol IN ('USDC', 'USDT', 'DAI', 'MIM', 'UST', 'FRAX', 'LUSD', 'GUSD', 'HUSD', 'mUSD', 'PAX', 'USDP', 'TUSD', 'sUSD', 'ALUSD', 'OUSD', 'DOLA', 'DUSD')
AND token_b_symbol IN ('USDC', 'USDT', 'DAI', 'MIM', 'UST', 'FRAX', 'LUSD', 'GUSD', 'HUSD', 'mUSD', 'PAX', 'USDP', 'TUSD', 'sUSD', 'ALUSD', 'OUSD', 'DOLA', 'DUSD')
GROUP BY 1, 2
ORDER BY 2"
366364,Curve VS Uniswap | USD stable to USD stable trading volume per week,,table,"with volumedaily as(

(

SELECT  project,                        
        date_trunc('day', block_time) as day,
        SUM(usd_amount) as volume_daily                                                                              
FROM dex.""trades""
WHERE (project = 'Uniswap')
AND token_a_symbol IN ('USDC', 'USDT', 'DAI', 'MIM', 'UST', 'FRAX', 'LUSD', 'GUSD', 'HUSD', 'mUSD', 'PAX', 'USDP', 'TUSD', 'sUSD', 'ALUSD', 'OUSD', 'DOLA', 'DUSD')
AND token_b_symbol IN ('USDC', 'USDT', 'DAI', 'MIM', 'UST', 'FRAX', 'LUSD', 'GUSD', 'HUSD', 'mUSD', 'PAX', 'USDP', 'TUSD', 'sUSD', 'ALUSD', 'OUSD', 'DOLA', 'DUSD')

GROUP BY 1, 2

)


union

(

select 

'Curve' as project,

day,

sum(threepool + aave + alusd + busd + busdv2 + compound + dusd + frax + gusd + husd + ironbank + linkusd + lusd + musd + pax + rsv + saave + susdv2 + tusd + usdk + usdn + usdp + usdt + ust + y + mim + mimust + ustw + fei + origin + dola + d3pool) as volume_daily


from (
    -- 3pool
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    end) as threepool,
    0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""threepool_swap_evt_TokenExchange"" as cst
    group by 1

    union
    -- aave
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    end) as aave, 
    0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""aave_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    end) as aave, 
    0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""aave_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- alusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as alusd,
    0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""alusd_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as alusd,
    0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""alusd_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- busd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as busd, 
    0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""busd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as busd, 
    0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""busd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- busdv2
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as busdv2,
    0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""busdv2_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as busdv2,
    0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""busdv2_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- compound
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e8
    when sold_id = 1 then tokens_sold / 1e8
    end) as compound,
    0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""compound_v2_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    end) as compound,
    0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""compound_v2_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day,
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e8
    when sold_id = 1 then tokens_sold / 1e8
    end) as compound,
    0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""compound_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day,
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    end) as compound,
    0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""compound_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- dusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as dusd,
    0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""dusd_swap_evt_TokenExchange"" as cst
    group by 1

    union
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e8
    when sold_id = 3 then tokens_sold / 1e8
    end) as dusd,
    0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""dusd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- frax
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as frax,
    0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""frax_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as frax,
    0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""frax_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- gusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e2
    when sold_id = 1 then tokens_sold / 1e18
    end) as gusd,
    0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""gusd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e2
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as gusd,
    0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""gusd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- husd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e8
    when sold_id = 1 then tokens_sold / 1e18
    end) as husd,
    0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""husd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e8
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as husd,
    0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""husd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- ironbank
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    end) as ironbank,
    0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""ironbank_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- linkusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as linkusd,
    0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""linkusd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as linkusd,
    0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""linkusd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- lusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as lusd,
    0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""lusd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as lusd,
    0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""lusd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- mim
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as mim,
    0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""mim_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as mim,
    0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""mim_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- musd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as musd,
    0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool  
    from curvefi.""musd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as musd,
    0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool  
    from curvefi.""musd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- pax
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as pax, 
    0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""pax_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- rsv
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as rsv,
    0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""rsv_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e8
    when sold_id = 3 then tokens_sold / 1e8
    end) as rsv,
    0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""rsv_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- saave
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as saave,
    0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""saave_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as saave,
    0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""saave_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- susdv2
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as susdv2, 
    0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""susd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as susdv2, 
    0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""susd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- tusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as tusd,
    0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""tusd_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as tusd,
    0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""tusd_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- usdk
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as usdk, 
    0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""usdk_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as usdk, 
    0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""usdk_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- usdn
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as usdn,
    0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdn_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as usdn,
    0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdn_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- usdp
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as usdp,
    0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdp_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as usdp,
    0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdp_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- usdt
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e8
    when sold_id = 1 then tokens_sold / 1e8
    when sold_id = 2 then tokens_sold / 1e6
    end) as usdt, 
    0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdt_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    end) as usdt, 
    0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdt_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- ust
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as ust,
    0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""ust_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as ust,
    0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""ust_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- y
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as y, 0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""y_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as y, 0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""y_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1
    
    union
    -- mimust
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""MIM_UST_evt_TokenExchange"" as cst
    group by 1
    
    union
    -- ustw
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e6
    when sold_id = 1 then tokens_sold / 1e18
    end) as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""wormhole_v2_evt_TokenExchange"" as cst
    group by 1
    
    union
    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e6
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e18
    when sold_id = 3 then tokens_sold / 1e18
    end) as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""wormhole_v2_evt_TokenExchangeUnderlying"" as cst
    group by 1
    
    union
    -- fei    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as fei, 0 as origin, 0 as dola, 0 as d3pool
    from fei_protocol.""Fei3Crv_evt_TokenExchange"" as cst
    group by 1
    
    union
    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e18
    when sold_id = 3 then tokens_sold / 1e18
    end) as fei, 0 as origin, 0 as dola, 0 as d3pool
    from fei_protocol.""Fei3Crv_evt_TokenExchangeUnderlying"" as cst
    group by 1
    
    union
    -- origin
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw, 0 as fei,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as origin, 0 as dola, 0 as d3pool
    from curvefi.""origin_3crv_pool_evt_TokenExchange"" as cst
    group by 1
    
    union
    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw, 0 as fei,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as origin, 0 as dola, 0 as d3pool
    from curvefi.""origin_3crv_pool_evt_TokenExchangeUnderlying"" as cst
    group by 1
    
    union
    -- dola    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw, 0 as fei, 0 as origin,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as dola, 0 as d3pool
    from curvefi.""dola_3crv_pool_evt_TokenExchange"" as cst
    group by 1
    
    union
    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw, 0 as fei, 0 as origin,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e18
    when sold_id = 3 then tokens_sold / 1e18
    end) as dola, 0 as d3pool
    from curvefi.""dola_3crv_pool_evt_TokenExchangeUnderlying"" as cst
    group by 1
    
    
    union
    -- d3pool
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e18
    when sold_id = 3 then tokens_sold / 1e18
    end) as d3pool
    from curvefi.""D3_evt_TokenExchange"" as cst
    group by 1
    
) a group by 2

)

)

SELECT  project,
        date_trunc('week', day) as week,
        SUM(volume_daily) as volume_weekly 
FROM volumedaily
GROUP BY 1, 2
ORDER BY 2 ASC"
366388,Uniswap V3 | USD stable to USD stable swap daily volume by fee tier,,table,"SELECT  
        date_trunc('day', block_time),
        (CASE exchange_contract_address
            WHEN '\x064880be0b82d07f5476653e3ceb1dbcd14be40b' THEN '5bps'
            WHEN '\x10581399a549dbfffdbd9b070a0ba2f9f61620d2' THEN '30bps'
            WHEN '\x129360c964e2e13910d603043f6287e5e9383374' THEN '5bps'
            WHEN '\x16980c16811bde2b3358c1ce4341541a4c772ec9' THEN '5bps'
            WHEN '\x18d96b617a3e5c42a2ada4bc5d1b48e223f17d0d' THEN '1bps'
            WHEN '\x1e8f1568b598908785064809ebf5745004ce3962' THEN '5bps'
            WHEN '\x1e9934db2730e14d89a1516c534612b6806d55b1' THEN '30bps'
            WHEN '\x24b272eacf72cbf561dfdb88d49874cde287b5d2' THEN '100bps'
            WHEN '\x298b7c5e0770d151e4c5cf6cca4dae3a3ffc8e27' THEN '5bps'
            WHEN '\x3416cf6c708da44db2624d63ea0aaef7113527c6' THEN '1bps'
            WHEN '\x34ff465ee92516e9855eb60f520df0384f410b45' THEN '5bps'
            WHEN '\x3c1b69b1a15d15b95a4b6525db43f0b3afcfffaf' THEN '5bps'
            WHEN '\x3f1a6182af41665e6d261efc895335f70e49b443' THEN '5bps'
            WHEN '\x4cf503c67ad0546767da4325742f8c1ca388cec3' THEN '30bps'
            WHEN '\x4e0924d3a751be199c426d52fb1f2337fa96f736' THEN '5bps'
            WHEN '\x54d0975f8667a5527e07a30d00da6832886c8fdb' THEN '5bps'
            WHEN '\x5720eb958685deeeb5aa0b34f677861ce3a8c7f5' THEN '5bps'
            WHEN '\x5777d92f208679db4b9778590fa3cab3ac9e2168' THEN '1bps'
            WHEN '\x5c09448abfdcb638ea992ce3e45bbc1d7ec7c4cf' THEN '30bps'
            WHEN '\x6572ab2843069aeb3e7246ce6f9b67f747b86ad8' THEN '100bps'
            WHEN '\x67e887913b13e280538c169f13d169a659a203de' THEN '5bps'
            WHEN '\x6958686b6348c3d6d5f2dca3106a5c09c156873a' THEN '100bps'
            WHEN '\x69dda571a9bbba1f4fb9e5de066a3fcf06d26ad2' THEN '100bps'
            WHEN '\x6a9850e46518231b23e50467c975fa94026be5d5' THEN '5bps'
            WHEN '\x6c6bc977e13df9b0de53b251522280bb72383700' THEN '5bps'
            WHEN '\x6f48eca74b38d2936b02ab603ff4e36a6c0e3a77' THEN '5bps'
            WHEN '\x7335118ece5464167ec940c4dba3291d1484e00f' THEN '5bps'
            WHEN '\x7858e59e0c01ea06df3af3d20ac7b0003275d4bf' THEN '5bps'
            WHEN '\x7c082bf85e01f9bb343dbb460a14e51f67c58cfb' THEN '30bps'
            WHEN '\x7cebafc6fd780c266c25329138b56bfe251c8f86' THEN '5bps'
            WHEN '\x7cf12cef5ce9e5e068ebdef470ff8295e26c47b9' THEN '5bps'
            WHEN '\x868b7bbbfe148516e5397f23982923686182c2d2' THEN '5bps'
            WHEN '\x88416bd15e3ef6493aa539a22e0ed12a1e9663e3' THEN '5bps'
            WHEN '\x92995d179a5528334356cb4dc5c6cbb1c068696c' THEN '5bps'
            WHEN '\x93f267fd92b432bebf4da4e13b8615bb8eb2095c' THEN '30bps'
            WHEN '\x951c82acc7374c5718c149e746d00c0605d7a69d' THEN '30bps'
            WHEN '\x973a67726227ce2747d5710eb44a53fb9abfd02a' THEN '5bps'
            WHEN '\x97e7d56a0408570ba1a7852de36350f7713906ec' THEN '5bps'
            WHEN '\x9902affdd3b8ef60304958c60377110c6d6ab1df' THEN '30bps'
            WHEN '\x9992c7e0ed14931ddd5bb68e5649c07b13267cb1' THEN '5bps'
            WHEN '\xa63b490aa077f541c9d64bfc1cc0db2a752157b5' THEN '30bps'
            WHEN '\xa6de8dbae7b2504a7bec7b0dc7783e46565e9f75' THEN '1bps'
            WHEN '\xb65fc555b0e970b16329a48e45cfa14fce9a36a4' THEN '1bps'
            WHEN '\xba6f08adb52badc392d803e70d48c8071734131e' THEN '30bps'
            WHEN '\xbb256c2f1b677e27118b0345fd2b3894d2e6d487' THEN '100bps'
            WHEN '\xbcc2adccd4de0b2656179f729c98c39dcd68c84d' THEN '30bps'
            WHEN '\xc2a856c3aff2110c1171b8f942256d40e980c726' THEN '5bps'
            WHEN '\xc63b0708e2f7e69cb8a1df0e1389a98c35a76d52' THEN '5bps'
            WHEN '\xc891f68bff4b020a41279321a31137dd2e535fa5' THEN '30bps'
            WHEN '\xd275bdd4290538e1f834b00f03457889153084a4' THEN '100bps'
            WHEN '\xdcebd5d749e1e2b476f4fcefc20fb1caba793b0c' THEN '30bps'
            WHEN '\xdd960b52ea78a2602bf56e2a0f1563740210c57c' THEN '5bps'
            WHEN '\xe55e68925809784c8234dfcf6f8fa42c3a48b2c3' THEN '5bps'
            WHEN '\xe6e14be906c1f1b438da2010b38beca14b387231' THEN '5bps'
            WHEN '\xee4cf3b78a74affa38c6a926282bcd8b5952818d' THEN '30bps'
            WHEN '\xf1ddc084500fc774bb835f412aea908259b55ce4' THEN '5bps'
            WHEN '\x12d6867fa648d269835cf69b49f125147754b54d' THEN '1bps'
            WHEN '\x39529e96c28807655b5856b3d342c6225111770e' THEN '1bps'
            WHEN '\x668fd4a51bc62dfc83cf5439ee5fda897a8733c6' THEN '30bps'
            WHEN '\xa87b2ff0759f5b82c7ec86444a70f25c6bffccbf' THEN '5bps'
            WHEN '\xbed966ba1d08c9c3fe77bd7f0ad7af22d0cccf9a' THEN '30bps'
            WHEN '\xd4bda8d3f3fa647caefad00032d0908547e00e9c' THEN '1bps'
            ELSE 'new pair detected'
        END)
        as fee_tier,
        SUM(usd_amount) as volume_daily
        
FROM dex.""trades""
WHERE (project = 'Uniswap')
AND exchange_contract_address in ('\x064880be0b82d07f5476653e3ceb1dbcd14be40b','\x10581399a549dbfffdbd9b070a0ba2f9f61620d2','\x129360c964e2e13910d603043f6287e5e9383374','\x16980c16811bde2b3358c1ce4341541a4c772ec9','\x18d96b617a3e5c42a2ada4bc5d1b48e223f17d0d','\x1e8f1568b598908785064809ebf5745004ce3962','\x1e9934db2730e14d89a1516c534612b6806d55b1','\x24b272eacf72cbf561dfdb88d49874cde287b5d2','\x298b7c5e0770d151e4c5cf6cca4dae3a3ffc8e27','\x3416cf6c708da44db2624d63ea0aaef7113527c6','\x34ff465ee92516e9855eb60f520df0384f410b45','\x3c1b69b1a15d15b95a4b6525db43f0b3afcfffaf','\x3f1a6182af41665e6d261efc895335f70e49b443','\x4cf503c67ad0546767da4325742f8c1ca388cec3','\x4e0924d3a751be199c426d52fb1f2337fa96f736','\x54d0975f8667a5527e07a30d00da6832886c8fdb','\x5720eb958685deeeb5aa0b34f677861ce3a8c7f5','\x5777d92f208679db4b9778590fa3cab3ac9e2168','\x5c09448abfdcb638ea992ce3e45bbc1d7ec7c4cf','\x6572ab2843069aeb3e7246ce6f9b67f747b86ad8','\x67e887913b13e280538c169f13d169a659a203de','\x6958686b6348c3d6d5f2dca3106a5c09c156873a','\x69dda571a9bbba1f4fb9e5de066a3fcf06d26ad2','\x6a9850e46518231b23e50467c975fa94026be5d5','\x6c6bc977e13df9b0de53b251522280bb72383700','\x6f48eca74b38d2936b02ab603ff4e36a6c0e3a77','\x7335118ece5464167ec940c4dba3291d1484e00f','\x7858e59e0c01ea06df3af3d20ac7b0003275d4bf','\x7c082bf85e01f9bb343dbb460a14e51f67c58cfb','\x7cebafc6fd780c266c25329138b56bfe251c8f86','\x7cf12cef5ce9e5e068ebdef470ff8295e26c47b9','\x868b7bbbfe148516e5397f23982923686182c2d2','\x88416bd15e3ef6493aa539a22e0ed12a1e9663e3','\x92995d179a5528334356cb4dc5c6cbb1c068696c','\x93f267fd92b432bebf4da4e13b8615bb8eb2095c','\x951c82acc7374c5718c149e746d00c0605d7a69d','\x973a67726227ce2747d5710eb44a53fb9abfd02a','\x97e7d56a0408570ba1a7852de36350f7713906ec','\x9902affdd3b8ef60304958c60377110c6d6ab1df','\x9992c7e0ed14931ddd5bb68e5649c07b13267cb1','\xa63b490aa077f541c9d64bfc1cc0db2a752157b5','\xa6de8dbae7b2504a7bec7b0dc7783e46565e9f75','\xb65fc555b0e970b16329a48e45cfa14fce9a36a4','\xba6f08adb52badc392d803e70d48c8071734131e','\xbb256c2f1b677e27118b0345fd2b3894d2e6d487','\xbcc2adccd4de0b2656179f729c98c39dcd68c84d','\xc2a856c3aff2110c1171b8f942256d40e980c726','\xc63b0708e2f7e69cb8a1df0e1389a98c35a76d52','\xc891f68bff4b020a41279321a31137dd2e535fa5','\xd275bdd4290538e1f834b00f03457889153084a4','\xdcebd5d749e1e2b476f4fcefc20fb1caba793b0c','\xdd960b52ea78a2602bf56e2a0f1563740210c57c','\xe55e68925809784c8234dfcf6f8fa42c3a48b2c3','\xe6e14be906c1f1b438da2010b38beca14b387231','\xee4cf3b78a74affa38c6a926282bcd8b5952818d','\xf1ddc084500fc774bb835f412aea908259b55ce4')
GROUP BY 1,2
ORDER BY 1"
366319,Curve.fi USD stable to USD stable trading volume per day,,table,"/*

Update log:

20220307 @pandajackson42
change 2 table names to comply with the new table name dune.xyz has applied
old: curvefi.""mim_ust_pool_evt_TokenExchange"", new: curvefi.""MIM_UST_evt_TokenExchange""
old: curvefi.""d3pool_swap_evt_TokenExchange"", new: curvefi.""D3_evt_TokenExchange""

*/

select 

day, 

sum(threepool + aave + alusd + busd + busdv2 + compound + dusd + frax + gusd + husd + ironbank + linkusd + lusd + musd + pax + rsv + saave + susdv2 + tusd + usdk + usdn + usdp + usdt + ust + y + mim + mimust + ustw + fei + origin + dola + d3pool) as usd_total,
sum(threepool) as threepool,
sum(aave) as aave,
sum(alusd) as alusd,
sum(busd) as busd,
sum(busdv2) as busdv2,
sum(compound) as compound,
sum(d3pool) as d3pool,
sum(dola) as dola,
sum(dusd) as dusd,
sum(fei) as fei,
sum(frax) as frax,
sum(gusd) as gusd,
sum(husd) as husd,
sum(ironbank) as ironbank,
sum(linkusd) as linkusd,
sum(lusd) as lusd,
sum(mim) as mim,
sum(mimust) as mimust,
sum(musd) as musd,
sum(origin) as origin,
sum(pax) as pax,
sum(rsv) as rsv,
sum(saave) as saave,
sum(susdv2) as susdv2,
sum(tusd) as tusd,
sum(usdk) as usdk,
sum(usdn) as usdn,
sum(usdp) as usdp,
sum(usdt) as usdt,
sum(ust) as ust,
sum(ustw) as ustw,
sum(y) as y


from (
    -- 3pool
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    end) as threepool,
    0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""threepool_swap_evt_TokenExchange"" as cst
    group by 1

    union
    -- aave
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    end) as aave, 
    0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""aave_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    end) as aave, 
    0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""aave_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- alusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as alusd,
    0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""alusd_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as alusd,
    0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""alusd_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- busd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as busd, 
    0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""busd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as busd, 
    0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""busd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- busdv2
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as busdv2,
    0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""busdv2_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as busdv2,
    0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""busdv2_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- compound
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e8
    when sold_id = 1 then tokens_sold / 1e8
    end) as compound,
    0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""compound_v2_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    end) as compound,
    0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""compound_v2_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day,
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e8
    when sold_id = 1 then tokens_sold / 1e8
    end) as compound,
    0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""compound_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day,
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    end) as compound,
    0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""compound_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- dusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as dusd,
    0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""dusd_swap_evt_TokenExchange"" as cst
    group by 1

    union
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e8
    when sold_id = 3 then tokens_sold / 1e8
    end) as dusd,
    0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""dusd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- frax
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as frax,
    0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""frax_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as frax,
    0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""frax_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- gusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e2
    when sold_id = 1 then tokens_sold / 1e18
    end) as gusd,
    0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""gusd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e2
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as gusd,
    0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""gusd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- husd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e8
    when sold_id = 1 then tokens_sold / 1e18
    end) as husd,
    0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""husd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e8
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as husd,
    0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""husd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- ironbank
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    end) as ironbank,
    0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""ironbank_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- linkusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as linkusd,
    0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""linkusd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as linkusd,
    0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""linkusd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- lusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as lusd,
    0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""lusd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as lusd,
    0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""lusd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- mim
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as mim,
    0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""mim_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as mim,
    0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""mim_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- musd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as musd,
    0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool  
    from curvefi.""musd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as musd,
    0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool  
    from curvefi.""musd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- pax
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as pax, 
    0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""pax_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- rsv
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as rsv,
    0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""rsv_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e8
    when sold_id = 3 then tokens_sold / 1e8
    end) as rsv,
    0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""rsv_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- saave
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as saave,
    0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""saave_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as saave,
    0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""saave_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- susdv2
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as susdv2, 
    0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""susd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as susdv2, 
    0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""susd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- tusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as tusd,
    0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""tusd_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as tusd,
    0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""tusd_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- usdk
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as usdk, 
    0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""usdk_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as usdk, 
    0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""usdk_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- usdn
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as usdn,
    0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdn_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as usdn,
    0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdn_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- usdp
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as usdp,
    0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdp_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as usdp,
    0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdp_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- usdt
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e8
    when sold_id = 1 then tokens_sold / 1e8
    when sold_id = 2 then tokens_sold / 1e6
    end) as usdt, 
    0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdt_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    end) as usdt, 
    0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdt_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- ust
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as ust,
    0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""ust_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as ust,
    0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""ust_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- y
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as y, 0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""y_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as y, 0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""y_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1
    
    union
    -- mimust
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""MIM_UST_evt_TokenExchange"" as cst
    group by 1
    
    union
    -- ustw
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e6
    when sold_id = 1 then tokens_sold / 1e18
    end) as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""wormhole_v2_evt_TokenExchange"" as cst
    group by 1
    
    union
    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e6
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e18
    when sold_id = 3 then tokens_sold / 1e18
    end) as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""wormhole_v2_evt_TokenExchangeUnderlying"" as cst
    group by 1
    
    union
    -- fei    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as fei, 0 as origin, 0 as dola, 0 as d3pool
    from fei_protocol.""Fei3Crv_evt_TokenExchange"" as cst
    group by 1
    
    union
    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e18
    when sold_id = 3 then tokens_sold / 1e18
    end) as fei, 0 as origin, 0 as dola, 0 as d3pool
    from fei_protocol.""Fei3Crv_evt_TokenExchangeUnderlying"" as cst
    group by 1
    
    union
    -- origin
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw, 0 as fei,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as origin, 0 as dola, 0 as d3pool
    from curvefi.""origin_3crv_pool_evt_TokenExchange"" as cst
    group by 1
    
    union
    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw, 0 as fei,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as origin, 0 as dola, 0 as d3pool
    from curvefi.""origin_3crv_pool_evt_TokenExchangeUnderlying"" as cst
    group by 1
    
    union
    -- dola    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw, 0 as fei, 0 as origin,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as dola, 0 as d3pool
    from curvefi.""dola_3crv_pool_evt_TokenExchange"" as cst
    group by 1
    
    union
    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw, 0 as fei, 0 as origin,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e18
    when sold_id = 3 then tokens_sold / 1e18
    end) as dola, 0 as d3pool
    from curvefi.""dola_3crv_pool_evt_TokenExchangeUnderlying"" as cst
    group by 1
    
    
    union
    -- d3pool
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e18
    when sold_id = 3 then tokens_sold / 1e18
    end) as d3pool
    from curvefi.""D3_evt_TokenExchange"" as cst
    group by 1
    
) a group by 1"
366354,Curve VS Uniswap | USD stable to USD stable trading volume per day,,table,"/*

Update log:

20220307 @pandajackson42
change 2 table names to comply with the new table name dune.xyz has applied
old: curvefi.""mim_ust_pool_evt_TokenExchange"", new: curvefi.""MIM_UST_evt_TokenExchange""
old: curvefi.""d3pool_swap_evt_TokenExchange"", new: curvefi.""D3_evt_TokenExchange""

*/

(

SELECT  project,                        
        date_trunc('day', block_time) as day,
        SUM(usd_amount) as volume_daily                                                                              
FROM dex.""trades""
WHERE (project = 'Uniswap')
AND token_a_symbol IN ('USDC', 'USDT', 'DAI', 'MIM', 'UST', 'FRAX', 'LUSD', 'GUSD', 'HUSD', 'mUSD', 'PAX', 'USDP', 'TUSD', 'sUSD', 'ALUSD', 'OUSD', 'DOLA', 'DUSD')
AND token_b_symbol IN ('USDC', 'USDT', 'DAI', 'MIM', 'UST', 'FRAX', 'LUSD', 'GUSD', 'HUSD', 'mUSD', 'PAX', 'USDP', 'TUSD', 'sUSD', 'ALUSD', 'OUSD', 'DOLA', 'DUSD')

GROUP BY 1, 2

)


union

(

select 

'Curve' as project,

day,

sum(threepool + aave + alusd + busd + busdv2 + compound + dusd + frax + gusd + husd + ironbank + linkusd + lusd + musd + pax + rsv + saave + susdv2 + tusd + usdk + usdn + usdp + usdt + ust + y + mim + mimust + ustw + fei + origin + dola + d3pool) as volume_daily


from (
    -- 3pool
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    end) as threepool,
    0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""threepool_swap_evt_TokenExchange"" as cst
    group by 1

    union
    -- aave
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    end) as aave, 
    0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""aave_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    end) as aave, 
    0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""aave_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- alusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as alusd,
    0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""alusd_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as alusd,
    0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""alusd_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- busd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as busd, 
    0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""busd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as busd, 
    0 as busdv2, 0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""busd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- busdv2
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as busdv2,
    0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""busdv2_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as busdv2,
    0 as compound, 0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""busdv2_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- compound
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e8
    when sold_id = 1 then tokens_sold / 1e8
    end) as compound,
    0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""compound_v2_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    end) as compound,
    0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""compound_v2_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day,
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e8
    when sold_id = 1 then tokens_sold / 1e8
    end) as compound,
    0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""compound_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day,
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    end) as compound,
    0 as dusd,0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""compound_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- dusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as dusd,
    0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""dusd_swap_evt_TokenExchange"" as cst
    group by 1

    union
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e8
    when sold_id = 3 then tokens_sold / 1e8
    end) as dusd,
    0 as frax,0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""dusd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- frax
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as frax,
    0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""frax_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as frax,
    0 as gusd, 0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""frax_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- gusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e2
    when sold_id = 1 then tokens_sold / 1e18
    end) as gusd,
    0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""gusd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e2
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as gusd,
    0 as husd, 0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""gusd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- husd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e8
    when sold_id = 1 then tokens_sold / 1e18
    end) as husd,
    0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""husd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e8
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as husd,
    0 as ironbank,0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""husd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- ironbank
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    end) as ironbank,
    0 as linkusd,0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""ironbank_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- linkusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as linkusd,
    0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""linkusd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as linkusd,
    0 as lusd,0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""linkusd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- lusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as lusd,
    0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""lusd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as lusd,
    0 as mim,0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""lusd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- mim
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as mim,
    0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""mim_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as mim,
    0 as musd,0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool     
    from curvefi.""mim_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- musd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as musd,
    0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool  
    from curvefi.""musd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as musd,
    0 as pax,0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool  
    from curvefi.""musd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- pax
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as pax, 
    0 as rsv,0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""pax_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- rsv
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as rsv,
    0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""rsv_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e8
    when sold_id = 3 then tokens_sold / 1e8
    end) as rsv,
    0 as saave,0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""rsv_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- saave
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as saave,
    0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""saave_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as saave,
    0 as susdv2, 0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""saave_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- susdv2
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as susdv2, 
    0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""susd_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as susdv2, 
    0 as tusd,0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""susd_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- tusd
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as tusd,
    0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""tusd_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as tusd,
    0 as usdk, 0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""tusd_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- usdk
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as usdk, 
    0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""usdk_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as usdk, 
    0 as usdn, 0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool 
    from curvefi.""usdk_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- usdn
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as usdn,
    0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdn_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as usdn,
    0 as usdp,0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdn_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- usdp
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as usdp,
    0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdp_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as usdp,
    0 as usdt, 0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdp_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- usdt
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e8
    when sold_id = 1 then tokens_sold / 1e8
    when sold_id = 2 then tokens_sold / 1e6
    end) as usdt, 
    0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdt_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    end) as usdt, 
    0 as ust,0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""usdt_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- ust
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as ust,
    0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""ust_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as ust,
    0 as y,0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""ust_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1

    union
    -- y
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as y, 0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""y_swap_evt_TokenExchange"" as cst
    group by 1

    union

    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e6
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e18
    end) as y, 0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""y_swap_evt_TokenExchangeUnderlying"" as cst
    group by 1
    
    union
    -- mimust
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""MIM_UST_evt_TokenExchange"" as cst
    group by 1
    
    union
    -- ustw
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e6
    when sold_id = 1 then tokens_sold / 1e18
    end) as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""wormhole_v2_evt_TokenExchange"" as cst
    group by 1
    
    union
    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e6
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e18
    when sold_id = 3 then tokens_sold / 1e18
    end) as ustw, 0 as fei, 0 as origin, 0 as dola, 0 as d3pool
    from curvefi.""wormhole_v2_evt_TokenExchangeUnderlying"" as cst
    group by 1
    
    union
    -- fei    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as fei, 0 as origin, 0 as dola, 0 as d3pool
    from fei_protocol.""Fei3Crv_evt_TokenExchange"" as cst
    group by 1
    
    union
    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e18
    when sold_id = 3 then tokens_sold / 1e18
    end) as fei, 0 as origin, 0 as dola, 0 as d3pool
    from fei_protocol.""Fei3Crv_evt_TokenExchangeUnderlying"" as cst
    group by 1
    
    union
    -- origin
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw, 0 as fei,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as origin, 0 as dola, 0 as d3pool
    from curvefi.""origin_3crv_pool_evt_TokenExchange"" as cst
    group by 1
    
    union
    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw, 0 as fei,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e6
    when sold_id = 3 then tokens_sold / 1e6
    end) as origin, 0 as dola, 0 as d3pool
    from curvefi.""origin_3crv_pool_evt_TokenExchangeUnderlying"" as cst
    group by 1
    
    union
    -- dola    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw, 0 as fei, 0 as origin,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    end) as dola, 0 as d3pool
    from curvefi.""dola_3crv_pool_evt_TokenExchange"" as cst
    group by 1
    
    union
    
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw, 0 as fei, 0 as origin,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e18
    when sold_id = 3 then tokens_sold / 1e18
    end) as dola, 0 as d3pool
    from curvefi.""dola_3crv_pool_evt_TokenExchangeUnderlying"" as cst
    group by 1
    
    
    union
    -- d3pool
    select date_trunc('day', evt_block_time) AS day, 
    0 as bbtc, 0 as hbtc, 0 as obtc, 0 as pbtc, 0 as renbtc, 0 as sbtc, 0 as tbtc,
    0 as ankreth, 0 as reth, 0 as seth, 0 as steth,
    0 as tricrypto, 0 as tricrypto2,
    0 as eurs, 0 as link,
    0 as threepool, 0 as aave, 0 as alusd, 0 as busd, 0 as busdv2, 0 as compound, 0 as dusd, 0 as frax, 0 as gusd, 0 as husd, 0 as ironbank, 0 as linkusd, 0 as lusd, 0 as mim, 0 as musd, 0 as pax, 0 as rsv, 0 as saave, 0 as susdv2, 0 as tusd, 0 as usdk, 0 as usdn, 0 as usdp, 0 as usdt, 0 as ust, 0 as y, 0 as mimust, 0 as ustw, 0 as fei, 0 as origin, 0 as dola,
    sum(case 
    when sold_id = 0 then tokens_sold / 1e18
    when sold_id = 1 then tokens_sold / 1e18
    when sold_id = 2 then tokens_sold / 1e18
    when sold_id = 3 then tokens_sold / 1e18
    end) as d3pool
    from curvefi.""D3_evt_TokenExchange"" as cst
    group by 1
    
) a group by 2

)

ORDER BY 2"
366398,Uniswap V3 | USD stable to USD stable swap daily volume by pair,,table,"SELECT  
        date_trunc('day', block_time),
        (CASE exchange_contract_address
            WHEN '\x064880be0b82d07f5476653e3ceb1dbcd14be40b' THEN 'USDC-USDP'
            WHEN '\x10581399a549dbfffdbd9b070a0ba2f9f61620d2' THEN 'FRAX-USDC'
            WHEN '\x129360c964e2e13910d603043f6287e5e9383374' THEN 'OUSD-USDT'
            WHEN '\x16980c16811bde2b3358c1ce4341541a4c772ec9' THEN 'DAI-LUSD'
            WHEN '\x18d96b617a3e5c42a2ada4bc5d1b48e223f17d0d' THEN 'USDC-UST'
            WHEN '\x1e8f1568b598908785064809ebf5745004ce3962' THEN 'TUSD-USDT'
            WHEN '\x1e9934db2730e14d89a1516c534612b6806d55b1' THEN 'DAI-DOLA'
            WHEN '\x24b272eacf72cbf561dfdb88d49874cde287b5d2' THEN 'MIM-USDC'
            WHEN '\x298b7c5e0770d151e4c5cf6cca4dae3a3ffc8e27' THEN 'MIM-USDC'
            WHEN '\x3416cf6c708da44db2624d63ea0aaef7113527c6' THEN 'USDC-USDT'
            WHEN '\x34ff465ee92516e9855eb60f520df0384f410b45' THEN 'FRAX-sUSD'
            WHEN '\x3c1b69b1a15d15b95a4b6525db43f0b3afcfffaf' THEN 'USDP-USDT'
            WHEN '\x3f1a6182af41665e6d261efc895335f70e49b443' THEN 'USDP-USDT'
            WHEN '\x4cf503c67ad0546767da4325742f8c1ca388cec3' THEN 'DOLA-USDT'
            WHEN '\x4e0924d3a751be199c426d52fb1f2337fa96f736' THEN 'LUSD-USDC'
            WHEN '\x54d0975f8667a5527e07a30d00da6832886c8fdb' THEN 'MIM-UST'
            WHEN '\x5720eb958685deeeb5aa0b34f677861ce3a8c7f5' THEN 'USDC-USDP'
            WHEN '\x5777d92f208679db4b9778590fa3cab3ac9e2168' THEN 'DAI-USDC'
            WHEN '\x5c09448abfdcb638ea992ce3e45bbc1d7ec7c4cf' THEN 'LUSD-USDT'
            WHEN '\x6572ab2843069aeb3e7246ce6f9b67f747b86ad8' THEN 'USDP-USDT'
            WHEN '\x67e887913b13e280538c169f13d169a659a203de' THEN 'LUSD-USDT'
            WHEN '\x6958686b6348c3d6d5f2dca3106a5c09c156873a' THEN 'DAI-USDC'
            WHEN '\x69dda571a9bbba1f4fb9e5de066a3fcf06d26ad2' THEN 'MIM-USDT'
            WHEN '\x6a9850e46518231b23e50467c975fa94026be5d5' THEN 'USDC-sUSD'
            WHEN '\x6c6bc977e13df9b0de53b251522280bb72383700' THEN 'DAI-USDC'
            WHEN '\x6f48eca74b38d2936b02ab603ff4e36a6c0e3a77' THEN 'DAI-USDT'
            WHEN '\x7335118ece5464167ec940c4dba3291d1484e00f' THEN 'DAI-USDP'
            WHEN '\x7858e59e0c01ea06df3af3d20ac7b0003275d4bf' THEN 'USDC-USDT'
            WHEN '\x7c082bf85e01f9bb343dbb460a14e51f67c58cfb' THEN 'DOLA-USDC'
            WHEN '\x7cebafc6fd780c266c25329138b56bfe251c8f86' THEN 'DAI-alUSD'
            WHEN '\x7cf12cef5ce9e5e068ebdef470ff8295e26c47b9' THEN 'DAI-GUSD'
            WHEN '\x868b7bbbfe148516e5397f23982923686182c2d2' THEN 'USDT-UST'
            WHEN '\x88416bd15e3ef6493aa539a22e0ed12a1e9663e3' THEN 'FRAX-UST'
            WHEN '\x92995d179a5528334356cb4dc5c6cbb1c068696c' THEN 'USDC-UST'
            WHEN '\x93f267fd92b432bebf4da4e13b8615bb8eb2095c' THEN 'GUSD-USDC'
            WHEN '\x951c82acc7374c5718c149e746d00c0605d7a69d' THEN 'GUSD-USDT'
            WHEN '\x973a67726227ce2747d5710eb44a53fb9abfd02a' THEN 'DAI-UST'
            WHEN '\x97e7d56a0408570ba1a7852de36350f7713906ec' THEN 'DAI-FRAX'
            WHEN '\x9902affdd3b8ef60304958c60377110c6d6ab1df' THEN 'LUSD-USDC'
            WHEN '\x9992c7e0ed14931ddd5bb68e5649c07b13267cb1' THEN 'DAI-DOLA'
            WHEN '\xa63b490aa077f541c9d64bfc1cc0db2a752157b5' THEN 'DAI-USDC'
            WHEN '\xa6de8dbae7b2504a7bec7b0dc7783e46565e9f75' THEN 'USDC-USDP'
            WHEN '\xb65fc555b0e970b16329a48e45cfa14fce9a36a4' THEN 'DAI-USDP'
            WHEN '\xba6f08adb52badc392d803e70d48c8071734131e' THEN 'DAI-sUSD'
            WHEN '\xbb256c2f1b677e27118b0345fd2b3894d2e6d487' THEN 'USDC-USDT'
            WHEN '\xbcc2adccd4de0b2656179f729c98c39dcd68c84d' THEN 'DAI-LUSD'
            WHEN '\xc2a856c3aff2110c1171b8f942256d40e980c726' THEN 'FRAX-USDT'
            WHEN '\xc63b0708e2f7e69cb8a1df0e1389a98c35a76d52' THEN 'FRAX-USDC'
            WHEN '\xc891f68bff4b020a41279321a31137dd2e535fa5' THEN 'MIM-USDC'
            WHEN '\xd275bdd4290538e1f834b00f03457889153084a4' THEN 'DAI-MIM'
            WHEN '\xdcebd5d749e1e2b476f4fcefc20fb1caba793b0c' THEN 'DAI-GUSD'
            WHEN '\xdd960b52ea78a2602bf56e2a0f1563740210c57c' THEN 'DAI-sUSD'
            WHEN '\xe55e68925809784c8234dfcf6f8fa42c3a48b2c3' THEN 'TUSD-USDC'
            WHEN '\xe6e14be906c1f1b438da2010b38beca14b387231' THEN 'MIM-USDT'
            WHEN '\xee4cf3b78a74affa38c6a926282bcd8b5952818d' THEN 'USDC-USDT'
            WHEN '\xf1ddc084500fc774bb835f412aea908259b55ce4' THEN 'FRAX-LUSD'
            WHEN '\x12d6867fa648d269835cf69b49f125147754b54d' THEN 'USDC-UST'
            WHEN '\x39529e96c28807655b5856b3d342c6225111770e' THEN 'TUSD-USDC'
            WHEN '\x668fd4a51bc62dfc83cf5439ee5fda897a8733c6' THEN 'USDC-UST'
            WHEN '\xa87b2ff0759f5b82c7ec86444a70f25c6bffccbf' THEN 'USDC-UST'
            WHEN '\xbed966ba1d08c9c3fe77bd7f0ad7af22d0cccf9a' THEN 'USDC-UST'
            WHEN '\xd4bda8d3f3fa647caefad00032d0908547e00e9c' THEN 'TUSD-USDT'
            ELSE 'new pair detected'
        END)
        as fee_tier,
        SUM(usd_amount) as volume_daily
        
FROM dex.""trades""
WHERE (project = 'Uniswap')
AND exchange_contract_address in ('\x064880be0b82d07f5476653e3ceb1dbcd14be40b','\x10581399a549dbfffdbd9b070a0ba2f9f61620d2','\x129360c964e2e13910d603043f6287e5e9383374','\x12d6867fa648d269835cf69b49f125147754b54d','\x16980c16811bde2b3358c1ce4341541a4c772ec9','\x18d96b617a3e5c42a2ada4bc5d1b48e223f17d0d','\x1e8f1568b598908785064809ebf5745004ce3962','\x1e9934db2730e14d89a1516c534612b6806d55b1','\x24b272eacf72cbf561dfdb88d49874cde287b5d2','\x298b7c5e0770d151e4c5cf6cca4dae3a3ffc8e27','\x3416cf6c708da44db2624d63ea0aaef7113527c6','\x34ff465ee92516e9855eb60f520df0384f410b45','\x39529e96c28807655b5856b3d342c6225111770e','\x3c1b69b1a15d15b95a4b6525db43f0b3afcfffaf','\x3f1a6182af41665e6d261efc895335f70e49b443','\x4cf503c67ad0546767da4325742f8c1ca388cec3','\x4e0924d3a751be199c426d52fb1f2337fa96f736','\x54d0975f8667a5527e07a30d00da6832886c8fdb','\x5720eb958685deeeb5aa0b34f677861ce3a8c7f5','\x5777d92f208679db4b9778590fa3cab3ac9e2168','\x5c09448abfdcb638ea992ce3e45bbc1d7ec7c4cf','\x6572ab2843069aeb3e7246ce6f9b67f747b86ad8','\x668fd4a51bc62dfc83cf5439ee5fda897a8733c6','\x67e887913b13e280538c169f13d169a659a203de','\x6958686b6348c3d6d5f2dca3106a5c09c156873a','\x69dda571a9bbba1f4fb9e5de066a3fcf06d26ad2','\x6a9850e46518231b23e50467c975fa94026be5d5','\x6c6bc977e13df9b0de53b251522280bb72383700','\x6f48eca74b38d2936b02ab603ff4e36a6c0e3a77','\x7335118ece5464167ec940c4dba3291d1484e00f','\x7858e59e0c01ea06df3af3d20ac7b0003275d4bf','\x7c082bf85e01f9bb343dbb460a14e51f67c58cfb','\x7cebafc6fd780c266c25329138b56bfe251c8f86','\x7cf12cef5ce9e5e068ebdef470ff8295e26c47b9','\x868b7bbbfe148516e5397f23982923686182c2d2','\x88416bd15e3ef6493aa539a22e0ed12a1e9663e3','\x92995d179a5528334356cb4dc5c6cbb1c068696c','\x93f267fd92b432bebf4da4e13b8615bb8eb2095c','\x951c82acc7374c5718c149e746d00c0605d7a69d','\x973a67726227ce2747d5710eb44a53fb9abfd02a','\x97e7d56a0408570ba1a7852de36350f7713906ec','\x9902affdd3b8ef60304958c60377110c6d6ab1df','\x9992c7e0ed14931ddd5bb68e5649c07b13267cb1','\xa63b490aa077f541c9d64bfc1cc0db2a752157b5','\xa6de8dbae7b2504a7bec7b0dc7783e46565e9f75','\xa87b2ff0759f5b82c7ec86444a70f25c6bffccbf','\xb65fc555b0e970b16329a48e45cfa14fce9a36a4','\xba6f08adb52badc392d803e70d48c8071734131e','\xbb256c2f1b677e27118b0345fd2b3894d2e6d487','\xbcc2adccd4de0b2656179f729c98c39dcd68c84d','\xbed966ba1d08c9c3fe77bd7f0ad7af22d0cccf9a','\xc2a856c3aff2110c1171b8f942256d40e980c726','\xc63b0708e2f7e69cb8a1df0e1389a98c35a76d52','\xc891f68bff4b020a41279321a31137dd2e535fa5','\xd275bdd4290538e1f834b00f03457889153084a4','\xd4bda8d3f3fa647caefad00032d0908547e00e9c','\xdcebd5d749e1e2b476f4fcefc20fb1caba793b0c','\xdd960b52ea78a2602bf56e2a0f1563740210c57c','\xe55e68925809784c8234dfcf6f8fa42c3a48b2c3','\xe6e14be906c1f1b438da2010b38beca14b387231','\xee4cf3b78a74affa38c6a926282bcd8b5952818d','\xf1ddc084500fc774bb835f412aea908259b55ce4')
GROUP BY 1,2
ORDER BY 1"
10690,DEX active users 24h,,chart,"SELECT a.project,
        count(DISTINCT a.trader) traders 
FROM
  (SELECT a.trader_a trader, a.project 
   FROM dex.trades a 
    WHERE a.block_time >= now() - interval '24 hours'
   UNION
   SELECT a.trader_b trader, a.project
   FROM dex.trades a
    WHERE a.block_time >= now() - interval '24 hours'
   ) a
  
GROUP BY 1
ORDER BY 2 DESC;"
3359,token on Uniswap trade volumn 24hours,,table,"/*
SELECT pur.contract_address,
case pur.contract_address when '\x05cde89ccfa0ada8c88d5a23caaa79ef129e7883' then 'HEX' 
when '\x64a9edd3f5fce0252cd708e26c8dd11205742826' then 'ANJ'
when '\xfc96e234d4b31c63051e707105fcc4aba37807fa' then 'UBT'
else erc.symbol end as symbol,
sum(eth_sold/1e18) FROM uniswap.""Exchange_evt_TokenPurchase"" pur 
left join uniswap.""Factory_evt_NewExchange"" ex on ex.exchange = pur.contract_address
left join erc20.""tokens"" erc on erc.contract_address = ex.token
where pur.evt_block_time > now() - interval '1 day'
group by 1,2
having sum(eth_sold/1e18) > 1
order by 3 desc
limit 10;
*/

with trade as (
select t.exchange_address,t.token_symbol,sum(t.usd_value_of_eth) volum from uniswap_v1.view_eth_purchase t
where t.block_time > now() - interval '1 day'
group by 1,2
union
select t.exchange_address,t.token_symbol,sum(t.usd_value_of_eth) volum from uniswap_v1.view_token_purchase t
where t.block_time > now() - interval '1 day'
group by 1,2

)

select t.exchange_address,
case t.exchange_address when '\x05cde89ccfa0ada8c88d5a23caaa79ef129e7883' then 'HEX' 
when '\x64a9edd3f5fce0252cd708e26c8dd11205742826' then 'ANJ'
when '\xfc96e234d4b31c63051e707105fcc4aba37807fa' then 'UBT'
else t.token_symbol end as token_symbol,
sum(t.volum) 成交量
from trade t  
--where t.block_time > now()- interval '1 day'
group by 1,2
order by 3 desc
limit 10

--select * from uniswap.""Factory_evt_NewExchange"" ex where ex.exchange = '\x05cde89ccfa0ada8c88d5a23caaa79ef129e7883'
/*
select * from erc20.""tokens"" t where t.contract_address = '6b175474e89094c44da98b954eedeac495271d0f'--exchange
select * from uniswap.""Factory_evt_NewExchange"" ex where ex.token = '\x9f8f72aa9304c8b593d555f12ef6589cc3a579a2';
*/
"
13922,Uniswap daily unique users,,chart,"SELECT  a.day,
        COUNT(DISTINCT a.trader) AS traders 
FROM
  (SELECT date_trunc('day',block_time) AS day,
          a.trader_a AS trader
   FROM dex.trades a 
   WHERE project = 'Uniswap' AND version = '2'
   UNION
   SELECT date_trunc('day',block_time) AS day,
         a.trader_b AS trader
   FROM dex.trades a 
   WHERE project = 'Uniswap' AND version = '2'
   ) a
   WHERE a.day >= now() - interval '6 months'
GROUP BY 1
;"
233623,Uniswap v3 JIT Liquidity MEV Transactions,,chart,"SELECT
    t.*,
    AVG (profit_usd / cost_usd) over (order by time rows between 24 preceding and current row) as profit_margin_smooth_24,
    AVG (profit_usd / cost_usd) over (order by time rows between 72 preceding and current row) as profit_margin_smooth_72,
    
    AVG (profit_usd / (cost_usd * .1)) over (order by time rows between 24 preceding and current row) as profit_margin_L2_smooth_24,
    AVG (profit_usd / (cost_usd * .1)) over (order by time rows between 72 preceding and current row) as profit_margin_L2_smooth_72,
    
 --   AVG (IF (cost_usd <= 0, 0, profit_usd / cost_usd)) over (order by time rows between 24 preceding and current row) as profit_margin_smooth_24,
    SUM (profit_usd) OVER (ORDER BY time) as culm_profit,
    SUM (cost_usd) OVER (ORDER BY time) as culm_cost,
    SUM (revenue_usd) OVER (ORDER BY time) as culm_revenue
FROM
(
    SELECT
        DISTINCT
        add.""call_block_time"" as time,
        tx_add.""from"",
        tx_add.""to"",
        add.call_block_number as block_number,
        add.""call_tx_hash"" as add_hash,
        remove.""call_tx_hash"" as remove_hash,
        
        add_liq.""amount0"" as add_amount0,
        add_liq.""amount1"" as add_amount1,
        
        add_liq.""amount0"" / 10 ^ p0.decimals * p0.median_price as add_amount0_usd,
        add_liq.""amount1"" / 10 ^ p1.decimals * p1.median_price as add_amount1_usd,
        
        token0.""contract_address"" as token0_address,
        token1.""contract_address"" as token1_address,
        
        p0.median_price,
        p1.median_price,
        
        collect.""amount0"" as remove_amount0,
        collect.""amount1"" as remove_amount1,
        
        collect.""amount0"" / 10 ^ p0.decimals * p0.median_price as remove_amount0_usd,
        collect.""amount1"" / 10 ^ p1.decimals * p1.median_price as remove_amount1_usd,
        
        (collect.""amount0"" / 10 ^ p0.decimals * p0.median_price - add_liq.""amount0"" / 10 ^ p0.decimals * p0.median_price) + (collect.""amount1"" / 10 ^ p1.decimals * p1.median_price - add_liq.""amount1"" / 10 ^ p1.decimals * p1.median_price) as revenue_usd,
        
        CASE
            WHEN tx_add.gas_price != 0 THEN tx_add.gas_used * tx_add.gas_price * weth_price.median_price / 10 ^ 18
            ELSE 0
        END add_cost_usd,
        
        CASE
            WHEN tx_add.gas_price != 0 THEN tx_remove.gas_used * tx_remove.gas_price * weth_price.median_price / 10 ^ 18
            ELSE eth_miner_bribe.value * weth_price.median_price / 10 ^ 18
        END remove_cost_usd,
        
        CASE
            WHEN tx_add.gas_price != 0 THEN tx_add.gas_used * tx_add.gas_price * weth_price.median_price / 10 ^ 18 + tx_remove.gas_used * tx_remove.gas_price * weth_price.median_price / 10 ^ 18  + (eth_miner_bribe.value * weth_price.median_price / 10 ^ 18)
            ELSE eth_miner_bribe.value * weth_price.median_price / 10 ^ 18
        END cost_usd,
    
        CASE
            WHEN tx_add.gas_price != 0 THEN
            (collect.""amount0"" / 10 ^ p0.decimals * p0.median_price - add_liq.""amount0"" / 10 ^ p0.decimals * p0.median_price) + (collect.""amount1"" / 10 ^ p1.decimals * p1.median_price - add_liq.""amount1"" / 10 ^ p1.decimals * p1.median_price) 
                - (tx_add.gas_used * tx_add.gas_price * weth_price.median_price / 10 ^ 18 + tx_remove.gas_used * tx_remove.gas_price * weth_price.median_price / 10 ^ 18) - eth_miner_bribe.value * weth_price.median_price / 10 ^ 18
            ELSE
            (collect.""amount0"" / 10 ^ p0.decimals * p0.median_price - add_liq.""amount0"" / 10 ^ p0.decimals * p0.median_price) + (collect.""amount1"" / 10 ^ p1.decimals * p1.median_price - add_liq.""amount1"" / 10 ^ p1.decimals * p1.median_price) 
                - eth_miner_bribe.value * weth_price.median_price / 10 ^ 18
        END profit_usd
        
    --    ""output_tokenId""
    --    tokenURI.""output_0""
    FROM uniswap_v3.""NonfungibleTokenPositionManager_call_burn"" remove
    INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_call_mint"" add ON add.call_block_number = remove.call_block_number and 
                                                                             add.""output_tokenId"" = remove.""tokenId""
                                                        
    INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_evt_Collect"" collect on remove.""call_tx_hash"" = collect.evt_tx_hash AND remove.""tokenId"" = collect.""tokenId""
    INNER JOIN uniswap_v3.""NonfungibleTokenPositionManager_evt_IncreaseLiquidity"" add_liq ON add_liq.evt_tx_hash = add.call_tx_hash
    
    LEFT JOIN erc20.""ERC20_evt_Transfer"" token0 ON token0.value = add_liq.""amount0""and token0.""evt_tx_hash"" = add_liq.""evt_tx_hash"" 
    LEFT JOIN erc20.""ERC20_evt_Transfer"" token1 ON token1.value = add_liq.""amount1""and token1.""evt_tx_hash"" = add_liq.""evt_tx_hash"" 
    
    LEFT JOIN prices.prices_from_dex_data p0 ON p0.""contract_address"" = token0.""contract_address"" AND p0.hour = date_trunc('hour', token0.evt_block_time)
    LEFT JOIN prices.prices_from_dex_data p1 ON p1.""contract_address"" = token1.""contract_address"" AND p1.hour = date_trunc('hour', token1.evt_block_time)
    
    LEFT JOIN prices.prices_from_dex_data weth_price ON weth_price.symbol = 'WETH' AND weth_price.hour = date_trunc('hour', add.call_block_time)
    
    INNER JOIN ethereum.transactions tx_add ON tx_add.hash = add.call_tx_hash
    INNER JOIN ethereum.transactions tx_remove ON tx_remove.hash = remove.call_tx_hash
    
    INNER JOIN ethereum.blocks block on tx_remove.block_number = block.""number""
    
    -- pre eip, there might be a bribe
    LEFT JOIN  ethereum.traces eth_miner_bribe ON eth_miner_bribe.tx_hash = remove.""call_tx_hash"" AND eth_miner_bribe.success = True AND eth_miner_bribe.""to"" = block.miner AND (call_type NOT IN ('delegatecall', 'callcode', 'staticcall') OR call_type IS null)
    
    
    WHERE token0.contract_address IS NOT NULL 
        AND token1.contract_address IS NOT NULL

) t
WHERE cost_usd != 0
ORDER BY 1 DESC





--uniswap_v3.""NonfungibleTokenPositionManager_call_uniswapV3MintCallback"""
7972,Uniswap USD liquidity,,table,"WITH prices AS (                                                                                     
    SELECT  minute,                                                         
            contract_address,                                                                              
            price                                                                                
    FROM prices.usd
) 
,v3_pools as (
SELECT pool, token0, token1
FROM uniswap_v3.""Factory_evt_PoolCreated""
)
,recent_transfers AS (
SELECT contract_address, value, ""from"", ""to"", evt_block_time
FROM erc20.""ERC20_evt_Transfer""
WHERE evt_block_time > '2021-04-01'
)
,transfers_to as (
SELECT contract_address as token_address, ""to"" as pool, SUM(value) as delta, date_trunc('day', evt_block_time) as day
FROM recent_transfers t
WHERE ""to"" IN (SELECT pool FROM v3_pools)
GROUP BY day, token_address, pool
)
,transfers_from as (
SELECT contract_address as token_address, ""from"" as pool, SUM(-1 * value) as delta, date_trunc('day', evt_block_time) as day
FROM recent_transfers t
WHERE ""from"" IN (SELECT pool FROM v3_pools)
GROUP BY day, token_address, pool
)
,day_deltas AS (SELECT SUM(delta) as delta, token_address, day
FROM 
(SELECT * FROM transfers_to
UNION ALL
SELECT * FROM transfers_from
) t
GROUP BY token_address, day
)
,balances AS (SELECT SUM(delta) OVER (PARTITION BY token_address ORDER BY day) as balance, token_address, day, price, decimals, symbol FROM day_deltas d
INNER JOIN prices pr ON d.token_address=pr.contract_address AND d.day=pr.minute
INNER JOIN erc20.tokens t ON d.token_address=t.contract_address)
,v3_liquidity AS (SELECT token_address, symbol, day, (balance / CAST(POWER(10, decimals) AS NUMERIC)) * price as usd_value
FROM balances b
ORDER BY token_address, day)
,v2_liquidity as (WITH syncs AS (SELECT DISTINCT ON (pair, day)
    syncs.contract_address as pair, pairs.token0, pairs.token1, reserve0, reserve1, syncs.evt_block_time as block_time, date_trunc('day', syncs.evt_block_time) as day
FROM uniswap_v2.""Pair_evt_Sync"" as syncs
INNER JOIN uniswap_v2.""Factory_evt_PairCreated"" as pairs ON syncs.contract_address=pairs.pair
ORDER BY pair, day, block_time)
SELECT
    day,
    SUM(
        CASE WHEN token0 = a.contract_address AND token0 = c.contract_address THEN 2 * reserve0 * a.price / power(10, c.decimals)     -- Use token0 when there's USD price for it                    
        ELSE 2 * reserve1 * b.price / power(10, d.decimals)                                -- Else use token1                             
        END   
        ) AS usd_value
FROM syncs
LEFT JOIN prices a ON date_trunc('minute', block_time) = a.minute AND token0 = a.contract_address -- Joining with prices on time and token address for token A
LEFT JOIN prices b ON date_trunc('minute', block_time) = b.minute AND token1 = b.contract_address -- Joining with prices on time and token address for token B
LEFT JOIN erc20.tokens c ON token0 = c.contract_address
LEFT JOIN erc20.tokens d ON token1 = d.contract_address
GROUP BY day
ORDER BY day), v1_liquidity as (
WITH deltas as (SELECT evt_block_time, -eth_bought as eth_delta FROM uniswap.""Exchange_evt_EthPurchase""
UNION ALL
SELECT evt_block_time, eth_sold as eth_delta FROM uniswap.""Exchange_evt_TokenPurchase""
UNION ALL
SELECT evt_block_time, -eth_amount as eth_delta FROM uniswap.""Exchange_evt_RemoveLiquidity""
UNION ALL
SELECT evt_block_time, eth_amount as eth_delta FROM uniswap.""Exchange_evt_AddLiquidity""), eth_liquidity as
(SELECT DISTINCT ON (day)
      date_trunc('day', evt_block_time) as day, 2 * SUM(eth_delta / POWER(10,18)) OVER (ORDER BY evt_block_time) as eth_value
FROM deltas
ORDER BY day)
SELECT day, eth_value * price as usd_value FROM eth_liquidity
LEFT JOIN prices.layer1_usd_eth as eth_price ON eth_price.minute = day
)
SELECT day, SUM(usd_value) as usd_value, 'v1' as version FROM v1_liquidity GROUP BY day
UNION ALL
SELECT day, SUM(usd_value) as usd_value, 'v2' as version FROM v2_liquidity GROUP BY day
UNION ALL
SELECT day, SUM(usd_value) as usd_value, 'v3' as version FROM v3_liquidity GROUP BY day"
8033,Uniswap pairs,,table,"SELECT evt_block_time, 
       COUNT(*) filter (WHERE uniswap_version='v1') OVER (ORDER BY evt_block_time) as v1_pairs,
       COUNT(*) filter (WHERE uniswap_version='v2') OVER (ORDER BY evt_block_time) as v2_pairs
FROM
(SELECT 'v2' as uniswap_version, evt_block_time FROM uniswap_v2.""Factory_evt_PairCreated""
UNION ALL
SELECT 'v1' as uniswap_version, evt_block_time FROM uniswap.""Factory_evt_NewExchange""
ORDER BY evt_block_time) as creations"
8014,Uniswap unique liquidity providers,,chart,"WITH deltas as ((SELECT evt_block_time, evt_index, ""from"" as lp, -value as delta, contract_address as pair, 'v2' as uniswap_version
    FROM uniswap_v2.""Pair_evt_Transfer"")
    UNION ALL
    (SELECT evt_block_time, evt_index, ""to"" as lp, value as delta, contract_address as pair, 'v2' as uniswap_version
    FROM uniswap_v2.""Pair_evt_Transfer"")
    UNION ALL
    (SELECT evt_block_time, evt_index, ""_from"" as lp, -_value as delta, contract_address as pair, 'v1' as uniswap_version
    FROM uniswap.""Exchange_evt_Transfer"")
    UNION ALL
    (SELECT evt_block_time, evt_index, ""_to"" as lp, _value as delta, contract_address as pair, 'v1' as uniswap_version
    FROM uniswap.""Exchange_evt_Transfer"")), balances as (SELECT *, SUM(delta) OVER (
    PARTITION BY lp, pair
    ORDER BY evt_block_time, evt_index
    ) as balance FROM deltas ORDER BY evt_block_time, evt_index, delta), delta_pools as 
    (SELECT *, (CASE 
        WHEN delta = 0 OR lp = '\x0000000000000000000000000000000000000000' THEN 0
        WHEN delta = balance THEN 1
        WHEN balance = 0 THEN -1
        ELSE 0
        END) as delta_pools FROM balances), lp_pools as
    (SELECT *, 
    SUM(CASE WHEN uniswap_version='v1' THEN delta_pools ELSE 0 END) OVER (PARTITION BY lp ORDER BY evt_block_time, evt_index) as lp_v1_pools,
    SUM(CASE WHEN uniswap_version='v2' THEN delta_pools ELSE 0 END) OVER (PARTITION BY lp ORDER BY evt_block_time, evt_index) as lp_v2_pools
    FROM delta_pools), delta_lps as (SELECT *, (CASE 
        WHEN uniswap_version='v2' OR lp_v2_pools != 0 THEN 0
        WHEN lp_v1_pools = 1 AND delta_pools = 1 THEN 1
        WHEN lp_v1_pools = 0 AND delta_pools = -1 THEN -1
        ELSE 0
        END) as delta_v1_lps,
        (CASE 
        WHEN uniswap_version='v1' OR lp_v1_pools != 0 THEN 0
        WHEN lp_v2_pools = 1 AND delta_pools = 1 THEN 1
        WHEN lp_v2_pools = 0 AND delta_pools = -1 THEN -1
        ELSE 0
        END) as delta_v2_lps,
        (CASE 
        WHEN uniswap_version='v2' AND lp_v1_pools != 0 AND lp_v2_pools = 1 AND delta_pools = 1 THEN 1
        WHEN uniswap_version='v1' AND lp_v2_pools != 0 AND lp_v1_pools = 1 AND delta_pools = 1 THEN 1
        WHEN uniswap_version='v2' AND lp_v1_pools != 0 AND lp_v2_pools = 0 AND delta_pools = -1 THEN -1
        WHEN uniswap_version='v1' AND lp_v2_pools != 0 AND lp_v1_pools = 0 AND delta_pools = -1 THEN -1
        ELSE 0
        END) as delta_both_lps
        FROM lp_pools), lps as
    (SELECT *, 
        date_trunc('day', evt_block_time) as day, 
        SUM(delta_v1_lps) OVER (ORDER BY evt_block_time, evt_index) as v1_lps, 
        SUM(delta_v2_lps) OVER (ORDER BY evt_block_time, evt_index) as v2_lps,
        SUM(delta_both_lps) OVER (ORDER BY evt_block_time, evt_index) as both_lps
    FROM delta_lps
    WHERE delta_v1_lps != 0 OR delta_v2_lps != 0 OR delta_both_lps != 0
    ORDER BY evt_block_time, evt_index)
    SELECT DISTINCT ON (day) day, v1_lps, v2_lps, both_lps
    FROM lps
    ORDER BY day, evt_block_time"
8023,Uniswap liquidity mints + burns,,table,"SELECT *
FROM (
SELECT 'v1_mint' as event_type, date_trunc('month', evt_block_time) as month, COUNT(*) FROM uniswap.""Exchange_evt_AddLiquidity"" GROUP BY month
UNION ALL
SELECT 'v1_burn' as event_type, date_trunc('month', evt_block_time) as month, COUNT(*) FROM uniswap.""Exchange_evt_RemoveLiquidity"" GROUP BY month
UNION ALL
SELECT 'v2_mint' as event_type, date_trunc('month', evt_block_time) as month, COUNT(*) FROM uniswap_v2.""Pair_evt_Mint"" GROUP BY month
UNION ALL
SELECT 'v2_burn' as event_type, date_trunc('month', evt_block_time) as month, COUNT(*) FROM uniswap_v2.""Pair_evt_Burn"" GROUP BY month
) as liq_events
ORDER BY month
"
7964,Uniswap unique trading addresses,,table,"WITH tos as (SELECT ""to"", date_trunc('month', call_block_time) as month, 'v2' as version FROM uniswap_v2.""Router02_call_swapETHForExactTokens""
UNION ALL
SELECT ""to"", date_trunc('month', call_block_time) as month, 'v2' as version FROM uniswap_v2.""Router02_call_swapExactETHForTokens""
UNION ALL
SELECT ""to"", date_trunc('month', call_block_time) as month, 'v2' as version FROM uniswap_v2.""Router02_call_swapExactETHForTokensSupportingFeeOnTransferToken""
UNION ALL
SELECT ""to"", date_trunc('month', call_block_time) as month, 'v2' as version FROM uniswap_v2.""Router02_call_swapExactTokensForETH""
UNION ALL
SELECT ""to"", date_trunc('month', call_block_time) as month, 'v2' as version FROM uniswap_v2.""Router02_call_swapExactTokensForETHSupportingFeeOnTransferToken""
UNION ALL
SELECT ""to"", date_trunc('month', call_block_time) as month, 'v2' as version FROM uniswap_v2.""Router02_call_swapExactTokensForTokens""
UNION ALL
SELECT ""to"", date_trunc('month', call_block_time) as month, 'v2' as version FROM uniswap_v2.""Router02_call_swapExactTokensForTokensSupportingFeeOnTransferTo""
UNION ALL
SELECT ""to"", date_trunc('month', call_block_time) as month, 'v2' as version FROM uniswap_v2.""Router02_call_swapTokensForExactETH""
UNION ALL
SELECT ""to"", date_trunc('month', call_block_time) as month, 'v2' as version FROM uniswap_v2.""Router02_call_swapTokensForExactTokens""
UNION ALL
SELECT ""to"", date_trunc('month', call_block_time) as month, 'v2' as version FROM uniswap_v2.""Router01_call_swapETHForExactTokens""
UNION ALL
SELECT ""to"", date_trunc('month', call_block_time) as month, 'v2' as version FROM uniswap_v2.""Router01_call_swapExactETHForTokens""
UNION ALL
SELECT ""to"", date_trunc('month', call_block_time) as month, 'v2' as version FROM uniswap_v2.""Router01_call_swapExactTokensForETH""
UNION ALL
SELECT ""to"", date_trunc('month', call_block_time) as month, 'v2' as version FROM uniswap_v2.""Router01_call_swapExactTokensForTokens""
UNION ALL
SELECT ""to"", date_trunc('month', call_block_time) as month, 'v2' as version FROM uniswap_v2.""Router01_call_swapTokensForExactETH""
UNION ALL
SELECT ""to"", date_trunc('month', call_block_time) as month, 'v2' as version FROM uniswap_v2.""Router01_call_swapTokensForExactTokens""
UNION ALL
SELECT ""to"", date_trunc('month', evt_block_time) as month, 'v2' as version FROM uniswap_v2.""Pair_evt_Swap""
UNION ALL
SELECT buyer as ""to"", date_trunc('month', evt_block_time) as month, 'v1' as version FROM uniswap.""Exchange_evt_TokenPurchase""
UNION ALL
SELECT buyer as ""to"", date_trunc('month', evt_block_time) as month, 'v1' as version FROM uniswap.""Exchange_evt_EthPurchase""
), counts as (SELECT ""to"", month, COUNT(*) filter (WHERE version='v1') as v1_trades, COUNT(*) filter (WHERE version='v2') as v2_trades
FROM tos
GROUP BY ""to"", month)
SELECT month,
       COUNT(*) filter (WHERE v1_trades > 0 AND v2_trades > 0) as both, 
       COUNT(*) filter (WHERE v1_trades > 0 AND v2_trades = 0) as v1,
       COUNT(*) filter (WHERE v1_trades = 0 AND v2_trades > 0) as v2
FROM counts
GROUP BY month"
20171,Uniswap USD Volume,,table,"SELECT date_trunc('month', block_time) AS month,
       SUM( usd_amount ) AS usd_volume,
       CASE
           WHEN VERSION = '1' THEN 'v1'
           WHEN VERSION = '2' THEN 'v2'
           ELSE 'v3'
       END AS uniswap_version
FROM dex.""trades"" t
WHERE project='Uniswap'
GROUP BY MONTH,
         uniswap_version;"
8086,Cumulative Uniswap volume,,chart,"SELECT DAY,
       uniswap_version,
       SUM(usd_volume) OVER (PARTITION BY uniswap_version
                             ORDER BY DAY) AS cumulative_usd_volume
FROM
  (SELECT date_trunc('day', block_time) AS DAY,
          (CASE
               WHEN VERSION = '1' THEN 'v1'
               ELSE 'v2'
           END) AS uniswap_version,
          SUM(usd_amount) AS usd_volume
   FROM dex.""trades""
   WHERE project='Uniswap'
   GROUP BY DAY, uniswap_version) as days;"
231701,ENS Airdropped Supply,,table,"SELECT  net.day,
        25 as ""Airdropped Tokens""
FROM 
(
    SELECT
    date_trunc('day', evt_block_time) as day,
    sum(value/10^18) as transfer
    FROM erc20.""ERC20_evt_Transfer""
    WHERE contract_address =  '\xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72' -- ENS
    AND ""from"" = '\x0000000000000000000000000000000000000000'
    GROUP BY 1
UNION
    SELECT
    date_trunc('day', evt_block_time) as day,
    -sum(value/10^18) as transfer
    FROM erc20.""ERC20_evt_Transfer""
    WHERE contract_address =  '\xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72' -- ENS
    AND ""to"" = '\x0000000000000000000000000000000000000000'
    GROUP BY 1
) as net
GROUP BY net.day, net.transfer"
231597,ENS claimed,,table,"SELECT SUM(amount)/1e18 AS claimed
, 100*(SUM(amount)/1e18)/25000000 AS claimed_percentage
, COUNT(distinct claimant) AS claimers
, 100.0*COUNT(distinct claimant)/137689 AS claimers_percentage
FROM ethereumnameservice.""ENSToken_evt_Claim"""
231604,ENS Airdrop Claims,,table,"SELECT date_trunc('day',evt_block_time) AS time
, COUNT(DISTINCT claimant) AS ""Hourly Claimers""
, SUM(COUNT(DISTINCT claimant)) OVER (ORDER BY date_trunc('day',evt_block_time) ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS ""Total Claimers""
, ROUND(SUM(COUNT(DISTINCT claimant)) OVER (ORDER BY date_trunc('day',evt_block_time) ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)/137689,3) AS ""Claimers %""
, SUM(amount)/1e18 AS ""Hourly Claims""
, SUM(SUM(amount)/1e18) OVER (ORDER BY date_trunc('day',evt_block_time) ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS ""Total Claimed""
, ROUND(SUM(SUM(amount)/1e18) OVER (ORDER BY date_trunc('day',evt_block_time) ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)/25000000,3) AS ""Claimed %""
FROM ethereumnameservice.""ENSToken_evt_Claim""
GROUP BY time"
231625,ENS bucketed claim sizes distribution,,table,"with claim AS
    (SELECT 
        value/1e18 AS token_balance
        FROM erc20.""ERC20_evt_Transfer""
        WHERE contract_address = '\xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72'
        AND ""from"" = '\xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72'
        ORDER BY value
    ),
    
bucketed AS (SELECT
    CASE
        WHEN token_balance <= 50 THEN '<=50'
        WHEN 50 < token_balance AND token_balance <= 100 THEN '50 - 100'
        WHEN 100 < token_balance AND token_balance <= 150 THEN '100 - 150'
        WHEN 150 < token_balance AND token_balance <= 200 THEN '150 - 200'
        WHEN 200 < token_balance AND token_balance <= 250 THEN '200 - 250'
        WHEN 250 < token_balance AND token_balance <= 300 THEN '250 - 300'
        WHEN 300 < token_balance AND token_balance <= 350 THEN '300 - 350'
        WHEN 350 < token_balance AND token_balance <= 400 THEN '350 - 400'
        WHEN 400 < token_balance AND token_balance <= 450 THEN '400 - 450'
        WHEN 450 < token_balance AND token_balance <= 500 THEN '450 - 500'
        WHEN 500 < token_balance AND token_balance <= 550 THEN '500 - 550'
        WHEN 550 < token_balance AND token_balance <= 600 THEN '550 - 600'
        WHEN 600 < token_balance AND token_balance <= 650 THEN '600 - 650'
        WHEN 650 < token_balance AND token_balance <= 700 THEN '650 - 700'
        WHEN 700 < token_balance AND token_balance <= 750 THEN '700 - 750'
        WHEN 750 < token_balance AND token_balance <= 800 THEN '750 - 800'
        WHEN 800 < token_balance AND token_balance <= 850 THEN '800 - 850'
        WHEN 850 < token_balance AND token_balance <= 900 THEN '850 - 900'
        WHEN 900 < token_balance AND token_balance <= 950 THEN '850 - 950'
        WHEN 950 < token_balance AND token_balance <= 1000 THEN '950 - 1000'
        WHEN 1000 < token_balance AND token_balance <= 1050 THEN '1000 - 1050'
        WHEN 1050 < token_balance AND token_balance <= 1100 THEN '1050 - 1100'
        WHEN 1100 < token_balance AND token_balance <= 1150 THEN '1100 - 1150'
        WHEN 1150 < token_balance AND token_balance <= 1200 THEN '1150 - 1200'
        WHEN 1200 < token_balance AND token_balance <= 1250 THEN '1200 - 1250'
        WHEN 1250 < token_balance AND token_balance <= 1300 THEN '1250 - 1300'
        WHEN 1300 < token_balance AND token_balance <= 1350 THEN '1300 - 1350'
        WHEN 1350 < token_balance AND token_balance <= 1400 THEN '1350 - 1400'
        WHEN 1400 < token_balance AND token_balance <= 1450 THEN '1400 - 1450'
        WHEN 1450 < token_balance AND token_balance <= 1500 THEN '1450 - 1500'
        WHEN 1500 < token_balance THEN '>1500'
    END AS tokens_balance_buckets,
CASE
        WHEN token_balance <= 50 THEN 1
        WHEN 50 < token_balance AND token_balance <= 100 THEN 2
        WHEN 100 < token_balance AND token_balance <= 150 THEN 3
        WHEN 150 < token_balance AND token_balance <= 200 THEN 4
        WHEN 200 < token_balance AND token_balance <= 250 THEN 5
        WHEN 250 < token_balance AND token_balance <= 300 THEN 6
        WHEN 300 < token_balance AND token_balance <= 350 THEN 7
        WHEN 350 < token_balance AND token_balance <= 400 THEN 8
        WHEN 400 < token_balance AND token_balance <= 450 THEN 9
        WHEN 450 < token_balance AND token_balance <= 500 THEN 10
        WHEN 500 < token_balance AND token_balance <= 550 THEN 11
        WHEN 550 < token_balance AND token_balance <= 600 THEN 12
        WHEN 600 < token_balance AND token_balance <= 650 THEN 13
        WHEN 650 < token_balance AND token_balance <= 700 THEN 14
        WHEN 700 < token_balance AND token_balance <= 750 THEN 15
        WHEN 750 < token_balance AND token_balance <= 800 THEN 16
        WHEN 800 < token_balance AND token_balance <= 850 THEN 17
        WHEN 850 < token_balance AND token_balance <= 900 THEN 18
        WHEN 900 < token_balance AND token_balance <= 950 THEN 19
        WHEN 950 < token_balance AND token_balance <= 1000 THEN 20
        WHEN 1000 < token_balance AND token_balance <= 1050 THEN 21
        WHEN 1050 < token_balance AND token_balance <= 1100 THEN 22
        WHEN 1100 < token_balance AND token_balance <= 1150 THEN 23
        WHEN 1150 < token_balance AND token_balance <= 1200 THEN 24
        WHEN 1200 < token_balance AND token_balance <= 1250 THEN 25
        WHEN 1250 < token_balance AND token_balance <= 1300 THEN 26
        WHEN 1300 < token_balance AND token_balance <= 1350 THEN 27
        WHEN 1350 < token_balance AND token_balance <= 1400 THEN 28
        WHEN 1400 < token_balance AND token_balance <= 1450 THEN 29
        WHEN 1450 < token_balance AND token_balance <= 1500 THEN 30
        WHEN 1500 < token_balance THEN 31
    END AS tokens_balance_buckets_ordering,
COUNT(token_balance) AS ""Claim Count""
FROM claim
GROUP BY tokens_balance_buckets, token_balance
ORDER BY tokens_balance_buckets_ordering)

SELECT COUNT (*) AS ""Count"", tokens_balance_buckets, tokens_balance_buckets_ordering
FROM bucketed
GROUP BY tokens_balance_buckets, tokens_balance_buckets_ordering
ORDER BY tokens_balance_buckets_ordering"
231675,ENS Maximum Supply,,table,"SELECT  net.day,
        100 as ""Total Supply"",
        SUM(transfer) over (order by net.day) as ""Current Supply"",
        concat(round(CAST((100*SUM(transfer) over (order by net.day)/100000000) AS numeric),1),'%') as ""% of Max Supply"",
        concat(round(CAST(100-(100*SUM(transfer) over (order by net.day)/100000000) AS numeric),1),'%') as ""% Burned""
FROM 
(
    SELECT
    date_trunc('day', evt_block_time) as day,
    sum(value/10^18) as transfer
    FROM erc20.""ERC20_evt_Transfer""
    WHERE contract_address =  '\xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72' -- ENS
    AND ""from"" = '\x0000000000000000000000000000000000000000'
    GROUP BY 1
UNION
    SELECT
    date_trunc('day', evt_block_time) as day,
    -sum(value/10^18) as transfer
    FROM erc20.""ERC20_evt_Transfer""
    WHERE contract_address =  '\xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72' -- ENS
    AND ""to"" = '\x0000000000000000000000000000000000000000'
    GROUP BY 1
) as net
GROUP BY net.day, net.transfer"
231695,ENS airdrop eligible addresses,,table,"SELECT 137689 as ""Total Supply"""
675376,Avatar record growth,,table,"select date_trunc('month', call_block_time) , count(*) from ethereumnameservice.""PublicResolver_call_setText"" where key = 'avatar' AND call_block_time > (current_date - interval '1' year) group by 1  order by 1 desc"
675509,Dweb (contenthash) growth,,table,"select date_trunc('month', call_block_time) as month , count(*) from ethereumnameservice.""PublicResolver_call_setContenthash"" WHERE call_block_time > (current_date - interval '1' year) group by 1  order by 1 desc"
675116,monthly primary names,,chart,"SELECT date_trunc('month', min_evt_block_time) , count(*) FROM ethereumnameservice.view_registries
WHERE node = '\x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2' /* addr.reverse */
AND min_evt_block_time > (current_date - interval '1' year)
GROUP BY 1 ORDER BY 1 DESC"
650661,monthly new addresses,,counter,"SELECT first_registration_date as total_new_user, COUNT(*) FROM (
    SELECT owner, min(month) as first_registration_date FROM (
        SELECT * FROM (
            SELECT node, owner, date_trunc('month', min(evt_block_time)) as month FROM (
                SELECT node, owner, evt_block_time FROM ethereumnameservice.""ENSRegistry_evt_NewOwner""
                WHERE evt_block_time < '2020-02-1' AND evt_block_time > (current_date - interval '1' year)
                UNION
                SELECT node, owner, evt_block_time FROM ethereumnameservice.""ENSRegistry_evt_Transfer""
                WHERE evt_block_time < '2020-02-1' AND evt_block_time > (current_date - interval '1' year)
                UNION
                SELECT node, owner, evt_block_time FROM ethereumnameservice.""ENSRegistryWithFallback_evt_NewOwner""
                WHERE evt_block_time >  '2020-02-10' AND evt_block_time > (current_date - interval '1' year)
                UNION
                SELECT node, owner, evt_block_time FROM ethereumnameservice.""ENSRegistryWithFallback_evt_Transfer""
                WHERE evt_block_time >  '2020-02-10' AND evt_block_time > (current_date - interval '1' year)
            ) as rr group by node, owner
        ) AS c
        /*
        WHERE max_expires > (now() - interval '90 days')
        */
    ) AS c1 group by owner
) AS a group by first_registration_date order by first_registration_date desc"
5341,Primary names registered,,table,"SELECT count(DISTINCT(label)) AS ""Primary names registrered"" FROM ethereumnameservice.view_registries
WHERE node = '\x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2' /* addr.reverse */
"
675539,cointype growth,,table,"WITH n AS (
SELECT 0 as cointype, 'BTC' as name
UNION
SELECT 2 as cointype, 'LTC' as name
UNION
SELECT 3 as cointype, 'DOGE' as name
UNION
SELECT 5 as cointype, 'DASH' as name
UNION
SELECT 6 as cointype, 'PPC' as name
UNION
SELECT 22 as cointype, 'MONA' as name
UNION
SELECT 43 as cointype, 'XEM' as name
UNION
SELECT 60 as cointype, 'ETH' as name
UNION
SELECT 61 as cointype, 'ETC' as name
UNION
SELECT 118 as cointype, 'ATOM' as name
UNION
SELECT 119 as cointype, 'ZIL' as name
UNION
SELECT 137 as cointype, 'RSK' as name
UNION
SELECT 144 as cointype, 'XRP' as name
UNION
SELECT 145 as cointype, 'BCH' as name
UNION
SELECT 148 as cointype, 'XLM' as name
UNION
SELECT 194 as cointype, 'EOS' as name
UNION
SELECT 195 as cointype, 'TRX' as name
UNION
SELECT 239 as cointype, 'NEO' as name
UNION
SELECT 354 as cointype, 'DOT' as name
UNION
SELECT 501 as cointype, 'SOL' as name
UNION
SELECT 434 as cointype, 'KXM' as name
UNION
SELECT 700 as cointype, 'XDAI' as name
UNION
SELECT 703 as cointype, 'VET' as name
UNION
SELECT 714 as cointype, 'BNB' as name
UNION
SELECT 1729 as cointype, 'XTZ' as name
UNION
SELECT 1815 as cointype, 'ADA' as name
UNION
SELECT 52752 as cointype, 'CELO' as name
UNION
SELECT 2147483785 as cointype, 'MATIC' as name
UNION
SELECT 2147483704 as cointype, 'BSC' as name
UNION
SELECT 539 as cointype, 'FLOW' as name
UNION
SELECT 283 as cointype, 'ALGO' as name
UNION
SELECT 128 as cointype, 'XMR' as name
UNION
SELECT 904 as cointype, 'HNT' as name
UNION
SELECT 3030 as cointype, 'HBAR' as name
UNION
SELECT 133 as cointype, 'ZEC' as name
UNION
SELECT 330 as cointype, 'LUNA' as name
UNION
SELECT 461 as cointype, 'FIL' as name
UNION
SELECT 461 as cointype, 'FIL' as name
UNION
SELECT 120 as cointype, 'EGLD' as name
UNION
SELECT 397 as cointype, 'NEAR' as name
UNION
SELECT 9000 as cointype, 'AVAX' as name
UNION
SELECT 165 as cointype, 'NANO' as name
UNION
SELECT 1007 as cointype, 'FTM' as name
UNION
SELECT 1023 as cointype, 'ONE' as name
UNION
SELECT 2147483709 as cointype, 'ETC' as name
UNION
SELECT 2147483898 as cointype, 'FTM' as name
UNION
SELECT 2147483658 as cointype, 'OP' as name
UNION
SELECT 2147525809 as cointype, 'ARB1' as name

), r AS (
  SELECT ""coinType"" as cointype, date_trunc('month', call_block_time) as month , count(*) as count FROM ethereumnameservice.""PublicResolver_call_setAddr"" WHERE ""coinType"" != 60
  AND call_block_time > (current_date - interval '1' year)
  group by 1,2
)
SELECT
CASE
WHEN name is not null THEN name
ELSE r.cointype::text
END as coin
,r.month, r.count FROM r
LEFT JOIN n ON r.cointype = n.cointype
WHERE r.count > 5
ORDER BY month desc"
5768,Total ENS names created,,table,"SELECT COUNT (*) FROM (
    /* .eth domains */
    SELECT c.label AS "".ETH names registrered""  FROM ethereumnameservice.view_registries AS c
    JOIN ethereumnameservice.""view_expirations"" AS e
    ON c.label = e.label AND c.node = '\x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae' /* eth  */
    WHERE max_expires > (now() - interval '90 days')
    UNION ALL
    /* everything else except 1tld and reverse records */
    SELECT label FROM ethereumnameservice.view_registries where node not in (
        '\x0000000000000000000000000000000000000000000000000000000000000000', /* root */
        '\x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2', /* addr.reverse */
        '\xa097f6721ce401e757d1223a763fef49b8b5f90bb18567ddb86fd205dff71d34', /* reverse */
        '\x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae' /* eth  */
    )
) as r


"
5676,.eth Registration,,table,"SELECT date_trunc('month', evt_block_time), COUNT(*)
FROM 

(
SELECT * FROM ethereumnameservice.""ETHRegistrarController_1_evt_NameRegistered""
WHERE evt_block_time > (current_date - interval '1' year)
UNION 
SELECT * FROM ethereumnameservice.""ETHRegistrarController_2_evt_NameRegistered""
WHERE evt_block_time > (current_date - interval '1' year)
UNION 
SELECT * FROM ethereumnameservice.""ETHRegistrarController_3_evt_NameRegistered""
WHERE evt_block_time > (current_date - interval '1' year)
) AS r
GROUP BY 1"
675898,Total avatar set,,table,"select count(distinct(node)) from ethereumnameservice.""PublicResolver_call_setText"" where key = 'avatar' "
675909,Total Dweb (contenthash) set,,table,"select count(distinct(node)) from ethereumnameservice.""PublicResolver_call_setContenthash"""
675916,Total cointype set (except ETH),,table,"SELECT count(distinct(node)) as count FROM ethereumnameservice.""PublicResolver_call_setAddr"" WHERE ""coinType"" != 60"
6491,All ENS participating addresses,,counter,"SELECT COUNT(*) FROM (
    /* eth owners */
    SELECT owner FROM (
        SELECT * FROM (
            SELECT node, label, owner FROM (
                SELECT * FROM ethereumnameservice.""ENSRegistry_evt_NewOwner""
                UNION
                SELECT * FROM ethereumnameservice.""ENSRegistryWithFallback_evt_NewOwner""
            ) as rr group by node, label, owner
        ) AS c
        JOIN ethereumnameservice.""view_expirations"" AS e
        ON c.label = e.label AND c.node = '\x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae' /* eth  */
        WHERE max_expires > (now() - interval '90 days')
    ) AS c1 group by owner
    UNION
    /* non eth owners */
    SELECT owner FROM (
            SELECT node, label, owner FROM (
                SELECT * FROM ethereumnameservice.""ENSRegistry_evt_NewOwner""
                UNION
                SELECT * FROM ethereumnameservice.""ENSRegistryWithFallback_evt_NewOwner""
            ) as rr WHERE 
            rr.node not in (
            '\x0000000000000000000000000000000000000000000000000000000000000000', /* root */
            '\x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2', /* addr.reverse */
            '\xa097f6721ce401e757d1223a763fef49b8b5f90bb18567ddb86fd205dff71d34', /* reverse */
            '\x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae' /* eth  */
            )
            group by node, label, owner
    ) AS c2 group by owner
) AS owenrs"
9415,Released/To be released names,,table,"SELECT date_trunc('month', released_date), COUNT(*) FROM
(
SELECT c.node as node, c.label as label, e.max_expires, e.max_expires + interval '90 days' as released_date  FROM
ethereumnameservice.""view_registries"" AS c
JOIN ethereumnameservice.""view_expirations"" AS e
ON c.label = e.label AND c.node = '\x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae'
WHERE max_expires BETWEEN (now() - interval '275 days') AND  now()
 ) AS r
 GROUP BY 1"
7507,.eth names Registered,,table,"
SELECT 
    evt_block_time,
    length(name) as length,
    name || '.eth',
    CASE WHEN length(name) = 3 THEN 640.43
         WHEN length(name) = 4 THEN 160.11
         ELSE 5 END
         AS unitprice,
    age(TO_TIMESTAMP(expires), evt_block_time) as duration,
    ROUND(CAST(cost / POW(10, 18) * p.price as NUMERIC), 2) as ""registration cost (USD)"" ,
    ROUND(CAST(cost / POW(10, 18) * p.price as NUMERIC), 2) / (DATE_PART('day', TO_TIMESTAMP(expires) - evt_block_time) / 365) as annual_cost
FROM ethereumnameservice.""ETHRegistrarController_3_evt_NameRegistered"" 
CROSS JOIN (
    SELECT price FROM  prices.layer1_usd WHERE symbol = 'ETH' ORDER BY minute desc limit 1
) as p
WHERE evt_block_time > now() - interval '30 day'
/*
AND length(name) = 3
*/

/* AND EXTRACT(year from age(TO_TIMESTAMP(expires), evt_block_time)) = 0 */
ORDER BY evt_block_time DESC
"
19108,ENS Names to be released,,table,"SELECT name, char_length(name), max_expires, released_date FROM
(
    SELECT c.node as node, c.label as label, e.max_expires, e.max_expires + interval '90 days' as released_date  FROM
    ethereumnameservice.""view_registries"" AS c
    JOIN ethereumnameservice.""view_expirations"" AS e
    ON c.label = e.label AND c.node = '\x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae'
    WHERE max_expires BETWEEN (now() - interval '90 days') AND  now()
) AS r
INNER JOIN 
  (SELECT name,
          hash
   FROM ethereumnameservice.""old_preimages"" 
   WHERE char_length(name) < 7 
   UNION SELECT name,
                label AS hash
   FROM ethereumnameservice.""ETHRegistrarController_3_evt_NameRegistered""
   WHERE char_length(name) < 7 
   ) labels ON label = labels.hash
ORDER BY  max_expires


"
781958,Most Followed Lens Profiles,,table,"SELECT (CONCAT('0x', substring(contract_address::text from 3))), COUNT(*) AS followers
FROM(
SELECT et.""contract_address"", lf.""call_tx_hash"", lf.""call_success"" FROM lens.""LensHub_call_followWithSig"" lf
LEFT JOIN erc721.""ERC721_evt_Transfer"" et ON et.""evt_tx_hash""=""call_tx_hash""
WHERE ""call_success"" = True
UNION
SELECT et.""contract_address"", lf2.""call_tx_hash"", lf2.""call_success"" FROM lens.""LensHub_call_follow"" lf2
LEFT JOIN erc721.""ERC721_evt_Transfer"" et ON et.""evt_tx_hash""=""call_tx_hash""
WHERE ""call_success"" = True
)a
GROUP BY 1 
ORDER BY 2 DESC 

-- SELECT (CONCAT('0x', substring(et.""contract_address""::text from 3))), COUNT(*) AS followers
-- FROM lens.""LensHub_call_followWithSig"" lf
-- LEFT JOIN erc721.""ERC721_evt_Transfer"" et ON et.""evt_tx_hash""=""call_tx_hash""
-- WHERE et.""contract_address"" IS NOT NULL
-- AND lf.""call_success"" = True
-- GROUP BY 1 
-- ORDER BY 2 DESC "
1373709,Monthly Active Lens Profiles,"Profiles that made at least one post, comment or mirror that month",table,"WITH comments AS (
SELECT 
""call_block_time"",
vars->>'profileId'::text AS profileid
FROM lens.""LensHub_call_commentWithSig""
WHERE ""call_success"" = True
UNION ALL 
SELECT 
""call_block_time"",
vars->>'profileId'::text AS profileid
FROM lens.""LensHub_call_comment""
WHERE ""call_success"" = True
),

mirrors AS(
SELECT 
""call_block_time"",
vars->>'profileId' AS profileid
FROM lens.""LensHub_call_mirrorWithSig""
WHERE ""call_success"" = TRUE
UNION ALL
SELECT 
""call_block_time"",
vars->>'profileId' AS profileid
FROM lens.""LensHub_call_mirror""
WHERE ""call_success"" = TRUE
),

posts AS(
SELECT 
""call_block_time"",
vars->>'profileId' AS profileid 
FROM lens.""LensHub_call_postWithSig""
WHERE ""call_success"" = TRUE
UNION ALL
SELECT 
""call_block_time"",
vars->>'profileId' AS profileid 
FROM lens.""LensHub_call_post""
WHERE ""call_success"" = TRUE
)

SELECT 
date_trunc('month',""call_block_time"") as month,
COUNT(DISTINCT profileid)
FROM (
SELECT * FROM comments 
UNION ALL
SELECT * FROM mirrors 
UNION ALL
SELECT * FROM posts
)a
WHERE date_trunc('month',""call_block_time"") < date_trunc('month',now())
GROUP BY 1
"
1373772,Monthly New Profiles,Number of new profiles minted every week,table,"SELECT
date_trunc('month', ""evt_block_time"") AS month,
COUNT(*) AS count
FROM erc721.""ERC721_evt_Transfer""
WHERE contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'  -- lens protocol contract address
AND ""from"" = '\x0000000000000000000000000000000000000000'  -- mint address
GROUP BY 1"
847168,Most frequent posters,,table,"SELECT profile, COUNT(*) FROM (
SELECT vars->>'profileId' AS profile FROM lens.""LensHub_call_postWithSig""
WHERE ""call_success"" = TRUE
UNION ALL
SELECT vars->>'profileId' AS profile FROM lens.""LensHub_call_post""
WHERE ""call_success"" = TRUE
)a
GROUP BY 1
ORDER BY 2 DESC
-- SELECT * FROM lens.""LensHub_call_postWithSig"""
1373788,Profiles Segmented by Engagement,"Any post, comment or mirror is counted as an engagement",table,"WITH comments AS (
SELECT 
""call_block_time"",
vars->>'profileId'::text AS profileid
FROM lens.""LensHub_call_commentWithSig""
WHERE ""call_success"" = True
),

mirrors AS(
SELECT 
""call_block_time"",
vars->>'profileId' AS profileid
FROM lens.""LensHub_call_mirrorWithSig""
WHERE ""call_success"" = TRUE
),

posts AS(
SELECT 
""call_block_time"",
vars->>'profileId' AS profileid 
FROM lens.""LensHub_call_postWithSig""
WHERE ""call_success"" = TRUE
UNION ALL
SELECT 
""call_block_time"",
vars->>'profileId' AS profileid 
FROM lens.""LensHub_call_post""
WHERE ""call_success"" = TRUE
)

SELECT 
engagements,
COUNT(*)
FROM(
SELECT 
*,
CASE
    WHEN actions = 0 THEN '0 Engagements'
    WHEN actions > 0 AND actions < 11 THEN '1-10 Engagements'
    WHEN actions > 10 AND actions < 51 THEN '10-50 Engagements'
    WHEN actions > 50 AND actions < 101 THEN '50-100 Engagements'
    ELSE '>100 Engagements'
END AS engagements
FROM (
SELECT 
profileid,
COUNT(*) as actions
FROM (
SELECT * FROM comments 
UNION ALL
SELECT * FROM mirrors 
UNION ALL
SELECT * FROM posts
)a
GROUP BY 1)b
)c
GROUP BY 1
"
781877,Lens Profiles,,table,"with agg as 
    (with transfers as 
        ((SELECT 
        ""to"" as wallet,
        'mint' as action,
        1 as value
        FROM erc721.""ERC721_evt_Transfer""
        where contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'
        and ""from"" = '\x0000000000000000000000000000000000000000')
        
        union all
        
        (SELECT 
        ""to"" as wallet,
        'gain' as action,
        1 as value
        FROM erc721.""ERC721_evt_Transfer""
        where contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'
        and ""from"" != '\x0000000000000000000000000000000000000000')
        
        union all 
        
        (SELECT 
        ""from"" as wallet,
        'lose' as action,
        -1 as value
        FROM erc721.""ERC721_evt_Transfer""
        where contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'
        and ""from"" != '\x0000000000000000000000000000000000000000'))
    
    select 
    wallet,
    sum(value) as tokens
    from 
    transfers 
    group by wallet
    order by tokens desc) 

select 
count(distinct wallet) as owners,
max(tokens) as most_owned,
avg(tokens) as average_owned,
count(distinct wallet) filter (where tokens = 1) as single_token_wallets,
percentile_cont(0.5) within group ( order by tokens) as median,
percentile_cont(0.25) within group ( order by tokens) as ""25th"",
percentile_cont(0.75) within group ( order by tokens) as ""75th""


from 
agg
where tokens > 0 
"
1017416,Most engaged post,,table,"WITH comments AS (
SELECT 
CONCAT(profileid, ', ', pubid) AS link,
-- '<a href=""https://lenster.xyz/posts/0x0' || to_hex(profileid::int) || '-0x0' || to_hex(pubid::int) || '"" target=""_blank"" >' || 'lenster.xyz/posts/0x0' || to_hex(profileid::int) || '-0x0' || to_hex(pubid::int) || '</a>' As link,
comment_count
FROM
(SELECT 
vars->>'profileIdPointed'::text AS profileid,
vars->>'pubIdPointed'::text AS pubid, 
COUNT(*) AS comment_count
FROM lens.""LensHub_call_commentWithSig""
WHERE ""call_success"" = True
GROUP BY 1,2
)a
),

mirrors AS(
SELECT 
CONCAT(profileid, ', ', pubid) AS link,
mirrors_count
FROM
(SELECT 
vars->>'profileIdPointed' AS profileid,
vars->>'pubIdPointed' AS pubid, 
COUNT(*) AS mirrors_count
FROM lens.""LensHub_call_mirrorWithSig""
WHERE ""call_success"" = TRUE
GROUP BY 1,2)a
),

collects AS(
SELECT
CONCAT(profileid, ', ', pubid) AS link,
collect_count
FROM
(SELECT 
vars->>'profileId' AS profileid,
vars->>'pubId' AS pubid, 
COUNT(*) AS collect_count
FROM lens.""LensHub_call_collectWithSig""
WHERE ""call_success"" = TRUE
GROUP BY 1,2)a
)

SELECT 
comments.link
,comment_count 
,mirrors_count 
,collect_count 
FROM comments
LEFT JOIN mirrors on mirrors.link = comments.link
LEFT JOIN collects on collects.link = comments.link
ORDER BY comments.comment_count DESC

-- (CONCAT(vars->>'profileIdPointed', ', ', vars->>'pubIdPointed')) AS post_id,
"
782098,No of Posts Created,,table,"SELECT COUNT(*) FROM (
SELECT * FROM lens.""LensHub_call_postWithSig""
UNION ALL
SELECT * FROM lens.""LensHub_call_post""
)a
WHERE ""call_success"" = TRUE

-- SELECT * FROM lens.""LensHub_call_postWithSig"""
781918,No of wallets that own a Lens Profile,,chart,"with running_wallet_balances as   
    (with base_data as  
        (with days as 
            (SELECT generate_series(date_trunc('day',min(evt_block_time))::TIMESTAMP, date_trunc('day', NOW()), '1 day') AS DAY
            FROM erc721.""ERC721_evt_Transfer""
            where contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'),      
        all_wallets as
            (select 
            distinct wallet 
            from 
                (select
                ""from"" as wallet
                FROM erc721.""ERC721_evt_Transfer""
                where contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'
                union all 
                select
                ""to"" as wallet
                FROM erc721.""ERC721_evt_Transfer""
                where contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d')
            distinct_wallets)
        select 
        day,
        wallet
        from 
        days
        full outer join all_wallets on true),
        
    aggregated_transfers as 
        (with transfers as 
            ((SELECT 
            date_trunc('day',evt_block_time) as day,
            ""to"" as wallet,
            count(evt_tx_hash) as value
            FROM erc721.""ERC721_evt_Transfer""
            where contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'
            -- and evt_block_time >= '2021-06-20'
            group by day, wallet)
            
            union all 
            
            (SELECT 
            date_trunc('day',evt_block_time) as day,
            ""from"" as wallet,
            count(evt_tx_hash)*-1 as value
            FROM erc721.""ERC721_evt_Transfer""
            where contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'
            -- and evt_block_time >= '2021-06-20'
            group by day, wallet))
        select
        day,
        wallet,
        sum(value) as resulting
        from 
        transfers 
        group by day, wallet)
        
        select 
        base_data.day,
        base_data.wallet,
        sum(coalesce(resulting,0)) over (partition by base_data.wallet order by base_data.day) as holding
        from 
        base_data
        left join aggregated_transfers on base_data.day = aggregated_transfers.day and base_data.wallet = aggregated_transfers.wallet 
        -- where base_data.wallet != '\x0000000000000000000000000000000000000000'
        )
    
    select 
    day::timestamp as day,
    count(wallet) filter (where holding > 0)
    from running_wallet_balances
    group by day::timestamp 
    order by day::timestamp "
782226,No of Comments Created,,table,"SELECT COUNT(*) FROM (
SELECT * FROM lens.""LensHub_call_commentWithSig""z
UNION ALL 
SELECT * FROM lens.""LensHub_call_comment""
)a
WHERE ""call_success"" = TRUE

-- SELECT * FROM lens.""LensHub_call_postWithSig"""
1373693,Engagements per Month,,table,"WITH posts AS(
SELECT month, COUNT(*) AS posts
FROM (
SELECT date_trunc('month',""call_block_time"") as month, 
vars->>'profileId' AS profile 
FROM lens.""LensHub_call_postWithSig""
WHERE ""call_success"" = TRUE
UNION ALL
SELECT date_trunc('month',""call_block_time"") as month, 
vars->>'profileId' AS profile 
FROM lens.""LensHub_call_post""
WHERE ""call_success"" = TRUE
)a
GROUP BY 1
)

, comments AS (
SELECT month, 
COUNT(*) AS comments
FROM (
SELECT date_trunc('month',""call_block_time"") as month
FROM lens.""LensHub_call_commentWithSig""
WHERE ""call_success"" = True
UNION ALL
SELECT date_trunc('month',""call_block_time"") as month
FROM lens.""LensHub_call_commentWithSig""
WHERE ""call_success"" = True)a
GROUP BY 1
)

, mirrors AS (
SELECT month, 
COUNT(*) AS mirrors
FROM(
SELECT date_trunc('month',""call_block_time"") as month
FROM lens.""LensHub_call_mirrorWithSig""
WHERE ""call_success"" = True
UNION ALL
SELECT date_trunc('month',""call_block_time"") as month
FROM lens.""LensHub_call_mirror""
WHERE ""call_success"" = True)a
GROUP BY 1
)

, collects AS (
SELECT month, 
COUNT(*) AS collects
FROM(
SELECT date_trunc('month',""call_block_time"") as month
FROM lens.""LensHub_call_collectWithSig""
WHERE ""call_success"" = True
UNION ALL
SELECT date_trunc('month',""call_block_time"") as month
FROM lens.""LensHub_call_collect""
WHERE ""call_success"" = True)a
GROUP BY 1
)

SELECT p.month,
posts,
comments,
mirrors,
collects
FROM posts p
LEFT JOIN comments c ON p.month = c.month
LEFT JOIN mirrors m ON p.month = m.month
LEFT JOIN collects co ON p.month = co.month
WHERE p.month < date_trunc('month',now())
"
1376314,Profiles Segmented by Continued Engagement,"Time between a profiles first engagement and most recent engagement. Engagement = post, comment, mirror",table,"WITH comments AS (
SELECT 
""call_block_time"",
vars->>'profileId'::text AS profileid
FROM lens.""LensHub_call_commentWithSig""
WHERE ""call_success"" = True
UNION ALL 
SELECT 
""call_block_time"",
vars->>'profileId'::text AS profileid
FROM lens.""LensHub_call_comment""
WHERE ""call_success"" = True
),

mirrors AS(
SELECT 
""call_block_time"",
vars->>'profileId' AS profileid
FROM lens.""LensHub_call_mirrorWithSig""
WHERE ""call_success"" = TRUE
UNION ALL
SELECT 
""call_block_time"",
vars->>'profileId' AS profileid
FROM lens.""LensHub_call_mirror""
WHERE ""call_success"" = TRUE
),

posts AS(
SELECT 
""call_block_time"",
vars->>'profileId' AS profileid 
FROM lens.""LensHub_call_postWithSig""
WHERE ""call_success"" = TRUE
UNION ALL
SELECT 
""call_block_time"",
vars->>'profileId' AS profileid 
FROM lens.""LensHub_call_post""
WHERE ""call_success"" = TRUE
)

SELECT 
continued_engagement,
COUNT(*)
FROM(
SELECT 
*,
CASE
    WHEN (last_engagement - first_engagement) < interval'1 week' THEN '<1 week'
    WHEN (last_engagement - first_engagement) >= interval'1 week' AND (last_engagement - first_engagement) < interval'2 weeks' THEN '1-2 weeks'
    WHEN (last_engagement - first_engagement) >= interval'2 weeks' AND (last_engagement - first_engagement) < interval'3 weeks' THEN '2-3 weeks'
    WHEN (last_engagement - first_engagement) >= interval'3 weeks' AND (last_engagement - first_engagement) < interval'3 months' THEN '3weeks - 3 months'
    ELSE '>3 months'
END AS continued_engagement
FROM (
SELECT 
profileid,
MIN(""call_block_time"") as first_engagement,
MAX(""call_block_time"") as last_engagement
FROM (
SELECT * FROM comments 
UNION ALL
SELECT * FROM mirrors 
UNION ALL
SELECT * FROM posts
)a
GROUP BY 1)b
)c
GROUP BY 1
"
1376362,Weekly Activity Distribution,"Engagement = post, comment, mirror",table,"WITH comments AS (
SELECT 
""call_block_time"",
vars->>'profileId'::text AS profileid
FROM lens.""LensHub_call_commentWithSig""
WHERE ""call_success"" = True
),

mirrors AS(
SELECT 
""call_block_time"",
vars->>'profileId' AS profileid
FROM lens.""LensHub_call_mirrorWithSig""
WHERE ""call_success"" = TRUE
),

posts AS(
SELECT 
""call_block_time"",
vars->>'profileId' AS profileid 
FROM lens.""LensHub_call_postWithSig""
WHERE ""call_success"" = TRUE
UNION ALL
SELECT 
""call_block_time"",
vars->>'profileId' AS profileid 
FROM lens.""LensHub_call_post""
WHERE ""call_success"" = TRUE
)


SELECT 
weekday,
hour,
(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY cnt)) as median
-- ROUND(AVG(cnt)) as avg_engagements
FROM(
SELECT 
week,
hour,
CASE
    WHEN extract(dow from ""call_block_time"") = 1 THEN 'Mon'
    WHEN extract(dow from ""call_block_time"") = 2 THEN 'Tue'
    WHEN extract(dow from ""call_block_time"") = 3 THEN 'Wed'
    WHEN extract(dow from ""call_block_time"") = 4 THEN 'Thurs'
    WHEN extract(dow from ""call_block_time"") = 5 THEN 'Fri'
    WHEN extract(dow from ""call_block_time"") = 6 THEN 'Sat'
    ELSE 'Sun'
END AS weekday,
COUNT(*) as cnt
FROM(
SELECT 
profileid,
""call_block_time"",
extract(hour from ""call_block_time"") as hour,
date_trunc('week',""call_block_time"") as week
FROM (
SELECT * FROM comments 
UNION ALL
SELECT * FROM mirrors 
UNION ALL
SELECT * FROM posts
)a)b
GROUP BY 1,2,3)c
GROUP BY 1,2
ORDER BY 3 DESC
-- )b
-- )c
-- GROUP BY 1
"
891346,Lens Profiles with Posts,,table,"
WITH p AS (
SELECT 
profile, COUNT(*) AS total
FROM (
SELECT vars->>'profileId' AS profile FROM lens.""LensHub_call_postWithSig""
WHERE ""call_success"" = TRUE
UNION ALL
SELECT vars->>'profileId' AS profile FROM lens.""LensHub_call_post""
WHERE ""call_success"" = TRUE
)a
GROUP BY profile
-- ORDER BY 2 DESC
)

SELECT COUNT(*) FROM p


"
891408,Lenster Daily Gas Fee Consumed ($MATIC),,table,"SELECT
  date_trunc('day', ""block_time"") AS day,
  ROUND(SUM(gas_used * gas_price / 1e18)) AS daily_gas_fees
FROM
  polygon.""transactions""
WHERE
  ""to"" = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d' -- Lens Smart Contract
GROUP BY day
"
891428,Lenster Total Gas Fee Consumed ($MATIC),,table,"SELECT
  ROUND(SUM(gas_used * gas_price / 1e18)) AS daily_gas_fees
FROM
  polygon.""transactions""
WHERE
  ""to"" = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d' -- Lens Smart Contract
"
891372,Lens Profiles with Posts Percentage,,counter,"
WITH p AS (
SELECT 
profile
FROM (
SELECT vars->>'profileId' AS profile FROM lens.""LensHub_call_postWithSig""
WHERE ""call_success"" = TRUE
UNION ALL
SELECT vars->>'profileId' AS profile FROM lens.""LensHub_call_post""
WHERE ""call_success"" = TRUE
)a
GROUP BY profile
),

t AS (
SELECT
  COUNT(*) AS total,
  COUNT(DISTINCT ""to"") AS wallet
FROM
  erc721.""ERC721_evt_Transfer""
WHERE
  contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'
  AND ""from"" = '\x0000000000000000000000000000000000000000'
)

SELECT ROUND(COUNT(p.profile)/(t.total + 0.0) * 100, 2) AS percentage 
FROM p,t 
GROUP BY t.total



"
891203,Lenster Posts,,table,"SELECT COUNT(*) FROM (
SELECT * FROM lens.""LensHub_call_postWithSig""
UNION ALL
SELECT * FROM lens.""LensHub_call_post""
)a
WHERE ""call_success"" = TRUE"
891205,Lenster Comments,,table,"SELECT COUNT(*) FROM (
SELECT * FROM lens.""LensHub_call_commentWithSig""z
UNION ALL 
SELECT * FROM lens.""LensHub_call_comment""
)a
WHERE ""call_success"" = TRUE"
891256,Daily Lens Profile Mint,,table,"SELECT
  date_trunc('day', ""evt_block_time"") AS day,
  COUNT(*) AS mint
FROM
  erc721.""ERC721_evt_Transfer""
WHERE
  contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'  -- lens protocol contract address
  AND ""from"" = '\x0000000000000000000000000000000000000000'  -- mint address
 GROUP BY day"
891266,Daily Lenster Comments,,chart,"SELECT 

date_trunc('day', ""call_block_time"") AS day,
COUNT(*) AS comments

FROM (
SELECT * FROM lens.""LensHub_call_commentWithSig""z
UNION ALL 
SELECT * FROM lens.""LensHub_call_comment""
)a
WHERE ""call_success"" = TRUE
GROUP BY day
ORDER BY day DESC
"
891273,Daily Lenster Posts,,table,"SELECT
  date_trunc('day', ""call_block_time"") AS day,
  COUNT(*) AS posts
FROM
  (
    SELECT
      *
    FROM
      lens.""LensHub_call_postWithSig""
    UNION ALL
    SELECT
      *
    FROM
      lens.""LensHub_call_post""
  ) a
WHERE
  ""call_success"" = TRUE
GROUP BY
  day
ORDER BY
  day DESC"
891286,Lenster Posts Amount,,table,"
WITH lens AS (
SELECT profile, COUNT(*) AS total 
FROM (
SELECT vars->>'profileId' AS profile FROM lens.""LensHub_call_postWithSig""
WHERE ""call_success"" = TRUE
UNION ALL
SELECT vars->>'profileId' AS profile FROM lens.""LensHub_call_post""
WHERE ""call_success"" = TRUE
)a
GROUP BY 1
-- ORDER BY 2 DESC
)

SELECT
  COUNT(*) AS lens_profile_counter,
  CASE
    WHEN lens.total >= 20  THEN '> 20 posts'
    WHEN lens.total >= 10  THEN '10~20 posts'
    WHEN lens.total >= 5  THEN '5~10 posts'
    WHEN lens.total >= 2  THEN '2~5 posts'
    WHEN lens.total >= 1  THEN '1 post'
    ELSE '0 post'
  END AS ""posts""
FROM lens
GROUP BY 2
ORDER BY 1 DESC

"
1509533,Lens Revenue by User V2.1,,table,"WITH 
-- Lens Collect-Event (https://github.com/lens-protocol/core/blob/746bda9cde9939a6ed19de6f70a0b4d390230bca/contracts/libraries/Events.sol#L313)
-- Get all relevant txn hashes to match transfer events
collect_evts AS (
    SELECT DISTINCT
        tx_hash
    FROM polygon.""logs""
    WHERE 
        block_time > now() - interval '{{interval}}'
        AND topic1 = '\xed39bf0d9afa849610b901c9d7f4d00751ba20de2db023428065bec153833218'
        AND contract_address = '\xDb46d1Dc155634FbC732f92E853b10B288AD5a1d'
),

-- Groups prices by contract address (e.g. each token), sorts them minute ascending to extract the latest price of each token
latest_prices AS (
    SELECT DISTINCT on (contract_address) contract_address, minute, price
    FROM  prices.""usd""
    WHERE contract_address IN (
        '\x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', -- MATIC
        '\x2791Bca1f2de4661ED88A30C99A7a9449Aa84174', -- USD
        '\x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619', -- WETH
        '\xD838290e877E0188a4A44700463419ED96c16107' -- NTC 
    )
    ORDER BY contract_address, minute desc
),

-- Joins latest price and pivots the table for easier frontend view
revenue AS (
    SELECT 
        SUBSTRING(topic3 FROM 13 FOR 20) AS address,
        SUM(CASE WHEN contract_address = '\x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270' THEN BYTEA2NUMERIC(SUBSTRING(data FROM 1 FOR 32)) / 1e18 ELSE 0 END) AS amount_matic,
        SUM(CASE WHEN contract_address = '\x2791Bca1f2de4661ED88A30C99A7a9449Aa84174' THEN BYTEA2NUMERIC(SUBSTRING(data FROM 1 FOR 32)) / 1e6 ELSE 0 END) AS amount_usdc,
        SUM(CASE WHEN contract_address = '\x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619' THEN BYTEA2NUMERIC(SUBSTRING(data FROM 1 FOR 32)) / 1e18 ELSE 0 END) AS amount_weth,
        SUM(CASE WHEN contract_address = '\xD838290e877E0188a4A44700463419ED96c16107' THEN BYTEA2NUMERIC(SUBSTRING(data FROM 1 FOR 32)) / 1e18 ELSE 0 END) AS amount_ntc,
        
        -- converted to USD 
        SUM(CASE WHEN contract_address = '\x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270' THEN BYTEA2NUMERIC(SUBSTRING(data FROM 1 FOR 32)) / 1e18 * price ELSE 0 END) AS amount_matic_usd,
        SUM(CASE WHEN contract_address = '\x2791Bca1f2de4661ED88A30C99A7a9449Aa84174' THEN BYTEA2NUMERIC(SUBSTRING(data FROM 1 FOR 32)) / 1e6 * price ELSE 0 END) AS amount_usdc_usd,
        SUM(CASE WHEN contract_address = '\x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619' THEN BYTEA2NUMERIC(SUBSTRING(data FROM 1 FOR 32)) / 1e18 * price ELSE 0 END) AS amount_weth_usd,
        SUM(CASE WHEN contract_address = '\xD838290e877E0188a4A44700463419ED96c16107' THEN BYTEA2NUMERIC(SUBSTRING(data FROM 1 FOR 32)) / 1e18 * price ELSE 0 END) AS amount_ntc_usd
    
    FROM polygon.""logs""
    LEFT JOIN collect_evts USING(tx_hash)
    LEFT JOIN latest_prices USING(contract_address)
    WHERE 
        block_time > now() - interval '{{interval}}'
        AND tx_hash IN (collect_evts.tx_hash)
        AND logs.topic1 = '\xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'
        AND logs.contract_address IN (
            '\x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', -- MATIC
            '\x2791Bca1f2de4661ED88A30C99A7a9449Aa84174', -- USDC
            '\x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619', -- WETH
            '\xD838290e877E0188a4A44700463419ED96c16107' -- NTC 
        )
        AND logs.data IS NOT NULL
    GROUP BY 1
),

-- Lens Profile Creation Events (to associate handle with address)
lens_profile_created AS (
    SELECT
        pg_typeof(vars)
        ,CONCAT('\x', substring(vars::json ->> 'to' from 3))::bytea as ""address""
        ,vars::json ->> 'handle' AS ""handle""
        ,call_block_time
    FROM lens.""ProfileCreationProxy_call_proxyCreateProfile""
),
-- only pick latest created profile for each address
latet_lens_handle AS (
    SELECT DISTINCT ON (address) address, handle
    FROM lens_profile_created
    ORDER BY address, call_block_time DESC
)

SELECT
    latet_lens_handle.handle as handle,
    '<a href=""https://lenster.xyz/u/' || latet_lens_handle.handle || '.lens"" target=""_blank"" >🪴 ' || latet_lens_handle.handle || '</a>' As link,
    amount_matic_usd + amount_weth_usd + amount_usdc_usd + COALESCE(amount_ntc_usd, 0) AS total_usd, -- no price for ntc so COALESCE
    revenue.*,
    latet_lens_handle.address as address
FROM revenue
LEFT JOIN latet_lens_handle ON latet_lens_handle.address = revenue.address
ORDER BY total_usd DESC
"
1427019,Lens Daily Users 60 Days,,chart,"with lens_transfers as (
    select evt_block_time,
        ""from"" as address,
        'sent' as transfer_type,
    -1 as nft_count
    FROM erc721.""ERC721_evt_Transfer""
    where contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'
        and ""from"" != '\x0000000000000000000000000000000000000000'

    union all

    select evt_block_time,
        ""to"" as address,
        (case when ""from"" = '\x0000000000000000000000000000000000000000' then 'mint'
            else 'receive'
        end) as transfer_type,
    1 as nft_count
    FROM erc721.""ERC721_evt_Transfer""
    where contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'
),

lens_users_summary as (
    select date_trunc('day', evt_block_time) as block_date,
        count(distinct address) as user_count,
        sum(nft_count) as nft_count
    from lens_transfers
    where evt_block_time >= now() - interval '60 days'
    group by block_date
    order by 1
)

select block_date,
    user_count,
    nft_count,
    sum(user_count) over (order by block_date) as accumulate_user_count,
    sum(nft_count) over (order by block_date) as accumulate_nft_count
from lens_users_summary
order by block_date"
1450488,Lenster Engagements per Month,,table,"WITH posts AS(
SELECT month, COUNT(*) AS posts
FROM (
SELECT date_trunc('month',""call_block_time"") as month, 
vars->>'profileId' AS profile 
FROM lens.""LensHub_call_postWithSig""
WHERE ""call_success"" = TRUE
UNION ALL
SELECT date_trunc('month',""call_block_time"") as month, 
vars->>'profileId' AS profile 
FROM lens.""LensHub_call_post""
WHERE ""call_success"" = TRUE
)a
GROUP BY 1
)

, comments AS (
SELECT month, 
COUNT(*) AS comments
FROM (
SELECT date_trunc('month',""call_block_time"") as month
FROM lens.""LensHub_call_commentWithSig""
WHERE ""call_success"" = True
UNION ALL
SELECT date_trunc('month',""call_block_time"") as month
FROM lens.""LensHub_call_commentWithSig""
WHERE ""call_success"" = True)a
GROUP BY 1
)

, mirrors AS (
SELECT month, 
COUNT(*) AS mirrors
FROM(
SELECT date_trunc('month',""call_block_time"") as month
FROM lens.""LensHub_call_mirrorWithSig""
WHERE ""call_success"" = True
UNION ALL
SELECT date_trunc('month',""call_block_time"") as month
FROM lens.""LensHub_call_mirror""
WHERE ""call_success"" = True)a
GROUP BY 1
)

, collects AS (
SELECT month, 
COUNT(*) AS collects
FROM(
SELECT date_trunc('month',""call_block_time"") as month
FROM lens.""LensHub_call_collectWithSig""
WHERE ""call_success"" = True
UNION ALL
SELECT date_trunc('month',""call_block_time"") as month
FROM lens.""LensHub_call_collect""
WHERE ""call_success"" = True)a
GROUP BY 1
)

SELECT p.month,
posts,
comments,
mirrors,
collects
FROM posts p
LEFT JOIN comments c ON p.month = c.month
LEFT JOIN mirrors m ON p.month = m.month
LEFT JOIN collects co ON p.month = co.month
WHERE p.month < date_trunc('month',now())
"
1388387,Lensters top posters,,table,"WITH lens_minted AS (
    SELECT
        date_trunc('day',evt_block_time) as ""mint_date""
        , ""to"" as ""owner""
        , ""tokenId""
    FROM erc721.""ERC721_evt_Transfer""
    WHERE contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'
    AND ""from"" = '\x0000000000000000000000000000000000000000'
), lens_profile_creation AS (
    SELECT
        pg_typeof(vars)
        ,CONCAT('\x', substring(vars::json ->> 'to' from 3))::bytea as ""owner""
        ,vars::json ->> 'handle' AS ""handle""
        ,vars::json ->> 'imageURI' AS ""imageURI""
        ,vars::json ->> 'followModule' AS ""followModule""
        ,vars::json ->> 'followNFTURI' AS ""followNFTURI""
        ,vars::json ->> 'followModuleInitData' AS ""followModuleInitData""
    FROM lens.""ProfileCreationProxy_call_proxyCreateProfile""
), lens_posters AS (

    SELECT profile, COUNT(*) as post_count FROM (
    SELECT vars->>'profileId' AS profile FROM lens.""LensHub_call_postWithSig""
    WHERE ""call_success"" = TRUE
    UNION ALL
    SELECT vars->>'profileId' AS profile FROM lens.""LensHub_call_post""
    WHERE ""call_success"" = TRUE
    )a
    GROUP BY 1
    ORDER BY 2 DESC
), lens_owners_handles AS (
    SELECT
        COALESCE(m.owner, p.owner) as ""owner""
        ,m.""tokenId""
        ,CASE 
            -- special case
            WHEN m.owner = '\x6c77a5a88c0ae712baeabe12fea81532060dcbf5' THEN 'lensprotocol' 
            ELSE p.handle
        END as ""handle""
    FROM lens_minted m
    FULL JOIN lens_profile_creation p
    ON m.owner = p.owner
), lens_top_posters AS (
    SELECT 
        CONCAT('<a href=""https://lenster.xyz/u/',h.handle,'.lens','"" target=""_blank""> </a>', ' ', h.handle) AS lens_profile
        ,p.profile as ""profileId"" 
        ,p.post_count
        ,h.owner -- wallet address
    FROM lens_posters p
    LEFT JOIN lens_owners_handles h
    ON p.profile = h.""tokenId""::TEXT
    ORDER BY p.post_count DESC
)

SELECT 
    DISTINCT lens_profile
    ,""profileId"" --Todo: some wallets have multiple lens handles
    ,post_count
    -- ,owner
FROM lens_top_posters
ORDER BY post_count DESC"
1451114,Lens active users in last 24 hours users summary,,counter,"with lens_transfers as (
    select evt_block_time,
        ""from"" as address,
        'sent' as transfer_type,
    -1 as nft_count
    FROM erc721.""ERC721_evt_Transfer""
    where contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'
        and ""from"" != '\x0000000000000000000000000000000000000000'

    union all

    select evt_block_time,
        ""to"" as address,
        (case when ""from"" = '\x0000000000000000000000000000000000000000' then 'mint'
            else 'receive'
        end) as transfer_type,
    1 as nft_count
    FROM erc721.""ERC721_evt_Transfer""
    where contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'
),

lens_users as (
    select transfer_type,
        count(distinct address) as full_time_user_count,
        sum(abs(nft_count)) as full_time_nft_count,
        count(distinct address) filter (where evt_block_time >= now() - interval '24 hours') as one_day_user_count,
        sum(abs(nft_count)) filter (where evt_block_time >= now() - interval '24 hours') as one_day_nft_count,
        count(distinct address) filter (where evt_block_time >= now() - interval '7 days') as seven_days_user_count,
        sum(abs(nft_count)) filter (where evt_block_time >= now() - interval '7 days') as seven_days_nft_count,
        count(distinct address) filter (where evt_block_time >= now() - interval '30 days') as thirty_days_user_count,
        sum(abs(nft_count)) filter (where evt_block_time >= now() - interval '30 days') as thirty_days_nft_count
    from lens_transfers
    group by transfer_type
),

lens_users_summary as (
    select count(distinct address) as total_full_time_user_count,
        sum(nft_count) as total_full_time_nft_count,
        count(distinct address) filter (where evt_block_time >= now() - interval '24 hours') as total_one_day_user_count,
        sum(nft_count) filter (where evt_block_time >= now() - interval '24 hours') as total_one_day_nft_count,
        count(distinct address) filter (where evt_block_time >= now() - interval '7 days') as total_seven_days_user_count,
        sum(nft_count) filter (where evt_block_time >= now() - interval '7 days') as total_seven_days_nft_count,
        count(distinct address) filter (where evt_block_time >= now() - interval '30 days') as total_thirty_days_user_count,
        sum(nft_count) filter (where evt_block_time >= now() - interval '30 days') as total_thirty_days_nft_count
    from lens_transfers
)

select transfer_type,
    full_time_user_count,
    full_time_nft_count,
    one_day_user_count,
    one_day_nft_count,
    seven_days_user_count,
    seven_days_nft_count,
    thirty_days_user_count,
    thirty_days_nft_count,
    total_full_time_user_count,
    total_full_time_nft_count,
    total_one_day_user_count,
    total_one_day_nft_count,
    total_seven_days_user_count,
    total_seven_days_nft_count,
    total_thirty_days_user_count,
    total_thirty_days_nft_count
from lens_users
join lens_users_summary on true

"
997847,Daily New Users 🌳,,table,"  --获得FPP
 with Allusers as(
 select date_trunc('day',call_block_time) as block_time, vars->>'handle' AS handle ,call_tx_hash from lens.""LensHub_call_createProfile"" where vars->>'followModule'='0x0000000000000000000000000000000000000000'  and call_success='true' 
 ) 
 select block_time, COUNT(*) from Allusers GROUP by block_time"
997922,Total Users 🌱,,counter,"  --获得FPP
 with Allusers1 as(
 select date_trunc('day',call_block_time) as block_time, vars->>'handle' AS handle ,call_tx_hash from lens.""LensHub_call_createProfile"" where vars->>'followModule'='0x0000000000000000000000000000000000000000'  and call_success='true' 
 )
 
 select COUNT(*) from Allusers1 "
996509,Lens Protocol DAU (Daily Active Users) 🌵,,table," With lensDAU AS (
 --评论
 SELECT date_trunc('day',call_block_time) as block_time,call_tx_hash, vars->>'profileId' AS profileId  from lens.""LensHub_call_commentWithSig"" where ""call_success""='true' 
 UNION ALL
 --发帖
 SELECT date_trunc('day',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM lens.""LensHub_call_postWithSig"" where  ""call_success""='true' 
  UNION ALL
 --收藏
 SELECT date_trunc('day',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM  lens.""LensHub_call_collectWithSig"" where  ""call_success""='true' 
 UNION ALL
--领Profile
 SELECT date_trunc('day',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM  lens.""LensHub_call_createProfile"" where  ""call_success""='true'
  UNION ALL
 --关注 (没有profileid)
 SELECT date_trunc('day',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM   lens.""LensHub_call_followWithSig"" where  ""call_success""='true' 
  UNION ALL
 --转发mirror
 SELECT date_trunc('day',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM   lens.""LensHub_call_mirrorWithSig"" where  ""call_success""='true' 
  UNION ALL
  --设置关注模块
 SELECT date_trunc('day',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM   lens.""LensHub_call_setFollowModuleWithSig"" where  ""call_success""='true' 
   UNION ALL
  --设置Dispatcher（切换账号？）lens.""LensHub_call_setDispatcherWithSig""
 SELECT date_trunc('day',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM   lens.""LensHub_call_setDispatcherWithSig"" where  ""call_success""='true' 
  UNION ALL
   --设置背景图片
 SELECT date_trunc('day',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM   lens.""LensHub_call_setDefaultProfileWithSig"" where  ""call_success""='true' 
 )

 SELECT  block_time ,COUNT(distinct profileId) as DAU from lensDAU GROUP by block_time
 
 
 


 "
997062,Lens Protocol MAU (Monthly Active Users)  🌴,,table," With lensDAU AS (
 --评论
 SELECT date_trunc('month',call_block_time) as block_time,call_tx_hash, vars->>'profileId' AS profileId  from lens.""LensHub_call_commentWithSig"" where ""call_success""='true' 
 UNION ALL
 --发帖
 SELECT date_trunc('month',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM lens.""LensHub_call_postWithSig"" where  ""call_success""='true' 
  UNION ALL
 --收藏
 SELECT date_trunc('month',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM  lens.""LensHub_call_collectWithSig"" where  ""call_success""='true' 
 UNION ALL
--领Profile
 SELECT date_trunc('month',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM  lens.""LensHub_call_createProfile"" where  ""call_success""='true'
  UNION ALL
 --关注
 SELECT date_trunc('month',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM   lens.""LensHub_call_followWithSig"" where  ""call_success""='true' 
  UNION ALL
 --转发mirror
 SELECT date_trunc('month',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM   lens.""LensHub_call_mirrorWithSig"" where  ""call_success""='true' 
  UNION ALL
  --设置关注模块
 SELECT date_trunc('month',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM   lens.""LensHub_call_setFollowModuleWithSig"" where  ""call_success""='true' 
   UNION ALL
  --设置Dispatcher（切换账号？）lens.""LensHub_call_setDispatcherWithSig""
 SELECT date_trunc('month',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM   lens.""LensHub_call_setDispatcherWithSig"" where  ""call_success""='true' 
  UNION ALL
   --设置背景图片
 SELECT date_trunc('month',call_block_time) as block_time,call_tx_hash,  vars->>'profileId' AS profileId  FROM   lens.""LensHub_call_setDefaultProfileWithSig"" where  ""call_success""='true'  
 
 )

 SELECT  block_time ,COUNT(distinct profileId) as MAU from lensDAU GROUP by block_time
 

  
 "
997878,Cumulative Users 🌲,,table,"  --获得FPP
 with Allusers1 as(
 select date_trunc('day',call_block_time) as block_time, vars->>'handle' AS handle ,call_tx_hash from lens.""LensHub_call_createProfile"" where vars->>'followModule'='0x0000000000000000000000000000000000000000'  and call_success='true' 
 ) 
 
 SELECT  

block_time,

SUM(num) OVER(ORDER BY block_time) Amount 

from (

 
 select block_time, COUNT(*) as num from Allusers1 GROUP by block_time )a
 
 
 "
998014,Followers Ranking 🌿,,table,"--SELECT * from lens.""LensHub_call_createProfile"" LIMIT 100  --包含handle 编号 adds

with allFollow as(
SELECT *,date_trunc('day',a.call_block_time) as block_time,a.call_tx_hash,   reverse(SUBSTRING(reverse(SUBSTRING( a.vars->>'profileIds' ,2)),2)) AS profileId ,a.output_0 
FROM   lens.""LensHub_call_followWithSig"" a

where  a.""call_success""='true' AND a.output_0[1]> 0 
)

SELECT  CASE
    WHEN profileId = 13::text THEN '0x3a5bd1e37b099ae3386d13947b6a90d97675e5e3'  
    WHEN profileId = 12::text THEN '0xd3b307753097430faedfdb89809610bf8e8f3203'
    WHEN profileId = 11778::text THEN '0xda1e2b80114f67093992a1443026f078c5299372' 
    WHEN profileId = 1::text THEN '0xdab8b0559186c1cb7638b2d4239268cb9cf83ac5' 
    WHEN profileId = 12539::text THEN '0x0a67a539698e7ef5685bcf79e4edca937d164b2e' 
    WHEN profileId = 9957::text THEN '0xb0a179c459484885d1875009110f3ce3064867b9' 	
    WHEN profileId = 5::text THEN '0x2e21f5d32841cf8c7da805185a041400bf15f21a' 
    ELSE profileId:: text
  END AS adds,
    CASE
    WHEN profileId = 13::text THEN    'yoginth.lens'
    WHEN profileId = 12::text THEN   'lenster.lens'
    WHEN profileId = 11778::text THEN 'rabbithole.lens'
    WHEN profileId = 1::text THEN  'lensprotocol'
    WHEN profileId = 12539::text THEN  'debridge.lens'
    WHEN profileId = 9957::text THEN 	'sismo.lens'
    WHEN profileId = 5::text THEN 'stani.lens' 
    ELSE profileId:: text
  END AS handle,
  profileId, COUNT(*) as amount from allFollow
GROUP by profileId
ORDER by amount desc
limit 5
 "
1001472,Proportion of Users According to Posts 🎄,,table,"WITH lens AS (
SELECT profile, COUNT(*) AS total 
FROM (
SELECT vars->>'profileId' AS profile FROM lens.""LensHub_call_postWithSig""
WHERE ""call_success"" = TRUE
UNION ALL
SELECT vars->>'profileId' AS profile FROM lens.""LensHub_call_post""
WHERE ""call_success"" = TRUE
)a
GROUP BY 1
-- ORDER BY 2 DESC
)

SELECT
  COUNT(*) AS lens_profile_counter,
  CASE
    WHEN lens.total >= 20  THEN ' 🔥🔥🔥🔥>20'
    WHEN lens.total >= 10  THEN ' 🔥🔥🔥>10'
    WHEN lens.total >= 5   THEN ' 🔥🔥  > 5'
    WHEN lens.total >= 2   THEN ' 🔥  > 1'
    WHEN lens.total >= 1   THEN ' ❄️  = 1'
    ELSE '0 post'
  END AS ""posts""
FROM lens
GROUP BY 2
ORDER BY 1 DESC"
1001537,Total Posts 📰,,counter,"SELECT COUNT(*) FROM (
SELECT * FROM lens.""LensHub_call_postWithSig""
UNION ALL
SELECT * FROM lens.""LensHub_call_post""
)a
WHERE ""call_success"" = TRUE"
885564,Lens Protocol - Top Posters,,table,"WITH lens_minted AS (
    SELECT
        date_trunc('day',evt_block_time) as ""mint_date""
        , ""to"" as ""owner""
        , ""tokenId""
    FROM erc721.""ERC721_evt_Transfer""
    WHERE contract_address = '\xdb46d1dc155634fbc732f92e853b10b288ad5a1d'
    AND ""from"" = '\x0000000000000000000000000000000000000000'
), lens_profile_creation AS (
    SELECT
        pg_typeof(vars)
        ,CONCAT('\x', substring(vars::json ->> 'to' from 3))::bytea as ""owner""
        ,vars::json ->> 'handle' AS ""handle""
        ,vars::json ->> 'imageURI' AS ""imageURI""
        ,vars::json ->> 'followModule' AS ""followModule""
        ,vars::json ->> 'followNFTURI' AS ""followNFTURI""
        ,vars::json ->> 'followModuleInitData' AS ""followModuleInitData""
    FROM lens.""ProfileCreationProxy_call_proxyCreateProfile""
), lens_posters AS (

    SELECT profile, COUNT(*) as post_count FROM (
    SELECT vars->>'profileId' AS profile FROM lens.""LensHub_call_postWithSig""
    WHERE ""call_success"" = TRUE
    UNION ALL
    SELECT vars->>'profileId' AS profile FROM lens.""LensHub_call_post""
    WHERE ""call_success"" = TRUE
    )a
    GROUP BY 1
    ORDER BY 2 DESC
), lens_owners_handles AS (
    SELECT
        COALESCE(m.owner, p.owner) as ""owner""
        ,m.""tokenId""
        ,CASE 
            -- special case
            WHEN m.owner = '\x6c77a5a88c0ae712baeabe12fea81532060dcbf5' THEN 'lensprotocol' 
            ELSE p.handle
        END as ""handle""
    FROM lens_minted m
    FULL JOIN lens_profile_creation p
    ON m.owner = p.owner
), lens_top_posters AS (
    SELECT 
        CONCAT('<a href=""https://lenster.xyz/u/',h.handle,'.lens','"" target=""_blank""> 🌿 </a>', ' ', h.handle) AS lens_profile
        ,p.profile as ""profileId"" 
        ,p.post_count
        ,h.owner -- wallet address
    FROM lens_posters p
    LEFT JOIN lens_owners_handles h
    ON p.profile = h.""tokenId""::TEXT
    ORDER BY p.post_count DESC
)

SELECT 
    DISTINCT lens_profile
    ,""profileId"" --Todo: some wallets have multiple lens handles
    ,post_count
    -- ,owner
FROM lens_top_posters
ORDER BY post_count DESC"
885692,Lens Protocol - Dispatcher Calls,,table,"WITH lens_dispatcher_calls AS (
    SELECT
        date_trunc('day', call_block_time) as ""date""
        ,vars
        ,call_tx_hash
        ,vars::json ->> 'profileId' AS ""profileId""
        ,CONCAT('\x', substring(vars::json ->> 'dispatcher' from 3))::bytea as ""dispatcher""
    FROM lens.""LensHub_call_setDispatcherWithSig"" 
    WHERE call_success = true
)

SELECT 
    ""date""
    ,COUNT(DISPATCHER) AS ""DISPATCHER_CALLS""
FROM LENS_DISPATCHER_CALLS
GROUP BY 1

-- SELECT * FROM lens_dispatcher_calls"
885984,Lens Protocol - Set ProfileImageURI Calls,,table,"WITH lens_set_profile_imageURI AS (
    SELECT
        date_trunc('day',call_block_time) as ""date""
        ,vars::json ->> 'profileId' AS ""profileId""
        ,vars::json ->> 'imageURI' AS ""imageURI""
    FROM lens.""LensHub_call_setProfileImageURIWithSig""
    WHERE call_success = true
)
SELECT 
    ""date""
    ,COUNT(""profileId"") as ""set_ProfileImageURI_calls""
FROM lens_set_profile_imageURI
GROUP BY 1"
